import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { parseArgs } from 'node:util';

function round(value, digits = 2) {
  const factor = 10 ** digits;
  return Math.round(value * factor) / factor;
}

function buildEvidenceSummary(summary) {
  const memoryMet = summary.performance.memoryPerKLOC <= summary.performance.targetMemoryPerKLOC;
  const liftMet = summary.ab.lift >= summary.ab.targetLift;
  const scenarioPassRate = summary.scenarios.total > 0
    ? summary.scenarios.passing / summary.scenarios.total
    : 0;
  return {
    ...summary,
    derived: {
      memoryMet,
      liftMet,
      scenarioPassRate,
    },
  };
}

function renderStatusBlock(summary) {
  const metrics = summary.metrics;
  const rows = [
    ['Retrieval Recall@5', metrics.retrievalRecallAt5.target, metrics.retrievalRecallAt5.mean, metrics.retrievalRecallAt5.met],
    ['Context Precision', metrics.contextPrecision.target, metrics.contextPrecision.mean, metrics.contextPrecision.met],
    ['Hallucination Rate', metrics.hallucinationRate.target, metrics.hallucinationRate.mean, metrics.hallucinationRate.met],
    ['Faithfulness', metrics.faithfulness.target, metrics.faithfulness.mean, metrics.faithfulness.met],
    ['Answer Relevancy', metrics.answerRelevancy.target, metrics.answerRelevancy.mean, metrics.answerRelevancy.met],
  ];

  const metricLines = rows
    .map(([name, target, measured, met]) => {
      const status = met ? 'MET' : 'NOT MET';
      return `| ${name} | ${target} | ${measured} | ${status} |`;
    })
    .join('\n');

  const memoryStatus = summary.derived.memoryMet ? 'MET' : 'NOT MET';
  const liftStatus = summary.derived.liftMet ? 'MET' : 'NOT MET';
  const scenarioRate = round(summary.derived.scenarioPassRate * 100, 1);

  return [
    '### Evidence-Backed Status (Autogenerated)',
    `Generated: ${summary.generatedAt}`,
    '',
    '| Metric | Target | Measured | Status |',
    '| --- | --- | --- | --- |',
    metricLines,
    '',
    `| A/B Lift | ${summary.ab.targetLift} | ${round(summary.ab.lift, 4)} (p-value ${round(summary.ab.pValue, 4)}) | ${liftStatus} |`,
    `| Memory per 1K LOC | ${summary.performance.targetMemoryPerKLOC} MB | ${round(summary.performance.memoryPerKLOC, 2)} MB | ${memoryStatus} |`,
    '',
    `Scenario Families: ${summary.scenarios.passing}/${summary.scenarios.total} (${scenarioRate}%)`,
  ].join('\n');
}

function renderValidationBlock(summary) {
  const scenarioRate = round(summary.derived.scenarioPassRate * 100, 1);
  return [
    '### Validation Summary (Autogenerated)',
    `Generated: ${summary.generatedAt}`,
    '',
    `Scenario Families: ${summary.scenarios.passing}/${summary.scenarios.total} (${scenarioRate}%)`,
    `A/B Lift: ${round(summary.ab.lift, 4)} (p-value ${round(summary.ab.pValue, 4)})`,
    `Memory per 1K LOC: ${round(summary.performance.memoryPerKLOC, 2)} MB (target ${summary.performance.targetMemoryPerKLOC} MB)`,
  ].join('\n');
}

function applyAutogenBlock(contents, markerName, newBlock) {
  const start = `<!-- ${markerName}_START -->`;
  const end = `<!-- ${markerName}_END -->`;
  const startIdx = contents.indexOf(start);
  const endIdx = contents.indexOf(end);

  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    return `${contents}\n${start}\n${newBlock}\n${end}`;
  }

  const before = contents.slice(0, startIdx + start.length);
  const after = contents.slice(endIdx);
  return `${before}\n${newBlock}\n${after}`;
}

function reconcileGates(gates, summary) {
  const next = { ...gates };
  next.lastUpdated = summary.generatedAt;
  const blockingMetrics = {
    'Retrieval Recall@5': {
      target: `>=${summary.metrics.retrievalRecallAt5.target}`,
      measured: `${summary.metrics.retrievalRecallAt5.mean}`,
      status: summary.metrics.retrievalRecallAt5.met ? 'MET' : 'NOT MET',
    },
    'Context Precision': {
      target: `>=${summary.metrics.contextPrecision.target}`,
      measured: `${summary.metrics.contextPrecision.mean}`,
      status: summary.metrics.contextPrecision.met ? 'MET' : 'NOT MET',
    },
    'Hallucination Rate': {
      target: `<${summary.metrics.hallucinationRate.target}`,
      measured: `${summary.metrics.hallucinationRate.mean}`,
      status: summary.metrics.hallucinationRate.met ? 'MET' : 'NOT MET',
    },
    'Faithfulness': {
      target: `>=${summary.metrics.faithfulness.target}`,
      measured: `${summary.metrics.faithfulness.mean}`,
      status: summary.metrics.faithfulness.met ? 'MET' : 'NOT MET',
    },
    'Answer Relevancy': {
      target: `>=${summary.metrics.answerRelevancy.target}`,
      measured: `${summary.metrics.answerRelevancy.mean}`,
      status: summary.metrics.answerRelevancy.met ? 'MET' : 'NOT MET',
    },
    'A/B Lift': {
      target: `>=${summary.ab.targetLift}`,
      measured: `${summary.ab.lift} (p=${summary.ab.pValue})`,
      status: summary.derived.liftMet ? 'MET' : 'NOT MET',
    },
    'Memory per 1K LOC': {
      target: `<=${summary.performance.targetMemoryPerKLOC} MB`,
      measured: `${summary.performance.memoryPerKLOC} MB`,
      status: summary.derived.memoryMet ? 'MET' : 'NOT MET',
    },
  };

  if (!next.validationStatus) {
    next.validationStatus = {};
  }
  next.validationStatus.blockingMetrics = blockingMetrics;
  next.validationStatus.lastVerified = summary.generatedAt;
  return next;
}

async function main() {
  const { values } = parseArgs({
    args: process.argv.slice(2),
    options: {
      manifest: { type: 'string' },
      dryRun: { type: 'boolean', default: false },
    },
  });

  const root = process.cwd();
  const manifestPath = values.manifest
    ? path.resolve(values.manifest)
    : path.join(root, 'state', 'audits', 'librarian', 'manifest.json');

  const manifestRaw = await readFile(manifestPath, 'utf8');
  const manifest = JSON.parse(manifestRaw);
  if (!manifest.summary) {
    throw new Error('manifest.summary is required for reconciliation');
  }

  const summary = buildEvidenceSummary(manifest.summary);

  const statusPath = path.join(root, 'docs', 'librarian', 'STATUS.md');
  const validationPath = path.join(root, 'docs', 'librarian', 'validation.md');
  const gatesPath = path.join(root, 'docs', 'librarian', 'GATES.json');

  const statusContents = await readFile(statusPath, 'utf8');
  const validationContents = await readFile(validationPath, 'utf8');
  const gatesContents = await readFile(gatesPath, 'utf8');

  const statusUpdated = applyAutogenBlock(statusContents, 'EVIDENCE_AUTOGEN', renderStatusBlock(summary));
  const validationUpdated = applyAutogenBlock(validationContents, 'EVIDENCE_AUTOGEN', renderValidationBlock(summary));
  const gatesUpdated = JSON.stringify(reconcileGates(JSON.parse(gatesContents), summary), null, 2) + '\n';

  if (!values.dryRun) {
    await writeFile(statusPath, statusUpdated);
    await writeFile(validationPath, validationUpdated);
    await writeFile(gatesPath, gatesUpdated);
  }

  console.log('Reconciliation complete.');
  if (values.dryRun) {
    console.log('Dry run: no files written.');
  }
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
