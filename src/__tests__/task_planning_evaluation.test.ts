/**
 * @fileoverview Task Planning Quality Evaluation
 *
 * This test suite evaluates the quality and usefulness of task plans
 * generated by the planTask API. It tests with realistic task descriptions
 * and validates that plans would be usable by an agent.
 *
 * Evaluation criteria:
 * 1. Realism: Do plans identify the right files to modify?
 * 2. Step Ordering: Are dependencies sensible?
 * 3. Risk Assessment: Are risks appropriate and actionable?
 * 4. Agent Usability: Could an agent follow the plan?
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import * as path from 'path';
import * as os from 'os';
import * as fs from 'fs/promises';
import { planTask, type TaskPlan } from '../api/task_planning.js';
import { createSqliteStorage } from '../storage/sqlite_storage.js';
import type { LibrarianStorage, ModuleRecord, FunctionRecord } from '../storage/types.js';

// ============================================================================
// TEST CONFIGURATION
// ============================================================================

const WORKSPACE = '/Volumes/BigSSD4/nathanielschmiedehaus/Documents/software/librarian';

// Test task descriptions - real-world scenarios
const TEST_TASKS = [
  {
    description: 'Add support for GraphQL schema analysis',
    expectedType: 'feature_add',
    expectedPatterns: ['api'],
    minContextFiles: 0,
    shouldHaveSteps: true,
  },
  {
    description: 'Optimize the slow vector search performance',
    expectedType: 'performance',
    expectedPatterns: [],
    minContextFiles: 0,
    shouldHaveSteps: true,
  },
  {
    description: 'Add Python language support',
    expectedType: 'feature_add',
    expectedPatterns: [],
    minContextFiles: 0,
    shouldHaveSteps: true,
  },
  {
    description: 'Fix the query caching bug that causes stale results',
    expectedType: 'bug_fix',
    expectedPatterns: ['query', 'cache'],
    minContextFiles: 0,
    shouldHaveSteps: true,
  },
  {
    description: 'Refactor the storage layer to use a plugin architecture',
    expectedType: 'refactor',
    expectedPatterns: ['storage'],
    minContextFiles: 0,
    shouldHaveSteps: true,
  },
  {
    description: 'Encrypt sensitive data and sanitize user inputs for security',
    expectedType: 'security',
    expectedPatterns: ['api', 'security'],
    minContextFiles: 0,
    shouldHaveSteps: true,
  },
];

// ============================================================================
// EVALUATION HELPERS
// ============================================================================

interface PlanEvaluation {
  task: string;
  plan: TaskPlan;
  scores: {
    realism: number;
    stepOrdering: number;
    riskAssessment: number;
    agentUsability: number;
    overall: number;
  };
  issues: string[];
  strengths: string[];
}

function evaluatePlanRealism(plan: TaskPlan): { score: number; issues: string[]; strengths: string[] } {
  const issues: string[] = [];
  const strengths: string[] = [];
  let score = 0.5; // Base score

  // Check if context files are identified
  if (plan.contextFiles.length > 0) {
    score += 0.1;
    strengths.push(`Identified ${plan.contextFiles.length} context files`);
  } else {
    issues.push('No context files identified');
  }

  // Check if files to modify are identified
  if (plan.filesToModify.length > 0) {
    score += 0.1;
    strengths.push(`Identified ${plan.filesToModify.length} files to modify`);
  }

  // Check if test requirements are present
  if (plan.testsRequired.length > 0) {
    score += 0.1;
    strengths.push(`Identified ${plan.testsRequired.length} test requirements`);
  } else {
    issues.push('No test requirements identified');
  }

  // Check complexity assessment
  if (['trivial', 'simple', 'moderate', 'complex', 'epic'].includes(plan.complexity)) {
    score += 0.1;
    strengths.push(`Complexity assessed as ${plan.complexity}`);
  }

  // Check estimated scope
  if (plan.estimatedScope.filesAffected > 0) {
    score += 0.1;
    strengths.push(`Estimated ${plan.estimatedScope.filesAffected} files affected`);
  }

  return { score: Math.min(1, score), issues, strengths };
}

function evaluateStepOrdering(plan: TaskPlan): { score: number; issues: string[]; strengths: string[] } {
  const issues: string[] = [];
  const strengths: string[] = [];
  let score = 0.5;

  // Check if steps exist
  if (plan.steps.length === 0) {
    issues.push('No steps in plan');
    return { score: 0, issues, strengths };
  }

  // Check step ordering is sequential
  const orders = plan.steps.map(s => s.order);
  const isSequential = orders.every((val, i) => i === 0 || val > orders[i - 1]);
  if (isSequential) {
    score += 0.2;
    strengths.push('Steps are in sequential order');
  } else {
    issues.push('Steps are not in sequential order');
  }

  // Check dependencies are valid (must reference earlier steps)
  let validDependencies = true;
  for (const step of plan.steps) {
    for (const dep of step.dependencies) {
      if (dep >= step.order) {
        validDependencies = false;
        issues.push(`Step ${step.order} depends on step ${dep} which comes after or at the same position`);
      }
    }
  }
  if (validDependencies) {
    score += 0.2;
    strengths.push('All step dependencies are valid');
  }

  // Check first step is context reading
  const firstStep = plan.steps[0];
  if (firstStep && firstStep.action === 'read') {
    score += 0.1;
    strengths.push('Plan starts with reading context');
  } else {
    issues.push('Plan does not start with reading context');
  }

  return { score: Math.min(1, score), issues, strengths };
}

function evaluateRiskAssessment(plan: TaskPlan): { score: number; issues: string[]; strengths: string[] } {
  const issues: string[] = [];
  const strengths: string[] = [];
  let score = 0.5;

  // Check if risks are identified
  if (plan.risks.length > 0) {
    score += 0.2;
    strengths.push(`Identified ${plan.risks.length} risks`);
  }

  // Check if risks have mitigations
  const risksWithMitigations = plan.risks.filter(r => r.mitigation && r.mitigation.length > 0);
  if (risksWithMitigations.length === plan.risks.length && plan.risks.length > 0) {
    score += 0.2;
    strengths.push('All risks have mitigations');
  } else if (risksWithMitigations.length < plan.risks.length) {
    issues.push(`${plan.risks.length - risksWithMitigations.length} risks without mitigations`);
  }

  // Check preflight checks
  if (plan.preflightChecks.length > 0) {
    score += 0.1;
    strengths.push(`${plan.preflightChecks.length} preflight checks identified`);
  } else {
    issues.push('No preflight checks identified');
  }

  return { score: Math.min(1, score), issues, strengths };
}

function evaluateAgentUsability(plan: TaskPlan): { score: number; issues: string[]; strengths: string[] } {
  const issues: string[] = [];
  const strengths: string[] = [];
  let score = 0.5;

  // Check if steps have clear actions
  const stepsWithActions = plan.steps.filter(s => s.action && s.action.length > 0);
  if (stepsWithActions.length === plan.steps.length) {
    score += 0.15;
    strengths.push('All steps have clear actions');
  } else {
    issues.push('Some steps lack clear actions');
  }

  // Check if steps have targets
  const stepsWithTargets = plan.steps.filter(s => s.target && s.target.length > 0);
  if (stepsWithTargets.length === plan.steps.length) {
    score += 0.15;
    strengths.push('All steps have clear targets');
  } else {
    issues.push('Some steps lack clear targets');
  }

  // Check if steps have verification criteria
  const stepsWithVerification = plan.steps.filter(s => s.verification && s.verification.length > 0);
  if (stepsWithVerification.length === plan.steps.length) {
    score += 0.1;
    strengths.push('All steps have verification criteria');
  } else {
    issues.push('Some steps lack verification criteria');
  }

  // Check if context files have priorities
  const filesWithPriorities = plan.contextFiles.filter(f => f.priority);
  if (filesWithPriorities.length === plan.contextFiles.length && plan.contextFiles.length > 0) {
    score += 0.1;
    strengths.push('All context files have priorities');
  }

  return { score: Math.min(1, score), issues, strengths };
}

function evaluatePlan(task: string, plan: TaskPlan): PlanEvaluation {
  const realism = evaluatePlanRealism(plan);
  const stepOrdering = evaluateStepOrdering(plan);
  const riskAssessment = evaluateRiskAssessment(plan);
  const agentUsability = evaluateAgentUsability(plan);

  const overall = (
    realism.score * 0.25 +
    stepOrdering.score * 0.25 +
    riskAssessment.score * 0.25 +
    agentUsability.score * 0.25
  );

  return {
    task,
    plan,
    scores: {
      realism: realism.score,
      stepOrdering: stepOrdering.score,
      riskAssessment: riskAssessment.score,
      agentUsability: agentUsability.score,
      overall,
    },
    issues: [
      ...realism.issues,
      ...stepOrdering.issues,
      ...riskAssessment.issues,
      ...agentUsability.issues,
    ],
    strengths: [
      ...realism.strengths,
      ...stepOrdering.strengths,
      ...riskAssessment.strengths,
      ...agentUsability.strengths,
    ],
  };
}

// ============================================================================
// MOCK DATA FOR REALISTIC TESTING
// ============================================================================

// Simulate real functions from the librarian codebase
const MOCK_FUNCTIONS: FunctionRecord[] = [
  {
    id: 'fn-query-1',
    filePath: path.join(WORKSPACE, 'src/api/query.ts'),
    name: 'queryLibrarian',
    purpose: 'Main query function that handles all librarian queries',
    signature: 'async function queryLibrarian(query: LibrarianQuery, storage: LibrarianStorage): Promise<LibrarianResponse>',
    startLine: 100,
    endLine: 200,
    confidence: 0.9,
    accessCount: 50,
    lastAccessed: new Date(),
    validationCount: 10,
    outcomeHistory: { successes: 45, failures: 5 },
  },
  {
    id: 'fn-storage-1',
    filePath: path.join(WORKSPACE, 'src/storage/sqlite_storage.ts'),
    name: 'createSqliteStorage',
    purpose: 'Creates a SQLite storage backend for the librarian',
    signature: 'function createSqliteStorage(dbPath: string, workspace: string): LibrarianStorage',
    startLine: 50,
    endLine: 100,
    confidence: 0.95,
    accessCount: 30,
    lastAccessed: new Date(),
    validationCount: 8,
    outcomeHistory: { successes: 28, failures: 2 },
  },
  {
    id: 'fn-embed-1',
    filePath: path.join(WORKSPACE, 'src/api/embeddings.ts'),
    name: 'generateEmbedding',
    purpose: 'Generate embeddings for semantic search using vector models',
    signature: 'async function generateEmbedding(text: string): Promise<Float32Array>',
    startLine: 75,
    endLine: 120,
    confidence: 0.85,
    accessCount: 100,
    lastAccessed: new Date(),
    validationCount: 20,
    outcomeHistory: { successes: 90, failures: 10 },
  },
  {
    id: 'fn-cache-1',
    filePath: path.join(WORKSPACE, 'src/storage/content_cache.ts'),
    name: 'getCachedContent',
    purpose: 'Retrieve cached content to improve query performance',
    signature: 'async function getCachedContent(key: string): Promise<CacheEntry | null>',
    startLine: 30,
    endLine: 60,
    confidence: 0.88,
    accessCount: 200,
    lastAccessed: new Date(),
    validationCount: 15,
    outcomeHistory: { successes: 180, failures: 20 },
  },
  {
    id: 'fn-vector-1',
    filePath: path.join(WORKSPACE, 'src/storage/vector_index.ts'),
    name: 'findSimilarByVector',
    purpose: 'Find similar documents using vector similarity search',
    signature: 'async function findSimilarByVector(embedding: Float32Array, limit: number): Promise<SimilarityResult[]>',
    startLine: 100,
    endLine: 180,
    confidence: 0.82,
    accessCount: 150,
    lastAccessed: new Date(),
    validationCount: 12,
    outcomeHistory: { successes: 140, failures: 10 },
  },
  {
    id: 'fn-api-1',
    filePath: path.join(WORKSPACE, 'src/api/librarian.ts'),
    name: 'query',
    purpose: 'API endpoint handler for librarian queries',
    signature: 'async query(query: LibrarianQuery): Promise<LibrarianResponse>',
    startLine: 500,
    endLine: 550,
    confidence: 0.9,
    accessCount: 80,
    lastAccessed: new Date(),
    validationCount: 18,
    outcomeHistory: { successes: 75, failures: 5 },
  },
];

const MOCK_MODULES: ModuleRecord[] = [
  {
    id: 'mod-api-1',
    path: path.join(WORKSPACE, 'src/api/query.ts'),
    purpose: 'Query API module - handles all librarian queries and context assembly',
    exports: ['queryLibrarian', 'createFunctionQuery', 'createFileQuery'],
    dependencies: ['../storage/types.js', '../types.js', './embeddings.js'],
    confidence: 0.9,
  },
  {
    id: 'mod-storage-1',
    path: path.join(WORKSPACE, 'src/storage/sqlite_storage.ts'),
    purpose: 'SQLite storage implementation for librarian data persistence',
    exports: ['createSqliteStorage', 'SqliteStorage'],
    dependencies: ['better-sqlite3', '../types.js', './types.js'],
    confidence: 0.95,
  },
  {
    id: 'mod-embed-1',
    path: path.join(WORKSPACE, 'src/api/embeddings.ts'),
    purpose: 'Embedding service for generating vector embeddings',
    exports: ['EmbeddingService', 'generateEmbedding', 'cosineSimilarity'],
    dependencies: ['@xenova/transformers', '../types.js'],
    confidence: 0.85,
  },
  {
    id: 'mod-cache-1',
    path: path.join(WORKSPACE, 'src/storage/content_cache.ts'),
    purpose: 'Content caching module for improved query performance',
    exports: ['ContentCache', 'getCachedContent', 'setCachedContent'],
    dependencies: ['./types.js', '../utils/index.js'],
    confidence: 0.88,
  },
  {
    id: 'mod-vector-1',
    path: path.join(WORKSPACE, 'src/storage/vector_index.ts'),
    purpose: 'Vector index for similarity search operations',
    exports: ['VectorIndex', 'findSimilarByVector', 'addVector'],
    dependencies: ['./types.js', '../api/embeddings.js'],
    confidence: 0.82,
  },
];

// ============================================================================
// TESTS
// ============================================================================

describe('Task Planning Quality Evaluation', () => {
  let storage: LibrarianStorage | null = null;
  let tempDbPath: string | null = null;
  const evaluations: PlanEvaluation[] = [];

  beforeAll(async () => {
    // Create a temporary database for testing
    tempDbPath = path.join(os.tmpdir(), `librarian-test-${Date.now()}.sqlite`);

    storage = createSqliteStorage(tempDbPath, WORKSPACE);
    await storage.initialize();

    // Populate with mock data
    for (const fn of MOCK_FUNCTIONS) {
      await storage.upsertFunction(fn);
    }
    for (const mod of MOCK_MODULES) {
      await storage.upsertModule(mod);
    }
  });

  afterAll(async () => {
    if (storage) {
      await storage.close();
    }

    // Cleanup temp database
    if (tempDbPath) {
      try {
        await fs.unlink(tempDbPath);
        await fs.unlink(tempDbPath + '-shm').catch(() => {});
        await fs.unlink(tempDbPath + '-wal').catch(() => {});
      } catch {
        // Ignore cleanup errors
      }
    }

    // Print summary report
    if (evaluations.length > 0) {
      console.log('\n');
      console.log('='.repeat(80));
      console.log('TASK PLANNING QUALITY EVALUATION REPORT');
      console.log('='.repeat(80));
      console.log('\n');

      for (const evaluation of evaluations) {
        console.log('-'.repeat(80));
        console.log(`Task: ${evaluation.task}`);
        console.log(`Classification: ${evaluation.plan.classification}`);
        console.log(`Complexity: ${evaluation.plan.complexity}`);
        console.log(`Planning Time: ${evaluation.plan.planningTimeMs}ms`);
        console.log(`Confidence: ${(evaluation.plan.confidence * 100).toFixed(1)}%`);
        console.log(`\nScores:`);
        console.log(`  Realism:        ${(evaluation.scores.realism * 100).toFixed(0)}%`);
        console.log(`  Step Ordering:  ${(evaluation.scores.stepOrdering * 100).toFixed(0)}%`);
        console.log(`  Risk Assessment: ${(evaluation.scores.riskAssessment * 100).toFixed(0)}%`);
        console.log(`  Agent Usability: ${(evaluation.scores.agentUsability * 100).toFixed(0)}%`);
        console.log(`  OVERALL:        ${(evaluation.scores.overall * 100).toFixed(0)}%`);
        console.log(`\nSteps (${evaluation.plan.steps.length}):`);
        for (const step of evaluation.plan.steps) {
          const details = step.details.length > 60 ? step.details.substring(0, 57) + '...' : step.details;
          console.log(`  ${step.order}. [${step.action}] ${step.target}`);
          console.log(`      ${details}`);
        }
        console.log(`\nContext Files (${evaluation.plan.contextFiles.length}):`);
        for (const file of evaluation.plan.contextFiles.slice(0, 5)) {
          console.log(`  [${file.priority}] ${file.path}`);
        }
        if (evaluation.plan.contextFiles.length > 5) {
          console.log(`  ... and ${evaluation.plan.contextFiles.length - 5} more`);
        }
        console.log(`\nRisks (${evaluation.plan.risks.length}):`);
        for (const risk of evaluation.plan.risks) {
          const riskText = risk.risk.length > 60 ? risk.risk.substring(0, 57) + '...' : risk.risk;
          console.log(`  [${risk.likelihood}] ${riskText}`);
        }
        console.log(`\nStrengths: ${evaluation.strengths.length}`);
        for (const strength of evaluation.strengths.slice(0, 5)) {
          console.log(`  + ${strength}`);
        }
        console.log(`\nIssues: ${evaluation.issues.length}`);
        for (const issue of evaluation.issues) {
          console.log(`  - ${issue}`);
        }
        console.log('\n');
      }

      // Overall summary
      const avgScores = {
        realism: evaluations.reduce((sum, e) => sum + e.scores.realism, 0) / evaluations.length,
        stepOrdering: evaluations.reduce((sum, e) => sum + e.scores.stepOrdering, 0) / evaluations.length,
        riskAssessment: evaluations.reduce((sum, e) => sum + e.scores.riskAssessment, 0) / evaluations.length,
        agentUsability: evaluations.reduce((sum, e) => sum + e.scores.agentUsability, 0) / evaluations.length,
        overall: evaluations.reduce((sum, e) => sum + e.scores.overall, 0) / evaluations.length,
      };

      console.log('='.repeat(80));
      console.log('OVERALL SUMMARY');
      console.log('='.repeat(80));
      console.log(`\nAverage Scores Across ${evaluations.length} Tasks:`);
      console.log(`  Realism:         ${(avgScores.realism * 100).toFixed(0)}%`);
      console.log(`  Step Ordering:   ${(avgScores.stepOrdering * 100).toFixed(0)}%`);
      console.log(`  Risk Assessment: ${(avgScores.riskAssessment * 100).toFixed(0)}%`);
      console.log(`  Agent Usability: ${(avgScores.agentUsability * 100).toFixed(0)}%`);
      console.log(`  OVERALL:         ${(avgScores.overall * 100).toFixed(0)}%`);

      const verdict = avgScores.overall >= 0.7 ? 'USEFUL' : avgScores.overall >= 0.5 ? 'SOMEWHAT USEFUL' : 'NEEDS IMPROVEMENT';
      console.log(`\nVerdict: Plans are ${verdict} for agent guidance.`);
      console.log('='.repeat(80));
    }
  });

  for (const testTask of TEST_TASKS) {
    it(`should generate a useful plan for: "${testTask.description}"`, async () => {
      if (!storage) {
        console.log('Skipping test - storage not initialized');
        return;
      }

      const plan = await planTask(storage, testTask.description, WORKSPACE);

      // Validate basic structure
      expect(plan.task).toBe(testTask.description);
      expect(plan.classification).toBe(testTask.expectedType);
      expect(plan.steps.length).toBeGreaterThan(0);
      expect(plan.confidence).toBeGreaterThan(0);
      expect(plan.confidence).toBeLessThanOrEqual(1);

      // Evaluate the plan
      const evaluation = evaluatePlan(testTask.description, plan);
      evaluations.push(evaluation);

      // Minimum quality thresholds
      expect(evaluation.scores.stepOrdering).toBeGreaterThanOrEqual(0.5);
      expect(evaluation.scores.agentUsability).toBeGreaterThanOrEqual(0.5);
      expect(evaluation.scores.overall).toBeGreaterThanOrEqual(0.4);
    });
  }

  it('should identify relevant files when context is available', async () => {
    if (!storage) {
      console.log('Skipping test - storage not initialized');
      return;
    }

    // Test with a task that should match existing code
    const plan = await planTask(storage, 'Add caching to the query handler', WORKSPACE);

    // This tests the real-world scenario where storage has indexed content
    expect(plan.steps.length).toBeGreaterThan(0);
    expect(plan.planningTimeMs).toBeLessThan(5000); // Should be fast

    // Should find cache-related context files
    const cacheRelated = plan.contextFiles.filter(f =>
      f.path.includes('cache') || f.reason.toLowerCase().includes('cache')
    );
    expect(cacheRelated.length).toBeGreaterThan(0);
  });

  it('should handle empty/new projects gracefully', async () => {
    // Create a storage with no data
    const emptyDbPath = path.join(os.tmpdir(), `librarian-empty-${Date.now()}.sqlite`);
    const emptyStorage = createSqliteStorage(emptyDbPath, WORKSPACE);
    await emptyStorage.initialize();

    try {
      // Even with minimal context, should produce a valid plan
      const plan = await planTask(emptyStorage, 'Implement a completely new feature with no existing code', WORKSPACE);

      expect(plan.steps.length).toBeGreaterThan(0);
      expect(plan.classification).toBe('feature_add');
      expect(plan.confidence).toBeGreaterThan(0);
    } finally {
      await emptyStorage.close();
      await fs.unlink(emptyDbPath).catch(() => {});
    }
  });

  it('should produce consistent plans for the same task', async () => {
    if (!storage) {
      console.log('Skipping test - storage not initialized');
      return;
    }

    const task = 'Add logging to the API handlers';
    const plan1 = await planTask(storage, task, WORKSPACE);
    const plan2 = await planTask(storage, task, WORKSPACE);

    // Classification should be consistent
    expect(plan1.classification).toBe(plan2.classification);
    expect(plan1.complexity).toBe(plan2.complexity);

    // Step structure should be similar (same count at minimum)
    expect(plan1.steps.length).toBe(plan2.steps.length);
  });

  it('should identify security risks for security-related tasks', async () => {
    if (!storage) {
      console.log('Skipping test - storage not initialized');
      return;
    }

    // Use explicit security keywords to trigger security classification
    const plan = await planTask(storage, 'Encrypt sensitive data and sanitize user inputs for security', WORKSPACE);

    expect(plan.classification).toBe('security');
    expect(plan.risks.length).toBeGreaterThan(0);

    // Should have security-specific risks
    const securityRisks = plan.risks.filter(r =>
      r.risk.toLowerCase().includes('security') ||
      r.risk.toLowerCase().includes('vulnerab')
    );
    expect(securityRisks.length).toBeGreaterThan(0);
  });

  it('should generate appropriate steps for refactoring tasks', async () => {
    if (!storage) {
      console.log('Skipping test - storage not initialized');
      return;
    }

    const plan = await planTask(storage, 'Refactor the storage layer to use a plugin architecture', WORKSPACE);

    expect(plan.classification).toBe('refactor');

    // Should have an identify step for refactoring targets
    const identifyStep = plan.steps.find(s => s.action === 'identify');
    expect(identifyStep).toBeDefined();

    // Should have preflight check about test coverage
    const testCoverageCheck = plan.preflightChecks.find(c =>
      c.toLowerCase().includes('test') || c.toLowerCase().includes('coverage')
    );
    expect(testCoverageCheck).toBeDefined();
  });

  it('should find vector/embedding related context for performance tasks', async () => {
    if (!storage) {
      console.log('Skipping test - storage not initialized');
      return;
    }

    // Use explicit performance keywords
    const plan = await planTask(storage, 'Optimize the slow vector search for better latency', WORKSPACE);

    expect(plan.classification).toBe('performance');

    // Should find vector-related functions
    const vectorContext = plan.contextFiles.filter(f =>
      f.path.includes('vector') ||
      f.path.includes('embed') ||
      f.reason.toLowerCase().includes('vector') ||
      f.reason.toLowerCase().includes('embed') ||
      f.reason.toLowerCase().includes('similar')
    );
    expect(vectorContext.length).toBeGreaterThan(0);
  });
});
