import type { LibrarianStorage } from '../storage/types.js';
import { createTechniquePrimitive, type TechniquePrimitive } from '../strategic/techniques.js';
import {
  listTechniquePrimitives,
  saveTechniquePrimitive,
  deleteTechniquePrimitive,
} from '../state/technique_primitives.js';
import { absent } from '../epistemics/confidence.js';

export const DEFAULT_TECHNIQUE_PRIMITIVES: TechniquePrimitive[] = [
  createTechniquePrimitive({
    id: 'tp_clarify_goal',
    name: 'Clarify goal and scope',
    intent: 'Turn a vague request into an explicit goal and scope.',
    triggers: ['ambiguous request', 'conflicting requirements', 'missing success criteria'],
    inputsRequired: ['initial request', 'constraints', 'stakeholders'],
    actions: ['Ask clarifying questions', 'Define success criteria', 'Confirm scope and exclusions'],
    failureModes: ['Assumes unstated requirements', 'Overly broad scope'],
    outputs: ['goal statement', 'scope boundaries', 'success criteria'],
  }),
  createTechniquePrimitive({
    id: 'tp_list_constraints',
    name: 'Enumerate constraints',
    intent: 'Capture constraints that bound the solution space.',
    triggers: ['unexpected failures', 'design tradeoffs', 'time pressure'],
    inputsRequired: ['requirements', 'environment limits', 'non-negotiables'],
    actions: ['List hard constraints', 'Rank soft constraints', 'Validate with stakeholders'],
    failureModes: ['Ignores hidden constraints', 'Confuses preferences with constraints'],
    outputs: ['constraint list', 'constraint priorities'],
  }),
  createTechniquePrimitive({
    id: 'tp_decompose',
    name: 'Decompose into subproblems',
    intent: 'Break complex tasks into smaller, verifiable steps.',
    triggers: ['large scope', 'multi-step deliverable', 'many unknowns'],
    inputsRequired: ['goal statement', 'current state'],
    actions: ['Identify subgoals', 'Order by dependency', 'Define checkpoints'],
    failureModes: ['Creates non-actionable steps', 'Misses critical dependencies'],
    outputs: ['subproblem list', 'dependency order', 'checkpoint list'],
  }),
  createTechniquePrimitive({
    id: 'tp_search_history',
    name: 'Search prior solutions',
    intent: 'Locate similar past work to reuse decisions and evidence.',
    triggers: ['recurring issue', 'known class of bug', 'repeated question'],
    inputsRequired: ['problem description', 'keywords'],
    actions: ['Search episodes', 'Review prior fixes', 'Extract reusable steps'],
    failureModes: ['Assumes similarity where none exists', 'Copies outdated approach'],
    outputs: ['related episodes', 'reusable steps', 'known pitfalls'],
  }),
  createTechniquePrimitive({
    id: 'tp_hypothesis',
    name: 'Generate hypotheses',
    intent: 'Propose multiple plausible causes or solution paths.',
    triggers: ['uncertain root cause', 'many possible explanations'],
    inputsRequired: ['observations', 'constraints'],
    actions: ['List hypotheses', 'Rank by likelihood', 'Define discriminating tests'],
    failureModes: ['Stops at first hypothesis', 'No falsifiable tests'],
    outputs: ['hypothesis list', 'test plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_bisect',
    name: 'Bisect and isolate',
    intent: 'Narrow down a failure by binary search or isolation.',
    triggers: ['regression', 'unknown change point', 'large surface area'],
    inputsRequired: ['timeline', 'change list'],
    actions: ['Choose pivot', 'Test midpoint', 'Repeat until isolated'],
    failureModes: ['Unstable signal', 'Non-deterministic tests'],
    outputs: ['isolated change window', 'candidate cause'],
  }),
  createTechniquePrimitive({
    id: 'tp_min_repro',
    name: 'Minimize reproduction',
    intent: 'Reduce a failure to the smallest reproducible case.',
    triggers: ['flaky behavior', 'slow debugging', 'complex environment'],
    inputsRequired: ['observed failure', 'execution steps'],
    actions: ['Remove unrelated steps', 'Isolate inputs', 'Confirm minimal case'],
    failureModes: ['Removes causal factor', 'Leaves hidden dependency'],
    outputs: ['minimal reproduction', 'repro steps'],
  }),
  createTechniquePrimitive({
    id: 'tp_instrument',
    name: 'Instrument and observe',
    intent: 'Add observability to validate assumptions.',
    triggers: ['missing telemetry', 'unknown state transitions'],
    inputsRequired: ['suspected locations', 'signals needed'],
    actions: ['Add logs/metrics', 'Capture before/after state', 'Inspect traces'],
    failureModes: ['Adds noise', 'Misses critical signal'],
    outputs: ['observed signals', 'trace logs'],
  }),
  createTechniquePrimitive({
    id: 'tp_experiment',
    name: 'Run controlled experiment',
    intent: 'Test hypotheses with minimal risk.',
    triggers: ['risky change', 'uncertain impact'],
    inputsRequired: ['hypothesis', 'safe environment'],
    actions: ['Define experiment', 'Run with guardrails', 'Compare outcomes'],
    failureModes: ['No control group', 'Confounded results'],
    outputs: ['experiment result', 'confidence update'],
  }),
  createTechniquePrimitive({
    id: 'tp_review_tests',
    name: 'Review tests and coverage',
    intent: 'Use tests to bound behavior and detect gaps.',
    triggers: ['changing behavior', 'suspected regression'],
    inputsRequired: ['test list', 'coverage map'],
    actions: ['Inspect existing tests', 'Run targeted suites', 'Identify gaps'],
    failureModes: ['Over-trusts outdated tests', 'Misses integration gaps'],
    outputs: ['coverage assessment', 'test gap list'],
  }),
  createTechniquePrimitive({
    id: 'tp_risk_scan',
    name: 'Pre-mortem risk scan',
    intent: 'Identify likely failure modes before implementation.',
    triggers: ['high-risk change', 'unknown dependencies'],
    inputsRequired: ['plan', 'system context'],
    actions: ['List failure modes', 'Estimate likelihood', 'Add mitigations'],
    failureModes: ['Underestimates rare failures', 'No mitigation follow-through'],
    outputs: ['risk register', 'mitigation list'],
  }),
  createTechniquePrimitive({
    id: 'tp_verify_plan',
    name: 'Create verification plan',
    intent: 'Define how to verify key claims and outcomes.',
    triggers: ['semantic claims', 'uncertain evidence'],
    inputsRequired: ['claims', 'required evidence'],
    actions: ['Specify verification methods', 'Define expected observations', 'Assign owners'],
    failureModes: ['No executable checks', 'Missing critical evidence'],
    outputs: ['verification plan', 'proof obligations'],
  }),
  createTechniquePrimitive({
    id: 'tp_root_cause',
    name: 'Root cause analysis',
    intent: 'Identify the underlying cause rather than surface symptoms.',
    triggers: ['recurring bug', 'unexpected regression', 'unclear failure'],
    inputsRequired: ['observed failure', 'timeline', 'context'],
    actions: ['Trace causal chain', 'Validate each link', 'Confirm root cause with evidence'],
    failureModes: ['Stops at proximal cause', 'Assumes without evidence'],
    outputs: ['root cause statement', 'supporting evidence'],
  }),
  createTechniquePrimitive({
    id: 'tp_arch_mapping',
    name: 'Map architecture',
    intent: 'Create a structural map of components and dependencies.',
    triggers: ['unknown codebase', 'large refactor', 'integration work'],
    inputsRequired: ['module list', 'dependency graph'],
    actions: ['Identify modules', 'Map dependencies', 'Summarize responsibilities'],
    failureModes: ['Misses hidden dependencies', 'Over-simplifies boundaries'],
    outputs: ['architecture map', 'dependency overview'],
  }),
  createTechniquePrimitive({
    id: 'tp_interface_contract',
    name: 'Define interface contract',
    intent: 'Clarify interfaces, invariants, and responsibilities.',
    triggers: ['API changes', 'cross-team integration', 'ambiguity'],
    inputsRequired: ['current API', 'consumer expectations'],
    actions: ['List inputs/outputs', 'Define invariants', 'Document error cases'],
    failureModes: ['Unstated invariants', 'Missing error handling'],
    outputs: ['interface contract', 'invariant list'],
  }),
  createTechniquePrimitive({
    id: 'tp_threat_model',
    name: 'Threat modeling',
    intent: 'Identify security threats and mitigations.',
    triggers: ['auth changes', 'new surfaces', 'sensitive data'],
    inputsRequired: ['data flow', 'actors', 'assets'],
    actions: ['Enumerate threats', 'Assess impact', 'Define mitigations'],
    failureModes: ['Ignores abuse cases', 'Misses privilege escalation'],
    outputs: ['threat list', 'mitigation plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_performance_profile',
    name: 'Performance profiling',
    intent: 'Locate and quantify performance bottlenecks.',
    triggers: ['latency spike', 'scaling limit', 'resource exhaustion'],
    inputsRequired: ['profiling tools', 'workload'],
    actions: ['Profile hot paths', 'Measure baseline', 'Identify top contributors'],
    failureModes: ['Optimizes cold path', 'Misreads metrics'],
    outputs: ['profile report', 'bottleneck list'],
  }),
  createTechniquePrimitive({
    id: 'tp_refactor_safe',
    name: 'Safe refactor',
    intent: 'Change structure without altering behavior.',
    triggers: ['technical debt', 'maintenance pain', 'complexity'],
    inputsRequired: ['existing behavior', 'tests'],
    actions: ['Add safety tests', 'Refactor incrementally', 'Validate behavior'],
    failureModes: ['Behavior drift', 'Insufficient test coverage'],
    outputs: ['refactor plan', 'behavior invariants'],
  }),
  createTechniquePrimitive({
    id: 'tp_ux_journey',
    name: 'User journey mapping',
    intent: 'Model the user journey to reveal friction points.',
    triggers: ['UX issues', 'feature redesign', 'conversion drop'],
    inputsRequired: ['user goals', 'current flows'],
    actions: ['Map steps', 'Identify pain points', 'Propose improvements'],
    failureModes: ['Ignores edge cases', 'Assumes ideal user'],
    outputs: ['journey map', 'friction list'],
  }),
  createTechniquePrimitive({
    id: 'tp_research_synthesis',
    name: 'Research synthesis',
    intent: 'Combine sources into a coherent, evidence-based summary.',
    triggers: ['multiple sources', 'conflicting evidence', 'design decisions'],
    inputsRequired: ['source list', 'evaluation criteria'],
    actions: ['Assess sources', 'Extract key points', 'Resolve conflicts'],
    failureModes: ['Cherry-picks evidence', 'Ignores uncertainty'],
    outputs: ['synthesis summary', 'evidence table'],
  }),
  createTechniquePrimitive({
    id: 'tp_data_invariants',
    name: 'Identify data invariants',
    intent: 'Capture invariant properties that must always hold.',
    triggers: ['data corruption', 'schema changes', 'logic complexity'],
    inputsRequired: ['data model', 'business rules'],
    actions: ['List invariants', 'Map to code', 'Define checks'],
    failureModes: ['Misses implicit invariants', 'Assumes without validation'],
    outputs: ['invariant list', 'validation checks'],
  }),
  createTechniquePrimitive({
    id: 'tp_failure_mode_analysis',
    name: 'Failure mode analysis',
    intent: 'Enumerate how the system can fail and how to detect it.',
    triggers: ['high reliability requirements', 'critical path changes'],
    inputsRequired: ['system overview', 'dependencies'],
    actions: ['List failure modes', 'Define detection signals', 'Plan mitigations'],
    failureModes: ['Ignores upstream dependencies', 'No detection strategy'],
    outputs: ['failure mode list', 'mitigation plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_api_surface_audit',
    name: 'API surface audit',
    intent: 'Inventory and assess public APIs and their consumers.',
    triggers: ['breaking changes', 'public interface uncertainty'],
    inputsRequired: ['API list', 'consumer map'],
    actions: ['Enumerate endpoints', 'Identify consumers', 'Assess compatibility risk'],
    failureModes: ['Misses indirect consumers', 'Underestimates compatibility'],
    outputs: ['API inventory', 'compatibility risks'],
  }),
  createTechniquePrimitive({
    id: 'tp_dependency_map',
    name: 'Dependency mapping',
    intent: 'Map critical dependencies and their health.',
    triggers: ['integration issues', 'runtime failures', 'build instability'],
    inputsRequired: ['dependency list', 'health signals'],
    actions: ['Map dependencies', 'Assess criticality', 'Identify weak links'],
    failureModes: ['Outdated dependency map', 'Ignores transitive deps'],
    outputs: ['dependency map', 'risk hotspots'],
  }),
  createTechniquePrimitive({
    id: 'tp_incident_timeline',
    name: 'Incident timeline reconstruction',
    intent: 'Reconstruct events leading to a failure.',
    triggers: ['production incident', 'multi-step failure'],
    inputsRequired: ['logs', 'alerts', 'deployment history'],
    actions: ['Order events', 'Identify triggers', 'Document key changes'],
    failureModes: ['Missing timestamps', 'Assumes causal order'],
    outputs: ['incident timeline', 'trigger candidates'],
  }),
  createTechniquePrimitive({
    id: 'tp_math_proof',
    name: 'Formal proof sketch',
    intent: 'Construct a proof sketch for a claim or algorithm.',
    triggers: ['novel algorithm', 'correctness claim'],
    inputsRequired: ['claim', 'definitions'],
    actions: ['State assumptions', 'Define invariants', 'Outline proof steps'],
    failureModes: ['Unstated assumptions', 'Gaps in logic'],
    outputs: ['proof sketch', 'assumption list'],
  }),
  createTechniquePrimitive({
    id: 'tp_creative_variation',
    name: 'Creative variation',
    intent: 'Generate diverse alternatives to avoid local optima.',
    triggers: ['stuck on solution', 'need novel approach'],
    inputsRequired: ['current approach', 'constraints'],
    actions: ['Generate alternatives', 'Vary constraints', 'Select promising options'],
    failureModes: ['Too similar alternatives', 'Ignores constraints'],
    outputs: ['alternative list', 'selected candidate'],
  }),
  createTechniquePrimitive({
    id: 'tp_experiment_design',
    name: 'Experiment design',
    intent: 'Design experiments that isolate variables and measure impact.',
    triggers: ['uncertain impact', 'need evidence'],
    inputsRequired: ['hypothesis', 'metrics', 'constraints'],
    actions: ['Define variables', 'Set success metrics', 'Plan rollback'],
    failureModes: ['Confounded variables', 'No rollback'],
    outputs: ['experiment plan', 'success metrics'],
  }),
  createTechniquePrimitive({
    id: 'tp_assumption_audit',
    name: 'Assumption audit',
    intent: 'Expose hidden assumptions and verify them.',
    triggers: ['uncertain plan', 'surprise failures', 'ambiguous requirements'],
    inputsRequired: ['plan', 'constraints', 'observations'],
    actions: ['List assumptions', 'Tag critical ones', 'Define validation checks'],
    failureModes: ['Assumes without evidence', 'Misses domain constraints'],
    outputs: ['assumption list', 'validation plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_first_principles',
    name: 'First principles reasoning',
    intent: 'Derive solutions from fundamental constraints.',
    triggers: ['conventional approach fails', 'novel domain'],
    inputsRequired: ['goal', 'constraints', 'resources'],
    actions: ['Break down to fundamentals', 'Rebuild solution', 'Cross-check with constraints'],
    failureModes: ['Ignores practical constraints', 'Over-simplifies'],
    outputs: ['first-principles model', 'derived options'],
  }),
  createTechniquePrimitive({
    id: 'tp_backcasting',
    name: 'Backcasting plan',
    intent: 'Plan backward from a target outcome to present steps.',
    triggers: ['long-term roadmap', 'ambitious deadline'],
    inputsRequired: ['target outcome', 'deadline', 'constraints'],
    actions: ['Define end state', 'Work backward milestones', 'Validate feasibility'],
    failureModes: ['Unrealistic milestones', 'No slack for risk'],
    outputs: ['backcast milestones', 'critical path'],
  }),
  createTechniquePrimitive({
    id: 'tp_decision_matrix',
    name: 'Decision matrix',
    intent: 'Compare options against weighted criteria.',
    triggers: ['multiple viable options', 'tradeoff dispute'],
    inputsRequired: ['option list', 'criteria', 'weights'],
    actions: ['Score options', 'Review sensitivity', 'Document tradeoffs'],
    failureModes: ['Biased scoring', 'Invalid weights'],
    outputs: ['decision matrix', 'recommended option'],
  }),
  createTechniquePrimitive({
    id: 'tp_scenario_planning',
    name: 'Scenario planning',
    intent: 'Explore multiple futures to stress-test plans.',
    triggers: ['uncertain roadmap', 'volatile environment'],
    inputsRequired: ['baseline plan', 'key uncertainties'],
    actions: ['Define scenarios', 'Evaluate plan under each', 'Identify robust moves'],
    failureModes: ['Too few scenarios', 'Ignores tail risks'],
    outputs: ['scenario set', 'robust strategy list'],
  }),
  createTechniquePrimitive({
    id: 'tp_security_abuse_cases',
    name: 'Abuse case analysis',
    intent: 'Identify attacker misuse paths and mitigations.',
    triggers: ['new surface', 'security review', 'sensitive data'],
    inputsRequired: ['user flows', 'assets', 'threat actors'],
    actions: ['Enumerate abuse cases', 'Prioritize by impact', 'Define mitigations'],
    failureModes: ['Assumes benign use', 'Misses privilege escalation'],
    outputs: ['abuse case list', 'mitigation backlog'],
  }),
  createTechniquePrimitive({
    id: 'tp_user_feedback_loop',
    name: 'User feedback loop',
    intent: 'Set up feedback channels and iteration cadence.',
    triggers: ['new feature launch', 'UX uncertainty'],
    inputsRequired: ['user segments', 'feedback channels'],
    actions: ['Define capture methods', 'Set review cadence', 'Feed insights into roadmap'],
    failureModes: ['No follow-through', 'Biased sample'],
    outputs: ['feedback plan', 'iteration cadence'],
  }),
  createTechniquePrimitive({
    id: 'tp_release_plan',
    name: 'Release planning',
    intent: 'Plan rollout, risk control, and stakeholder communication.',
    triggers: ['major release', 'migration', 'high-risk change'],
    inputsRequired: ['change list', 'risk assessment', 'stakeholders'],
    actions: ['Define rollout phases', 'Set rollback criteria', 'Prepare comms'],
    failureModes: ['No rollback path', 'Insufficient comms'],
    outputs: ['release plan', 'rollback checklist'],
  }),
  createTechniquePrimitive({
    id: 'tp_assurance_case',
    name: 'Assurance case',
    intent: 'Build a structured argument that claims are satisfied.',
    triggers: ['safety-critical change', 'compliance review', 'high-stakes release'],
    inputsRequired: ['claims', 'evidence', 'assumptions'],
    actions: ['Define claims', 'Collect evidence', 'Map evidence to claims'],
    failureModes: ['Missing evidence', 'Circular argument'],
    outputs: ['assurance case', 'evidence gaps'],
  }),
  createTechniquePrimitive({
    id: 'tp_requirement_traceability',
    name: 'Requirement traceability',
    intent: 'Ensure requirements map to design, code, and tests.',
    triggers: ['regulatory requirements', 'large scope', 'audit request'],
    inputsRequired: ['requirements', 'design artifacts', 'tests'],
    actions: ['Map requirements to design', 'Map to tests', 'Identify gaps'],
    failureModes: ['Outdated requirements', 'Missing coverage'],
    outputs: ['traceability matrix', 'coverage gaps'],
  }),
  createTechniquePrimitive({
    id: 'tp_change_impact',
    name: 'Change impact analysis',
    intent: 'Assess downstream impact before making a change.',
    triggers: ['breaking change', 'dependency upgrade', 'risky refactor'],
    inputsRequired: ['change description', 'dependency map'],
    actions: ['Identify impacted components', 'Estimate risk', 'Plan mitigations'],
    failureModes: ['Misses indirect impacts', 'Underestimates risk'],
    outputs: ['impact assessment', 'mitigation plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_edge_case_catalog',
    name: 'Edge case catalog',
    intent: 'Enumerate edge cases and ensure coverage.',
    triggers: ['complex logic', 'input variability', 'bug cluster'],
    inputsRequired: ['spec', 'data ranges', 'failure history'],
    actions: ['List edge cases', 'Prioritize by risk', 'Add targeted tests'],
    failureModes: ['Assumes typical usage', 'Ignores boundary conditions'],
    outputs: ['edge case list', 'test targets'],
  }),
  createTechniquePrimitive({
    id: 'tp_test_gap_analysis',
    name: 'Test gap analysis',
    intent: 'Identify coverage gaps against risk areas.',
    triggers: ['uncertain coverage', 'high-risk changes'],
    inputsRequired: ['test suite', 'risk areas', 'requirements'],
    actions: ['Map tests to risks', 'Identify gaps', 'Propose new tests'],
    failureModes: ['Focuses on coverage alone', 'Misses integration gaps'],
    outputs: ['test gap report', 'test backlog'],
  }),
  createTechniquePrimitive({
    id: 'tp_scaling_bottleneck',
    name: 'Scaling bottleneck analysis',
    intent: 'Predict bottlenecks as load grows.',
    triggers: ['traffic growth', 'capacity planning', 'performance regressions'],
    inputsRequired: ['traffic model', 'current metrics', 'architecture map'],
    actions: ['Model growth', 'Identify bottlenecks', 'Plan scaling strategies'],
    failureModes: ['Assumes linear scaling', 'Ignores tail latency'],
    outputs: ['scaling limits', 'optimization plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_data_quality_audit',
    name: 'Data quality audit',
    intent: 'Assess data completeness, consistency, and accuracy.',
    triggers: ['data anomalies', 'new data pipeline', 'model training'],
    inputsRequired: ['data sources', 'quality metrics', 'lineage info'],
    actions: ['Assess completeness', 'Check consistency', 'Flag anomalies'],
    failureModes: ['No baseline', 'Ignores data lineage'],
    outputs: ['quality report', 'remediation plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_accessibility_review',
    name: 'Accessibility review',
    intent: 'Audit UI for accessibility and inclusive design.',
    triggers: ['UI changes', 'public release', 'compliance requirement'],
    inputsRequired: ['UI components', 'accessibility guidelines'],
    actions: ['Audit contrast and semantics', 'Test with assistive tech', 'Record issues'],
    failureModes: ['Relies only on automated checks', 'Misses keyboard flows'],
    outputs: ['accessibility report', 'fix list'],
  }),
  createTechniquePrimitive({
    id: 'tp_calibration_check',
    name: 'Calibration check',
    intent: 'Compare confidence to outcomes to improve judgment.',
    triggers: ['high uncertainty', 'post-decision review'],
    inputsRequired: ['prior estimates', 'actual outcomes'],
    actions: ['Record confidence', 'Compare to outcomes', 'Adjust calibration guidance'],
    failureModes: ['No outcome tracking', 'Overconfidence persists'],
    outputs: ['calibration notes', 'updated confidence guidance'],
  }),
  createTechniquePrimitive({
    id: 'tp_bias_check',
    name: 'Bias check',
    intent: 'Surface cognitive biases that distort decisions.',
    triggers: ['strong prior', 'controversial tradeoff'],
    inputsRequired: ['decision context', 'evidence set'],
    actions: ['Identify biases', 'Seek disconfirming evidence', 'Document adjustments'],
    failureModes: ['Token check', 'Ignores dissent'],
    outputs: ['bias checklist', 'mitigation notes'],
  }),
  createTechniquePrimitive({
    id: 'tp_red_team_prompt',
    name: 'Red-team challenge',
    intent: 'Adversarially stress-test a plan or assumption.',
    triggers: ['high-stakes decision', 'security risk'],
    inputsRequired: ['current plan', 'assumptions'],
    actions: ['Generate adversarial questions', 'Test failure scenarios', 'Record vulnerabilities'],
    failureModes: ['Superficial challenge', 'No follow-up'],
    outputs: ['red-team findings', 'risk updates'],
  }),
  createTechniquePrimitive({
    id: 'tp_decision_review',
    name: 'Decision review',
    intent: 'Revisit decisions with evidence and outcomes.',
    triggers: ['post-incident', 'after milestone', 'unexpected outcome'],
    inputsRequired: ['decision record', 'outcomes'],
    actions: ['Review rationale', 'Compare to outcomes', 'Update guidelines'],
    failureModes: ['No documentation', 'Defensive review'],
    outputs: ['decision review', 'updated guidance'],
  }),
  createTechniquePrimitive({
    id: 'tp_stop_escalate',
    name: 'Stop and escalate',
    intent: 'Define stop conditions and escalation paths.',
    triggers: ['blocked work', 'uncertain evidence', 'high risk'],
    inputsRequired: ['current blockers', 'risk assessment'],
    actions: ['Define stop triggers', 'Escalate with evidence', 'Record decision'],
    failureModes: ['Keeps going without evidence', 'No escalation owner'],
    outputs: ['stop criteria', 'escalation record'],
  }),
  createTechniquePrimitive({
    id: 'tp_ownership_matrix',
    name: 'Ownership matrix',
    intent: 'Clarify ownership and responsibilities.',
    triggers: ['cross-team work', 'multi-owner code'],
    inputsRequired: ['stakeholders', 'components'],
    actions: ['Map owners', 'Define responsibilities', 'Confirm handoffs'],
    failureModes: ['Ambiguous ownership', 'Stale owner map'],
    outputs: ['ownership matrix', 'handoff list'],
  }),
  createTechniquePrimitive({
    id: 'tp_communication_cadence',
    name: 'Communication cadence',
    intent: 'Establish update rhythm and channels.',
    triggers: ['multi-team project', 'long-running work'],
    inputsRequired: ['stakeholders', 'timeline'],
    actions: ['Define cadence', 'Choose channels', 'Assign update owner'],
    failureModes: ['No follow-through', 'Over-communication'],
    outputs: ['communication plan', 'update schedule'],
  }),
  createTechniquePrimitive({
    id: 'tp_integration_checkpoint',
    name: 'Integration checkpoint',
    intent: 'Plan integration points with verification.',
    triggers: ['multi-component change', 'partner dependency'],
    inputsRequired: ['integration points', 'tests'],
    actions: ['Define checkpoints', 'Set verification steps', 'Schedule merges'],
    failureModes: ['Late integration', 'Missing verification'],
    outputs: ['integration plan', 'checkpoint list'],
  }),
  createTechniquePrimitive({
    id: 'tp_evidence_pack',
    name: 'Evidence pack assembly',
    intent: 'Collect durable, machine-verifiable evidence artifacts for claims.',
    triggers: ['claim completion', 'release readiness', 'quality audit'],
    inputsRequired: ['commands executed', 'stdout/stderr digests', 'artifact paths'],
    actions: ['Record evidence metadata', 'Store artifact digests', 'Emit evidence pack'],
    failureModes: ['Missing artifacts', 'Unverifiable claims'],
    outputs: ['evidence pack', 'artifact digest list'],
  }),
  createTechniquePrimitive({
    id: 'tp_artifact_envelope',
    name: 'Artifact envelope validation',
    intent: 'Wrap artifacts with provenance, budgets, and outcome metadata.',
    triggers: ['artifact creation', 'audit trail requirement'],
    inputsRequired: ['artifact payload', 'environment ref', 'canon ref'],
    actions: ['Attach envelope', 'Record budgets', 'Validate schema'],
    failureModes: ['Missing provenance', 'Invalid schema version'],
    outputs: ['enveloped artifact', 'validation report'],
  }),
  createTechniquePrimitive({
    id: 'tp_artifact_versioning',
    name: 'Artifact versioning',
    intent: 'Track artifact schema versions and migrations deterministically.',
    triggers: ['schema change', 'artifact upgrade'],
    inputsRequired: ['artifact schema', 'version map'],
    actions: ['Detect version drift', 'Apply migration', 'Emit upgrade report'],
    failureModes: ['Silent downgrades', 'Untracked schema changes'],
    outputs: ['versioned artifact', 'upgrade report'],
  }),
  createTechniquePrimitive({
    id: 'tp_research_evidence_pack',
    name: 'Research evidence pack',
    intent: 'Capture research queries and sources with provenance and digests.',
    triggers: ['web research', 'external dependency review'],
    inputsRequired: ['queries', 'source URLs', 'extractor output'],
    actions: ['Fetch sources', 'Record digests', 'Store provenance'],
    failureModes: ['Missing source digest', 'Unverifiable citations'],
    outputs: ['research pack', 'source provenance list'],
  }),
  createTechniquePrimitive({
    id: 'tp_source_extraction',
    name: 'Source extraction',
    intent: 'Extract and normalize external source content safely.',
    triggers: ['web research', 'external docs ingestion'],
    inputsRequired: ['URL list', 'extractor choice'],
    actions: ['Fetch content', 'Record preview', 'Classify format'],
    failureModes: ['Auth blocked', 'Rate limited'],
    outputs: ['source extraction report', 'content digest'],
  }),
  createTechniquePrimitive({
    id: 'tp_provider_probe',
    name: 'Provider probe',
    intent: 'Verify CLI providers are available and authenticated.',
    triggers: ['tier-2 run', 'provider-dependent tasks'],
    inputsRequired: ['provider list', 'workspace root'],
    actions: ['Probe CLI availability', 'Record auth status', 'Emit report'],
    failureModes: ['Unauthenticated provider', 'Sandbox failure'],
    outputs: ['provider probe report', 'availability summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_stage_compliance',
    name: 'Stage compliance check',
    intent: 'Verify stage artifacts and gating rules for Wave0 programs.',
    triggers: ['promotion pipeline', 'compliance audit'],
    inputsRequired: ['stage definitions', 'artifact inventory'],
    actions: ['Check artifacts', 'Evaluate gating rules', 'Record findings'],
    failureModes: ['Missing artifacts', 'Unchecked gates'],
    outputs: ['stage compliance report', 'missing artifact list'],
  }),
  createTechniquePrimitive({
    id: 'tp_gating_rules',
    name: 'Gating rule evaluation',
    intent: 'Evaluate deterministic gates with stable reason codes.',
    triggers: ['quality gate', 'promotion decision'],
    inputsRequired: ['gate definition', 'evidence references'],
    actions: ['Validate evidence', 'Apply gate rules', 'Emit reason codes'],
    failureModes: ['Gate bypass', 'No reason codes'],
    outputs: ['gate evaluation', 'reason code list'],
  }),
  createTechniquePrimitive({
    id: 'tp_prompt_injection_scan',
    name: 'Prompt injection scan',
    intent: 'Detect prompt injection attempts in inputs and payloads.',
    triggers: ['user input', 'external content ingestion'],
    inputsRequired: ['raw inputs', 'encoded payloads'],
    actions: ['Scan patterns', 'Decode base64 candidates', 'Flag blocks'],
    failureModes: ['Missed injection', 'False positives without review'],
    outputs: ['injection findings', 'blocked status'],
  }),
  createTechniquePrimitive({
    id: 'tp_secret_scan',
    name: 'Secret scan and redaction',
    intent: 'Detect and redact secrets from outputs and artifacts.',
    triggers: ['log emission', 'artifact storage'],
    inputsRequired: ['text payload', 'secret patterns'],
    actions: ['Scan for secrets', 'Redact matches', 'Record leak report'],
    failureModes: ['Secrets leaked', 'Unlogged redaction'],
    outputs: ['redacted output', 'secret scan report'],
  }),
  createTechniquePrimitive({
    id: 'tp_path_containment',
    name: 'Path containment check',
    intent: 'Ensure file operations stay within approved workspace roots.',
    triggers: ['file write', 'path resolution'],
    inputsRequired: ['root path', 'candidate path'],
    actions: ['Resolve real paths', 'Verify containment', 'Block escapes'],
    failureModes: ['Path traversal', 'Symlink escape'],
    outputs: ['containment verdict', 'blocked paths list'],
  }),
  createTechniquePrimitive({
    id: 'tp_git_sanitization',
    name: 'Git URL sanitization',
    intent: 'Validate git URLs and block unsafe protocols.',
    triggers: ['git fetch', 'external repo access'],
    inputsRequired: ['git URL', 'allowed protocols'],
    actions: ['Parse URL', 'Validate protocol', 'Reject unsafe formats'],
    failureModes: ['Unsafe protocol allowed', 'Invalid URLs accepted'],
    outputs: ['sanitized URL', 'rejection reason'],
  }),
  createTechniquePrimitive({
    id: 'tp_repo_map',
    name: 'Repository map',
    intent: 'Generate a module map and dependency inventory.',
    triggers: ['large codebase', 'architecture audit'],
    inputsRequired: ['repo root', 'include/exclude patterns'],
    actions: ['Scan modules', 'Extract imports', 'Emit repo map'],
    failureModes: ['Incomplete map', 'Missing hotspots'],
    outputs: ['repo map', 'module inventory'],
  }),
  createTechniquePrimitive({
    id: 'tp_arch_invariant_scan',
    name: 'Architecture invariant scan',
    intent: 'Detect architectural boundary violations and invariants.',
    triggers: ['architecture audit', 'module boundary changes'],
    inputsRequired: ['repo map', 'invariant rules'],
    actions: ['Evaluate dependencies', 'Flag violations', 'Emit report'],
    failureModes: ['Unchecked violations', 'Missing boundary rules'],
    outputs: ['invariant report', 'violation list'],
  }),
  createTechniquePrimitive({
    id: 'tp_ownership_hints',
    name: 'Ownership hints',
    intent: 'Provide ownership and responsibility hints for modules.',
    triggers: ['handoff', 'review routing'],
    inputsRequired: ['repo map', 'ownership rules'],
    actions: ['Classify ownership', 'Emit hints', 'Record coverage gaps'],
    failureModes: ['Stale ownership data', 'Missing owners'],
    outputs: ['ownership hints', 'coverage gaps'],
  }),
  createTechniquePrimitive({
    id: 'tp_via_negativa',
    name: 'Via negativa reduction',
    intent: 'Identify and remove unnecessary code or complexity.',
    triggers: ['complexity spike', 'refactor need'],
    inputsRequired: ['codebase metrics', 'thresholds'],
    actions: ['Detect bloat', 'Identify removals', 'Score simplifications'],
    failureModes: ['Deletes critical code', 'No verification of removals'],
    outputs: ['removal candidates', 'simplification plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_slop_prevention',
    name: 'Slop prevention',
    intent: 'Detect and block low-quality or hallucinated changes.',
    triggers: ['AI-generated changes', 'suspicious diffs'],
    inputsRequired: ['diffs', 'slop patterns'],
    actions: ['Scan patterns', 'Score slop risk', 'Emit recommendations'],
    failureModes: ['False negatives', 'No remediation guidance'],
    outputs: ['slop report', 'blocking findings'],
  }),
  createTechniquePrimitive({
    id: 'tp_byzantine_consensus',
    name: 'Byzantine consensus verification',
    intent: 'Require multi-verifier consensus for high-risk claims.',
    triggers: ['high-risk change', 'safety critical decision'],
    inputsRequired: ['verifier roster', 'evidence pack'],
    actions: ['Collect votes', 'Compute consensus', 'Record outliers'],
    failureModes: ['Insufficient verifiers', 'No dissent captured'],
    outputs: ['consensus report', 'verifier outliers'],
  }),
  createTechniquePrimitive({
    id: 'tp_temporal_feedback',
    name: 'Temporal feedback verification',
    intent: 'Re-evaluate claims with long-term evidence and decay.',
    triggers: ['post-release review', 'stability monitoring'],
    inputsRequired: ['verification history', 'production evidence'],
    actions: ['Gather long-term evidence', 'Adjust confidence', 'Emit delta'],
    failureModes: ['No decay applied', 'Ignored regressions'],
    outputs: ['temporal verification report', 'confidence deltas'],
  }),
  createTechniquePrimitive({
    id: 'tp_blackboard_coordination',
    name: 'Blackboard coordination',
    intent: 'Coordinate agents via shared artifact board.',
    triggers: ['multi-agent task', 'parallel exploration'],
    inputsRequired: ['artifact bus', 'role roster'],
    actions: ['Publish artifacts', 'Subscribe to updates', 'Resolve conflicts'],
    failureModes: ['No shared state', 'Conflicting artifacts unresolved'],
    outputs: ['artifact ledger', 'conflict resolution log'],
  }),
  createTechniquePrimitive({
    id: 'tp_contract_net_leasing',
    name: 'Contract-net leasing',
    intent: 'Allocate tasks with explicit leases to prevent collisions.',
    triggers: ['parallel agents', 'shared workspace'],
    inputsRequired: ['task list', 'lease policy'],
    actions: ['Issue leases', 'Track ownership', 'Reclaim expired leases'],
    failureModes: ['Lease conflicts', 'Unclaimed tasks'],
    outputs: ['lease registry', 'assignment log'],
  }),
  createTechniquePrimitive({
    id: 'tp_arbitration',
    name: 'Arbitration and selection',
    intent: 'Select among competing proposals with evidence-based scoring.',
    triggers: ['multiple proposals', 'multi-agent review'],
    inputsRequired: ['proposal set', 'verdict evidence'],
    actions: ['Score proposals', 'Apply veto rules', 'Select winner'],
    failureModes: ['No evidence in selection', 'Unrecorded vetoes'],
    outputs: ['selection decision', 'scoring summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_worktree_isolation',
    name: 'Worktree isolation',
    intent: 'Isolate concurrent work in separate worktrees or sandboxes.',
    triggers: ['parallel agents', 'conflicting changes'],
    inputsRequired: ['workspace root', 'branch plan'],
    actions: ['Create worktrees', 'Assign tasks', 'Merge via arbitration'],
    failureModes: ['Shared state contamination', 'Merge conflicts unreviewed'],
    outputs: ['worktree plan', 'merge decision'],
  }),
  createTechniquePrimitive({
    id: 'tp_ote_rubric_planning',
    name: 'OTE rubric planning',
    intent: 'Generate objective task rubrics for high-variance work.',
    triggers: ['design tasks', 'subjective goals'],
    inputsRequired: ['intent', 'domain tags'],
    actions: ['Draft rubrics', 'Confirm priorities', 'Record rationale'],
    failureModes: ['No rubrics', 'Unclear success criteria'],
    outputs: ['rubric set', 'rationale notes'],
  }),
  createTechniquePrimitive({
    id: 'tp_playwright_verification',
    name: 'Playwright verification',
    intent: 'Verify UI flows or web extraction with Playwright evidence.',
    triggers: ['UI changes', 'browser extraction'],
    inputsRequired: ['scenario', 'browser availability'],
    actions: ['Run Playwright probe', 'Capture outputs', 'Store evidence'],
    failureModes: ['Browser unavailable', 'No trace artifacts'],
    outputs: ['playwright report', 'trace evidence'],
  }),
  createTechniquePrimitive({
    id: 'tp_web_research_evidence',
    name: 'Web research evidence',
    intent: 'Collect web research outputs with provenance and digests.',
    triggers: ['external dependency', 'market research'],
    inputsRequired: ['queries', 'URLs'],
    actions: ['Search sources', 'Extract content', 'Record digests'],
    failureModes: ['Missing provenance', 'Unverified sources'],
    outputs: ['research evidence', 'source list'],
  }),
  createTechniquePrimitive({
    id: 'tp_capability_probe',
    name: 'Capability probe',
    intent: 'Probe tool and provider capabilities before execution.',
    triggers: ['tier-2 run', 'new environment'],
    inputsRequired: ['capability list', 'probe budget'],
    actions: ['Run probes', 'Record results', 'Emit capability report'],
    failureModes: ['Missing probe coverage', 'Silent failures'],
    outputs: ['capability report', 'probe failures'],
  }),
  createTechniquePrimitive({
    id: 'tp_execution_budgeting',
    name: 'Execution budgeting',
    intent: 'Allocate and enforce resource budgets for execution loops.',
    triggers: ['long-running tasks', 'cost-sensitive runs'],
    inputsRequired: ['budget constraints', 'task estimate'],
    actions: ['Set budget caps', 'Monitor usage', 'Escalate on overrun'],
    failureModes: ['Unbounded runs', 'Budget overruns unreported'],
    outputs: ['budget plan', 'budget usage report'],
  }),
  createTechniquePrimitive({
    id: 'tp_evolvable_artifacts',
    name: 'Evolvable artifact resolution',
    intent: 'Resolve evolvable artifacts with policy, rubric, and prompt pack pointers.',
    triggers: ['policy update', 'rubric update', 'prompt pack update'],
    inputsRequired: ['pointer files', 'artifact digests', 'policy schema'],
    actions: ['Resolve pointers', 'Validate schema', 'Record resolved refs'],
    failureModes: ['Stale pointers', 'Invalid schema'],
    outputs: ['resolved artifact refs', 'validation report'],
  }),
  createTechniquePrimitive({
    id: 'tp_durable_execution',
    name: 'Durable execution',
    intent: 'Persist run manifests, checkpoints, and events for resumable execution.',
    triggers: ['long-running run', 'multi-stage workflow'],
    inputsRequired: ['run manifest', 'checkpoint policy'],
    actions: ['Emit run manifest', 'Write checkpoints', 'Append run events'],
    failureModes: ['Checkpoint corruption', 'Resume drift'],
    outputs: ['run manifest', 'checkpoint chain', 'run event log'],
  }),
  createTechniquePrimitive({
    id: 'tp_run_event_log',
    name: 'Run event logging',
    intent: 'Maintain append-only run event logs for audit and replay.',
    triggers: ['execution start', 'stage transition'],
    inputsRequired: ['run id', 'event schema'],
    actions: ['Append events', 'Seal digests', 'Summarize run'],
    failureModes: ['Missing events', 'Out-of-order events'],
    outputs: ['event log', 'event digest'],
  }),
  createTechniquePrimitive({
    id: 'tp_policy_enforcement',
    name: 'Policy enforcement',
    intent: 'Apply policy rules to commands, files, and network actions.',
    triggers: ['command execution', 'network access', 'file write'],
    inputsRequired: ['policy rules', 'resource identifiers'],
    actions: ['Evaluate policy', 'Record decision', 'Require approval on deny'],
    failureModes: ['Policy bypass', 'Missing reason codes'],
    outputs: ['policy decision', 'approval request'],
  }),
  createTechniquePrimitive({
    id: 'tp_principles_injection',
    name: 'Principles injection',
    intent: 'Inject Wave0 principles and anti-slop rules into worker context.',
    triggers: ['worker startup', 'principles update'],
    inputsRequired: ['principles registry', 'worker context'],
    actions: ['Load registry', 'Compute digest', 'Inject context', 'Propagate updates'],
    failureModes: ['Stale principles', 'Missing enforcement metadata'],
    outputs: ['principles context', 'propagation report'],
  }),
  createTechniquePrimitive({
    id: 'tp_external_project_protocol',
    name: 'External project protocol',
    intent: 'Execute external project snapshot, qualification, and evidence collection.',
    triggers: ['external repo evaluation', 'benchmark intake'],
    inputsRequired: ['project source', 'protocol config'],
    actions: ['Create snapshot', 'Run probes', 'Execute qualification', 'Emit evidence pack'],
    failureModes: ['Snapshot failure', 'Unverified external source'],
    outputs: ['project snapshot', 'protocol report', 'evidence pack'],
  }),
  createTechniquePrimitive({
    id: 'tp_safe_code_search',
    name: 'Safe code search',
    intent: 'Search codebases safely via indexed queries.',
    triggers: ['codebase exploration', 'symbol lookup'],
    inputsRequired: ['query', 'language filters'],
    actions: ['Refresh index', 'Run search', 'Return ranked results'],
    failureModes: ['Stale index', 'Query timeout'],
    outputs: ['search results', 'search metadata'],
  }),
  createTechniquePrimitive({
    id: 'tp_replay_pack',
    name: 'Replay pack assembly',
    intent: 'Summarize run artifacts into replay packs for audit and replay.',
    triggers: ['run completion', 'audit request'],
    inputsRequired: ['artifact list', 'artifact digests'],
    actions: ['Normalize artifacts', 'Compute summary digest', 'Emit replay pack'],
    failureModes: ['Missing artifacts', 'Digest mismatch'],
    outputs: ['replay pack', 'summary digest'],
  }),
  createTechniquePrimitive({
    id: 'tp_self_healing',
    name: 'Self-healing loop',
    intent: 'Detect degradation and apply automated recovery actions.',
    category: 'recovery',
    semanticProfileId: 'recovery',
    domains: ['recovery', 'resilience', 'operations'],
    triggers: ['service instability', 'recurring failure'],
    inputsRequired: ['health signals', 'recovery playbook'],
    actions: ['Detect anomaly', 'Select recovery action', 'Verify stabilization'],
    failureModes: ['False recovery triggers', 'No rollback safety'],
    outputs: ['recovery action log', 'stability report'],
  }),
  createTechniquePrimitive({
    id: 'tp_resilience_engine',
    name: 'Resilience engine',
    intent: 'Continuously stress and harden failure pathways.',
    category: 'recovery',
    semanticProfileId: 'recovery',
    domains: ['resilience', 'operations'],
    triggers: ['resilience audit', 'pre-release hardening'],
    inputsRequired: ['failure scenarios', 'system topology'],
    actions: ['Simulate failures', 'Measure recovery', 'Record mitigations'],
    failureModes: ['Incomplete scenarios', 'Unverified mitigations'],
    outputs: ['resilience report', 'mitigation backlog'],
  }),
  createTechniquePrimitive({
    id: 'tp_graceful_degradation',
    name: 'Graceful degradation',
    intent: 'Define safe fallbacks when capacity or dependencies fail.',
    category: 'operations',
    semanticProfileId: 'operations',
    domains: ['operations', 'resilience'],
    triggers: ['dependency outage', 'capacity pressure'],
    inputsRequired: ['service tiers', 'fallback policies'],
    actions: ['Define fallback behavior', 'Validate impact', 'Document triggers'],
    failureModes: ['Unclear fallback policy', 'Hidden degraded state'],
    outputs: ['fallback plan', 'degradation triggers'],
  }),
  createTechniquePrimitive({
    id: 'tp_slo_definition',
    name: 'SLO definition',
    intent: 'Define service-level objectives with measurable targets.',
    category: 'operations',
    semanticProfileId: 'operations',
    domains: ['operations', 'observability'],
    triggers: ['new service', 'reliability contract'],
    inputsRequired: ['service metrics', 'stakeholder expectations'],
    actions: ['Define SLOs', 'Set error budget', 'Record ownership'],
    failureModes: ['Unmeasurable SLOs', 'No owner assigned'],
    outputs: ['SLO document', 'error budget plan'],
  }),
  createTechniquePrimitive({
    id: 'tp_slo_monitoring',
    name: 'SLO monitoring',
    intent: 'Track SLO compliance and alert on budget burn.',
    category: 'observability',
    semanticProfileId: 'observability',
    domains: ['observability', 'operations', 'reliability'],
    triggers: ['SLO breach', 'budget burn'],
    inputsRequired: ['SLO targets', 'telemetry streams'],
    actions: ['Compute burn rate', 'Trigger alerts', 'Record breach evidence'],
    failureModes: ['Silent breaches', 'Missing telemetry'],
    outputs: ['SLO status report', 'breach alerts'],
  }),
  createTechniquePrimitive({
    id: 'tp_semantic_dedup',
    name: 'Semantic deduplication',
    intent: 'Detect semantically duplicate artifacts or findings.',
    category: 'quality',
    semanticProfileId: 'quality',
    domains: ['quality', 'data'],
    triggers: ['duplicate findings', 'repeated outputs'],
    inputsRequired: ['candidate artifacts', 'embedding index'],
    actions: ['Compute similarity', 'Cluster duplicates', 'Select canonical'],
    failureModes: ['False merges', 'Missed duplicates'],
    outputs: ['dedup report', 'canonical artifact list'],
  }),
  createTechniquePrimitive({
    id: 'tp_self_bootstrap',
    name: 'Self-bootstrap',
    intent: 'Bootstrap Librarian index on its own source code.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'analysis'],
    triggers: ['self audit', 'self improvement cycle', 'new release'],
    inputsRequired: ['allowlisted librarian source root', 'storage system', 'embedding provider'],
    actions: [
      'Validate source root containment',
      'Index source tree into staging',
      'Compute embeddings',
      'Record dependency graph',
      'Summarize coverage',
      'Atomically publish index',
    ],
    failureModes: ['Source path missing', 'Embedding provider unavailable', 'Partial index'],
    outputs: ['bootstrap report', 'entity count', 'relationship count', 'coverage metrics', 'index integrity hash'],
  }),
  createTechniquePrimitive({
    id: 'tp_analyze_architecture',
    name: 'Analyze architecture',
    intent: 'Analyze system architecture for violations and improvement opportunities.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'governance'],
    triggers: ['architecture audit', 'self improvement cycle', 'large refactor'],
    inputsRequired: ['self index', 'architecture checks declarative rules', 'thresholds'],
    actions: ['Validate checks schema', 'Run architecture checks', 'Record violations', 'Summarize hotspots'],
    failureModes: ['Missing index', 'False positives', 'Incomplete checks'],
    outputs: ['architecture violations', 'improvement suggestions', 'architecture summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_hebbian_learning',
    name: 'Hebbian learning update',
    intent: 'Reinforce associations based on co-activation signals.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'learning'],
    triggers: ['repeated co-occurrence', 'feedback loop'],
    inputsRequired: ['signal pairs', 'learning rate'],
    actions: ['Update weights', 'Normalize associations', 'Record deltas'],
    failureModes: ['Runaway reinforcement', 'No normalization'],
    outputs: ['association updates', 'learning audit log'],
  }),
  createTechniquePrimitive({
    id: 'tp_unified_field_signal',
    name: 'Unified field signaling',
    intent: 'Aggregate system signals into unified field metrics.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'observability'],
    triggers: ['system telemetry update', 'audit cycle'],
    inputsRequired: ['metric streams', 'aggregation rules'],
    actions: ['Aggregate signals', 'Normalize scales', 'Record field state'],
    failureModes: ['Signal drift', 'Untracked aggregation'],
    outputs: ['unified field snapshot', 'signal summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_homeostasis_loop',
    name: 'Homeostasis loop',
    intent: 'Stabilize system behavior with corrective feedback loops.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'operations'],
    triggers: ['drift detected', 'instability trend'],
    inputsRequired: ['target ranges', 'feedback signals'],
    actions: ['Measure deviation', 'Apply correction', 'Confirm stability'],
    failureModes: ['Over-correction', 'Unstable feedback'],
    outputs: ['homeostasis report', 'correction log'],
  }),
  createTechniquePrimitive({
    id: 'tp_thermodynamic_pressure',
    name: 'Thermodynamic pressure tracking',
    intent: 'Track entropy pressure to trigger intervention thresholds.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'risk'],
    triggers: ['entropy spike', 'quality regression'],
    inputsRequired: ['entropy metrics', 'threshold policy'],
    actions: ['Compute pressure', 'Compare thresholds', 'Signal interventions'],
    failureModes: ['Threshold drift', 'No escalation'],
    outputs: ['pressure report', 'intervention signals'],
  }),
  createTechniquePrimitive({
    id: 'tp_adaptive_complexity',
    name: 'Adaptive complexity tuning',
    intent: 'Adjust complexity budgets based on system load and risk.',
    category: 'optimization',
    semanticProfileId: 'optimization',
    domains: ['optimization', 'resilience'],
    triggers: ['complexity spike', 'performance degradation'],
    inputsRequired: ['complexity metrics', 'budget policy'],
    actions: ['Assess complexity', 'Tune budgets', 'Record adjustments'],
    failureModes: ['Over-pruning', 'No measurable impact'],
    outputs: ['complexity tuning report', 'budget adjustments'],
  }),
  createTechniquePrimitive({
    id: 'tp_task_economics',
    name: 'Task economics modeling',
    intent: 'Model cost, value, and risk for task selection.',
    category: 'optimization',
    semanticProfileId: 'optimization',
    domains: ['economics', 'optimization'],
    triggers: ['portfolio planning', 'budget constraint'],
    inputsRequired: ['task list', 'cost estimates'],
    actions: ['Estimate cost/value', 'Rank tasks', 'Record tradeoffs'],
    failureModes: ['Mispriced tasks', 'Ignored risk factors'],
    outputs: ['economics model', 'ranked task list'],
  }),
  createTechniquePrimitive({
    id: 'tp_token_ledger',
    name: 'Token ledger tracking',
    intent: 'Track token flows, debits, and credits for agents.',
    category: 'governance',
    semanticProfileId: 'governance',
    domains: ['economics', 'governance'],
    triggers: ['run completion', 'budget settlement'],
    inputsRequired: ['token events', 'account registry'],
    actions: ['Record debits', 'Apply credits', 'Seal ledger'],
    failureModes: ['Unbalanced ledger', 'Missing provenance'],
    outputs: ['token ledger', 'audit receipt'],
  }),
  createTechniquePrimitive({
    id: 'tp_reputation_update',
    name: 'Reputation update',
    intent: 'Update agent reputation signals from outcomes.',
    category: 'governance',
    semanticProfileId: 'governance',
    domains: ['economics', 'governance'],
    triggers: ['verification verdict', 'audit cycle'],
    inputsRequired: ['outcome signals', 'reputation policy'],
    actions: ['Compute score delta', 'Apply bounds', 'Record rationale'],
    failureModes: ['Unbounded penalties', 'No audit trail'],
    outputs: ['reputation update', 'rationale record'],
  }),
  createTechniquePrimitive({
    id: 'tp_cost_estimation',
    name: 'Cost estimation',
    intent: 'Estimate execution cost and resource burn before action.',
    category: 'optimization',
    semanticProfileId: 'optimization',
    domains: ['economics', 'operations'],
    triggers: ['budget planning', 'capacity check'],
    inputsRequired: ['work scope', 'historical costs'],
    actions: ['Estimate cost', 'Quantify uncertainty', 'Record assumptions'],
    failureModes: ['Underestimated costs', 'No uncertainty bounds'],
    outputs: ['cost estimate', 'assumption log'],
  }),
  createTechniquePrimitive({
    id: 'tp_vcg_auction',
    name: 'VCG auction allocation',
    intent: 'Allocate tasks using VCG incentive mechanisms.',
    category: 'coordination',
    semanticProfileId: 'coordination',
    domains: ['economics', 'coordination'],
    triggers: ['multi-agent bidding', 'task allocation'],
    inputsRequired: ['bids', 'allocation policy'],
    actions: ['Compute allocation', 'Calculate payments', 'Record winners'],
    failureModes: ['Invalid bids', 'Unrecorded payouts'],
    outputs: ['allocation result', 'payment ledger'],
  }),
  createTechniquePrimitive({
    id: 'tp_novelty_search',
    name: 'Novelty search',
    intent: 'Explore novel solution spaces for diverse strategies.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'research'],
    triggers: ['stagnant performance', 'exploration need'],
    inputsRequired: ['solution archive', 'novelty metric'],
    actions: ['Score novelty', 'Select candidates', 'Record discoveries'],
    failureModes: ['No diversity metric', 'Untracked discoveries'],
    outputs: ['novelty candidates', 'exploration report'],
  }),
  createTechniquePrimitive({
    id: 'tp_evolution_tournament',
    name: 'Evolution tournament',
    intent: 'Select and evolve candidates through tournament selection.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'optimization'],
    triggers: ['evolution cycle', 'candidate refresh'],
    inputsRequired: ['candidate pool', 'fitness criteria'],
    actions: ['Run tournament', 'Select survivors', 'Record fitness scores'],
    failureModes: ['Fitness bias', 'No diversity enforcement'],
    outputs: ['selected candidates', 'fitness summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_diversity_enforcer',
    name: 'Diversity enforcement',
    intent: 'Preserve diversity across solution candidates.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'optimization'],
    triggers: ['homogeneous candidates', 'selection bias'],
    inputsRequired: ['candidate pool', 'diversity policy'],
    actions: ['Measure diversity', 'Penalize duplicates', 'Record adjustments'],
    failureModes: ['Over-penalization', 'No diversity audit'],
    outputs: ['diversity report', 'adjusted pool'],
  }),
  createTechniquePrimitive({
    id: 'tp_fitness_gap_proposer',
    name: 'Fitness gap proposer',
    intent: 'Identify fitness gaps and propose targeted experiments.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'optimization'],
    triggers: ['fitness plateau', 'gap analysis'],
    inputsRequired: ['fitness history', 'candidate metrics'],
    actions: ['Detect gaps', 'Propose experiments', 'Record hypotheses'],
    failureModes: ['Misidentified gaps', 'No experiment follow-up'],
    outputs: ['gap proposals', 'experiment backlog'],
  }),
  createTechniquePrimitive({
    id: 'tp_knowledge_graph',
    name: 'Knowledge graph build',
    intent: 'Construct and update a knowledge graph from evidence.',
    category: 'research',
    semanticProfileId: 'research',
    domains: ['research', 'analysis'],
    triggers: ['new evidence', 'context synthesis'],
    inputsRequired: ['entity list', 'relation evidence'],
    actions: ['Extract entities', 'Link relations', 'Persist graph'],
    failureModes: ['Stale entities', 'Unverified links'],
    outputs: ['knowledge graph', 'relation audit'],
  }),
  createTechniquePrimitive({
    id: 'tp_real_world_grounding',
    name: 'Real-world grounding',
    intent: 'Ground decisions with real-world constraints and signals.',
    category: 'analysis',
    semanticProfileId: 'analysis',
    domains: ['research', 'risk'],
    triggers: ['speculation risk', 'external dependency'],
    inputsRequired: ['external evidence', 'constraint list'],
    actions: ['Validate assumptions', 'Record constraints', 'Update risk posture'],
    failureModes: ['Unverified assumptions', 'Ignored constraints'],
    outputs: ['grounding report', 'constraint deltas'],
  }),
  createTechniquePrimitive({
    id: 'tp_adversarial_immune',
    name: 'Adversarial immune response',
    intent: 'Detect adversarial patterns and reinforce defenses.',
    category: 'security',
    semanticProfileId: 'security',
    domains: ['security', 'safety'],
    triggers: ['adversarial signals', 'abuse patterns'],
    inputsRequired: ['attack indicators', 'defense playbook'],
    actions: ['Detect anomalies', 'Apply countermeasures', 'Record signatures'],
    failureModes: ['Missed attacks', 'Over-blocking'],
    outputs: ['adversarial report', 'defense updates'],
  }),
  createTechniquePrimitive({
    id: 'tp_federated_learning',
    name: 'Federated learning sync',
    intent: 'Aggregate learning signals across isolated agents.',
    category: 'meta',
    semanticProfileId: 'meta',
    domains: ['meta', 'learning'],
    triggers: ['periodic sync', 'global model update'],
    inputsRequired: ['local gradients', 'aggregation policy'],
    actions: ['Aggregate updates', 'Apply privacy filters', 'Record consensus'],
    failureModes: ['Privacy leakage', 'Divergent updates'],
    outputs: ['global update', 'aggregation report'],
  }),
  createTechniquePrimitive({
    id: 'tp_agent_ecosystem',
    name: 'Agent ecosystem mapping',
    intent: 'Map agent roles, dependencies, and feedback loops.',
    category: 'coordination',
    semanticProfileId: 'coordination',
    domains: ['coordination', 'meta'],
    triggers: ['multi-agent scale', 'ecosystem audit'],
    inputsRequired: ['agent roster', 'interaction logs'],
    actions: ['Map dependencies', 'Identify bottlenecks', 'Record ecosystem graph'],
    failureModes: ['Missing agents', 'Untracked dependencies'],
    outputs: ['ecosystem graph', 'coordination gaps'],
  }),
  createTechniquePrimitive({
    id: 'tp_deliberate',
    name: 'Deliberate on disagreement',
    intent: 'Engage in structured deliberation to resolve disagreement.',
    category: 'coordination',
    semanticProfileId: 'coordination',
    domains: ['coordination', 'consensus'],
    triggers: ['disagreement', 'conflicting conclusions'],
    inputsRequired: ['positions', 'round', 'max rounds'],
    actions: ['Summarize positions', 'Propose synthesis', 'Capture remaining disagreements'],
    failureModes: ['Superficial synthesis', 'Ignores minority views'],
    outputs: ['consensus reached', 'synthesized position', 'remaining disagreements'],
  }),
  createTechniquePrimitive({
    id: 'tp_handle_escalation',
    name: 'Handle escalation',
    intent: 'Prepare context for human review or higher-level intervention.',
    category: 'governance',
    semanticProfileId: 'governance',
    domains: ['governance', 'coordination'],
    triggers: ['blocked decision', 'risk escalation'],
    inputsRequired: ['level', 'reason', 'context'],
    actions: ['Summarize issue', 'Package evidence', 'Recommend next actions'],
    failureModes: ['Missing context', 'Unclear recommendation'],
    outputs: ['escalation id', 'summary', 'recommended actions', 'blocked until resolved'],
  }),
  createTechniquePrimitive({
    id: 'tp_recover_from_checkpoint',
    name: 'Recover from checkpoint',
    intent: 'Assess a checkpoint and recommend a recovery strategy.',
    category: 'recovery',
    semanticProfileId: 'recovery',
    domains: ['recovery', 'resilience'],
    triggers: ['timeout', 'failure recovery', 'interrupted execution'],
    inputsRequired: ['checkpoint', 'time since checkpoint', 'external changes'],
    actions: ['Review checkpoint state', 'Assess environment drift', 'Recommend recovery plan'],
    failureModes: ['Restores stale state', 'Misses external changes'],
    outputs: ['recovery strategy', 'start from primitive', 'state adjustments'],
  }),
  createTechniquePrimitive({
    id: 'tp_merge_parallel_results',
    name: 'Merge parallel results',
    intent: 'Combine outputs from parallel execution branches.',
    category: 'coordination',
    semanticProfileId: 'coordination',
    domains: ['coordination', 'synthesis'],
    triggers: ['parallel execution', 'conflicting outputs'],
    inputsRequired: ['results', 'merge strategy'],
    actions: ['Normalize outputs', 'Resolve conflicts', 'Record merge decision'],
    failureModes: ['Drops critical output', 'Unresolved conflicts'],
    outputs: ['merged results', 'conflicts'],
  }),
  // Universal domain primitives (Part XIX.D1)
  createTechniquePrimitive({
    id: 'tp_algorithm_trace',
    name: 'Algorithm tracing',
    intent: 'Trace ranking, selection, or recommendation logic end-to-end.',
    category: 'analysis',
    semanticProfileId: 'analysis',
    domains: ['analysis', 'product', 'optimization'],
    confidence: absent('uncalibrated'),
    triggers: ['ranking regression', 'unexpected recommendations', 'search relevance issues'],
    inputsRequired: ['ranking pipeline', 'feature definitions', 'signal weights'],
    actions: ['Map scoring stages', 'Trace decision flow', 'Surface signal contributions'],
    failureModes: ['Missed ranking stage', 'Incorrect weight attribution'],
    outputs: ['algorithm trace', 'signal inventory', 'ranking summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_component_graph',
    name: 'Component graphing',
    intent: 'Map UI or system components to reveal composition structure.',
    category: 'design',
    semanticProfileId: 'design',
    domains: ['ux', 'product', 'platform'],
    confidence: absent('uncalibrated'),
    triggers: ['UI refactor', 'unknown component boundaries', 'layout regression'],
    inputsRequired: ['component list', 'render tree', 'routing map'],
    actions: ['Build component graph', 'Identify ownership boundaries', 'Summarize dependencies'],
    failureModes: ['Missing hidden dependencies', 'Over-simplified hierarchy'],
    outputs: ['component graph', 'dependency summary', 'ownership map'],
  }),
  createTechniquePrimitive({
    id: 'tp_scale_pattern',
    name: 'Scale pattern detection',
    intent: 'Identify sharding, replication, and high-availability patterns.',
    category: 'optimization',
    semanticProfileId: 'optimization',
    domains: ['performance', 'reliability', 'platform'],
    confidence: absent('uncalibrated'),
    triggers: ['scaling bottlenecks', 'throughput saturation', 'availability risks'],
    inputsRequired: ['service topology', 'data partitioning', 'traffic profile'],
    actions: ['Detect scaling patterns', 'Map replication paths', 'Summarize HA posture'],
    failureModes: ['Misclassified topology', 'Incomplete infrastructure view'],
    outputs: ['scale pattern map', 'replication summary', 'availability risks'],
  }),
  createTechniquePrimitive({
    id: 'tp_realtime_flow',
    name: 'Real-time flow analysis',
    intent: 'Trace event streams and live update paths end-to-end.',
    category: 'observability',
    semanticProfileId: 'observability',
    domains: ['operations', 'reliability', 'resilience'],
    confidence: absent('uncalibrated'),
    triggers: ['stale updates', 'latency spikes', 'event drops'],
    inputsRequired: ['event sources', 'stream topology', 'subscriber list'],
    actions: ['Map event flow', 'Identify backpressure points', 'Summarize realtime path'],
    failureModes: ['Hidden event paths', 'Missing subscriber coverage'],
    outputs: ['event flow map', 'latency hotspots', 'realtime summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_media_pipeline',
    name: 'Media pipeline tracing',
    intent: 'Trace asset processing from ingestion to delivery.',
    category: 'artifact',
    semanticProfileId: 'artifact',
    domains: ['custom:media', 'product', 'ux'],
    confidence: absent('uncalibrated'),
    triggers: ['transcoding failures', 'asset mismatches', 'CDN invalidation'],
    inputsRequired: ['media assets', 'processing stages', 'delivery targets'],
    actions: ['Map media stages', 'Identify transformations', 'Summarize delivery flow'],
    failureModes: ['Skipped processing stage', 'Incorrect asset mapping'],
    outputs: ['media pipeline map', 'transformations', 'delivery summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_tool_orchestration',
    name: 'Tool orchestration tracing',
    intent: 'Track tool coordination across agents and automation layers.',
    category: 'coordination',
    semanticProfileId: 'coordination',
    domains: ['tooling', 'operations'],
    confidence: absent('uncalibrated'),
    triggers: ['tool failures', 'automation drift', 'orchestration changes'],
    inputsRequired: ['tool registry', 'workflow definitions', 'execution logs'],
    actions: ['Map tool calls', 'Identify coordination gaps', 'Summarize orchestration flow'],
    failureModes: ['Missing tool telemetry', 'Unmapped orchestration steps'],
    outputs: ['tool flow map', 'coordination gaps', 'orchestration summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_distribution_map',
    name: 'Distribution mapping',
    intent: 'Map execution and data distribution across regions and edges.',
    category: 'operations',
    semanticProfileId: 'operations',
    domains: ['platform', 'reliability', 'custom:distribution'],
    confidence: absent('uncalibrated'),
    triggers: ['regional outages', 'latency spikes', 'cache inconsistency'],
    inputsRequired: ['deployment topology', 'region list', 'routing rules'],
    actions: ['Map topology', 'Trace data locality', 'Summarize distribution risks'],
    failureModes: ['Hidden routing paths', 'Incomplete regional data'],
    outputs: ['distribution map', 'locality summary', 'resilience risks'],
  }),
  // Domain-bridging primitives (Part XVII.A.4)
  createTechniquePrimitive({
    id: 'tp_artifact_trace',
    name: 'Artifact-code tracing',
    intent: 'Trace relationships between non-code artifacts and code entities.',
    category: 'artifact',
    semanticProfileId: 'artifact',
    domains: ['artifact', 'product', 'ux'],
    confidence: absent('uncalibrated'),
    triggers: ['design drift', 'asset mismatch', 'non-code artifact changes'],
    inputsRequired: ['artifact path', 'artifact type', 'scope'],
    actions: ['Locate references', 'Resolve linked entities', 'Summarize trace relationships'],
    failureModes: ['Missing metadata', 'Incorrect linkage'],
    outputs: ['linked entities', 'relationship map', 'trace summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_data_lineage',
    name: 'Data lineage tracing',
    intent: 'Track how data transforms as it flows through the system.',
    category: 'analysis',
    semanticProfileId: 'analysis',
    domains: ['data', 'operations', 'observability'],
    confidence: absent('uncalibrated'),
    triggers: ['data pipeline audit', 'unexpected outputs', 'compliance request'],
    inputsRequired: ['data sources', 'data types', 'scope'],
    actions: ['Trace transformations', 'Record sinks', 'Summarize lineage'],
    failureModes: ['Missing lineage steps', 'Incorrect sink mapping'],
    outputs: ['transformations', 'sink list', 'lineage report'],
  }),
  createTechniquePrimitive({
    id: 'tp_policy_verify',
    name: 'Policy verification',
    intent: 'Verify code compliance with regulatory or policy requirements.',
    category: 'compliance',
    semanticProfileId: 'compliance',
    domains: ['compliance', 'policy', 'governance'],
    confidence: absent('uncalibrated'),
    triggers: ['policy change', 'audit request', 'high-risk release'],
    inputsRequired: ['policy id', 'scope', 'evidence requirements'],
    actions: ['Map policy to controls', 'Check code paths', 'Collect evidence'],
    failureModes: ['Incomplete policy mapping', 'False positives'],
    outputs: ['violations', 'evidence', 'compliance summary'],
  }),
  createTechniquePrimitive({
    id: 'tp_platform_map',
    name: 'Platform mapping',
    intent: 'Map code paths to deployment platforms and constraints.',
    category: 'design',
    semanticProfileId: 'design',
    domains: ['platform', 'operations'],
    confidence: absent('uncalibrated'),
    triggers: ['multi-platform build', 'deployment issues', 'porting effort'],
    inputsRequired: ['entity ids', 'platform targets', 'build configs'],
    actions: ['Resolve platform bindings', 'Map constraints', 'Summarize platform coverage'],
    failureModes: ['Missing build metadata', 'Incorrect platform mapping'],
    outputs: ['platform map', 'constraints', 'platform coverage report'],
  }),
  createTechniquePrimitive({
    id: 'tp_metric_trace',
    name: 'Metric tracing',
    intent: 'Trace code paths that affect specific business or user metrics.',
    category: 'observability',
    semanticProfileId: 'observability',
    domains: ['observability', 'product', 'economics'],
    confidence: absent('uncalibrated'),
    triggers: ['metric regression', 'growth experiment', 'metric attribution'],
    inputsRequired: ['metric name', 'tracking context', 'scope'],
    actions: ['Identify metric emitters', 'Map influencing components', 'Estimate impact'],
    failureModes: ['Weak attribution', 'Missing telemetry'],
    outputs: ['affecting entities', 'impact estimate', 'metric trace report'],
  }),
  createTechniquePrimitive({
    id: 'tp_timing_bound',
    name: 'Timing bound analysis',
    intent: 'Analyze worst-case timing bounds for code paths.',
    category: 'optimization',
    semanticProfileId: 'optimization',
    domains: ['performance', 'reliability', 'optimization'],
    confidence: absent('uncalibrated'),
    triggers: ['latency budget breach', 'real-time constraint', 'performance audit'],
    inputsRequired: ['entry points', 'timing budget', 'profiling data'],
    actions: ['Analyze path timings', 'Identify bottlenecks', 'Estimate worst-case latency'],
    failureModes: ['Incomplete instrumentation', 'Non-representative profiles'],
    outputs: ['worst-case latency', 'bottleneck list', 'timing report'],
  }),
  createTechniquePrimitive({
    id: 'tp_state_trace',
    name: 'State transition tracing',
    intent: 'Trace state machine transitions and their triggering code.',
    category: 'analysis',
    semanticProfileId: 'analysis',
    domains: ['operations', 'reliability', 'data'],
    confidence: absent('uncalibrated'),
    triggers: ['state drift', 'workflow bug', 'complex state machine'],
    inputsRequired: ['state definitions', 'entry points', 'transition logs'],
    actions: ['Map transitions', 'Identify triggers', 'Summarize state flow'],
    failureModes: ['Missing state transitions', 'Incorrect mapping'],
    outputs: ['states', 'transitions', 'state trace report'],
  }),
];

export const DEFAULT_TECHNIQUE_PRIMITIVES_BY_ID = new Map(
  DEFAULT_TECHNIQUE_PRIMITIVES.map((item) => [item.id, item])
);

export async function ensureTechniquePrimitives(
  storage: LibrarianStorage,
  options?: { overwrite?: boolean }
): Promise<TechniquePrimitive[]> {
  const existing = await listTechniquePrimitives(storage);
  const defaultsById = DEFAULT_TECHNIQUE_PRIMITIVES_BY_ID;

  if (options?.overwrite) {
    for (const primitive of existing) {
      if (!defaultsById.has(primitive.id)) {
        await deleteTechniquePrimitive(storage, primitive.id);
      }
    }
    for (const primitive of DEFAULT_TECHNIQUE_PRIMITIVES) {
      await saveTechniquePrimitive(storage, primitive);
    }
    return listTechniquePrimitives(storage);
  }

  if (existing.length === 0) {
    for (const primitive of DEFAULT_TECHNIQUE_PRIMITIVES) {
      await saveTechniquePrimitive(storage, primitive);
    }
    return listTechniquePrimitives(storage);
  }

  const existingIds = new Set(existing.map((item) => item.id));
  let added = false;
  for (const primitive of DEFAULT_TECHNIQUE_PRIMITIVES) {
    if (!existingIds.has(primitive.id)) {
      await saveTechniquePrimitive(storage, primitive);
      added = true;
    }
  }
  return added ? listTechniquePrimitives(storage) : existing;
}
