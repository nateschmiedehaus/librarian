/**
 * @fileoverview Tests for Dependency Vulnerability Scanning
 *
 * Tests the npm audit integration and fallback vulnerability detection:
 * - scanDependencyVulnerabilities function
 * - Known vulnerability database fallback
 * - Version comparison utilities
 * - Integration with SecurityAuditHelper
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs';
import * as child_process from 'child_process';
import {
  scanDependencyVulnerabilities,
  SecurityAuditHelper,
  createSecurityAuditHelper,
  type DependencyVulnerability,
  type DependencyScanResult,
} from '../security_audit_helper.js';
import type { Librarian } from '../../api/librarian.js';
import type { ContextPack } from '../../types.js';

// ============================================================================
// MOCKS
// ============================================================================

vi.mock('child_process', () => ({
  execSync: vi.fn(),
}));

vi.mock('fs', async () => {
  const actual = await vi.importActual('fs');
  return {
    ...actual,
    promises: {
      readFile: vi.fn(),
    },
  };
});

function createMockLibrarian(): Librarian {
  const mockPacks: ContextPack[] = [
    {
      packId: 'test-pack-1',
      packType: 'function_context',
      targetId: 'testFunction',
      summary: 'Test function',
      keyFacts: [],
      codeSnippets: [],
      confidence: 0.85,
      createdAt: new Date(),
      accessCount: 1,
      lastOutcome: 'success',
      successCount: 1,
      failureCount: 0,
      relatedFiles: [],
      invalidationTriggers: [],
    },
  ];

  return {
    queryOptional: vi.fn().mockResolvedValue({ packs: mockPacks }),
    queryRequired: vi.fn().mockResolvedValue({ packs: mockPacks }),
    query: vi.fn().mockResolvedValue({ packs: mockPacks }),
  } as unknown as Librarian;
}

// ============================================================================
// TEST SUITES
// ============================================================================

describe('scanDependencyVulnerabilities', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('npm audit integration', () => {
    it('should parse npm audit json output correctly', async () => {
      const mockAuditOutput = JSON.stringify({
        vulnerabilities: {
          lodash: {
            name: 'lodash',
            severity: 'high',
            url: 'https://nvd.nist.gov/vuln/detail/CVE-2021-23337',
            fixAvailable: true,
            range: '<4.17.21',
            via: ['lodash'],
          },
          minimist: {
            name: 'minimist',
            severity: 'critical',
            fixAvailable: { name: 'minimist', version: '1.2.6' },
            range: '<1.2.6',
            via: [{ name: 'CVE-2021-44906', title: 'Prototype Pollution' }],
          },
        },
        metadata: {
          dependencies: {
            prod: 50,
            dev: 100,
            optional: 5,
          },
        },
      });

      vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.source).toBe('npm_audit');
      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.packagesScanned).toBe(155);

      const lodashVuln = result.vulnerabilities.find(v => v.package === 'lodash');
      expect(lodashVuln).toBeDefined();
      expect(lodashVuln?.severity).toBe('high');
      expect(lodashVuln?.fixAvailable).toBe(true);

      const minimistVuln = result.vulnerabilities.find(v => v.package === 'minimist');
      expect(minimistVuln).toBeDefined();
      expect(minimistVuln?.severity).toBe('critical');
    });

    it('should handle npm audit with no vulnerabilities', async () => {
      const mockAuditOutput = JSON.stringify({
        vulnerabilities: {},
        metadata: {
          dependencies: {
            prod: 50,
            dev: 100,
          },
        },
      });

      vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.source).toBe('npm_audit');
      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.packagesScanned).toBe(150);
    });

    it('should handle different severity levels', async () => {
      const mockAuditOutput = JSON.stringify({
        vulnerabilities: {
          pkg1: { severity: 'critical', name: 'pkg1', via: [] },
          pkg2: { severity: 'high', name: 'pkg2', via: [] },
          pkg3: { severity: 'moderate', name: 'pkg3', via: [] },
          pkg4: { severity: 'low', name: 'pkg4', via: [] },
        },
        metadata: { dependencies: {} },
      });

      vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.vulnerabilities.map(v => v.severity)).toEqual([
        'critical',
        'high',
        'moderate',
        'low',
      ]);
    });
  });

  describe('fallback to known vulnerabilities', () => {
    it('should fall back when npm audit fails', async () => {
      vi.mocked(child_process.execSync).mockImplementation(() => {
        throw new Error('npm audit failed');
      });

      const mockPackageJson = JSON.stringify({
        dependencies: {
          lodash: '^4.17.19',
          express: '^4.17.1',
        },
        devDependencies: {
          minimist: '^1.2.0',
        },
      });

      vi.mocked(fs.promises.readFile).mockResolvedValue(mockPackageJson);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.source).toBe('known_vulnerabilities');
      expect(result.packagesScanned).toBe(3);

      // Should detect lodash vulnerability (4.17.19 < 4.17.21)
      const lodashVuln = result.vulnerabilities.find(v => v.package === 'lodash');
      expect(lodashVuln).toBeDefined();
      expect(lodashVuln?.severity).toBe('high');

      // Should detect minimist vulnerability (1.2.0 < 1.2.6)
      const minimistVuln = result.vulnerabilities.find(v => v.package === 'minimist');
      expect(minimistVuln).toBeDefined();
      expect(minimistVuln?.severity).toBe('critical');
    });

    it('should not report vulnerabilities for patched versions', async () => {
      vi.mocked(child_process.execSync).mockImplementation(() => {
        throw new Error('npm audit failed');
      });

      const mockPackageJson = JSON.stringify({
        dependencies: {
          lodash: '^4.17.21',
          minimist: '^1.2.6',
        },
      });

      vi.mocked(fs.promises.readFile).mockResolvedValue(mockPackageJson);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.source).toBe('known_vulnerabilities');
      expect(result.vulnerabilities).toHaveLength(0);
    });

    it('should handle multiple vulnerabilities for same package', async () => {
      vi.mocked(child_process.execSync).mockImplementation(() => {
        throw new Error('npm audit failed');
      });

      const mockPackageJson = JSON.stringify({
        dependencies: {
          axios: '^0.20.0', // Vulnerable to both SSRF and CSRF
        },
      });

      vi.mocked(fs.promises.readFile).mockResolvedValue(mockPackageJson);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      const axiosVulns = result.vulnerabilities.filter(v => v.package === 'axios');
      expect(axiosVulns.length).toBeGreaterThanOrEqual(1);
    });

    it('should handle missing package.json gracefully', async () => {
      vi.mocked(child_process.execSync).mockImplementation(() => {
        throw new Error('npm audit failed');
      });

      vi.mocked(fs.promises.readFile).mockRejectedValue(new Error('ENOENT'));

      const result = await scanDependencyVulnerabilities('/nonexistent/workspace');

      expect(result.source).toBe('known_vulnerabilities');
      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.packagesScanned).toBe(0);
    });

    it('should handle malformed package.json', async () => {
      vi.mocked(child_process.execSync).mockImplementation(() => {
        throw new Error('npm audit failed');
      });

      vi.mocked(fs.promises.readFile).mockResolvedValue('invalid json {{{');

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.source).toBe('known_vulnerabilities');
      expect(result.vulnerabilities).toHaveLength(0);
    });
  });

  describe('timing', () => {
    it('should track scan time', async () => {
      const mockAuditOutput = JSON.stringify({
        vulnerabilities: {},
        metadata: { dependencies: {} },
      });

      vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      expect(result.scanTimeMs).toBeGreaterThanOrEqual(0);
    });
  });
});

describe('SecurityAuditHelper with dependency scanning', () => {
  let helper: SecurityAuditHelper;
  let mockLibrarian: Librarian;

  beforeEach(() => {
    vi.clearAllMocks();
    mockLibrarian = createMockLibrarian();
    helper = new SecurityAuditHelper(mockLibrarian);
  });

  it('should include dependency vulnerabilities in audit report when workspace provided', async () => {
    const mockAuditOutput = JSON.stringify({
      vulnerabilities: {
        lodash: {
          name: 'lodash',
          severity: 'high',
          fixAvailable: true,
          range: '<4.17.21',
          via: ['lodash'],
        },
      },
      metadata: { dependencies: { prod: 10 } },
    });

    vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

    const result = await helper.audit({
      files: ['src/test.ts'],
      checkTypes: ['injection'],
      workspace: '/test/workspace',
    });

    expect(result.dependencyVulnerabilities).toBeDefined();
    expect(result.dependencyVulnerabilities).toHaveLength(1);
    expect(result.dependencyVulnerabilities?.[0].package).toBe('lodash');

    // Should also be in findings
    const depFinding = result.findings.find(f => f.title.includes('lodash'));
    expect(depFinding).toBeDefined();
    expect(depFinding?.type).toBe('components');
    expect(depFinding?.cweId).toBe('CWE-1395');
  });

  it('should not include dependency scan when workspace not provided', async () => {
    const result = await helper.audit({
      files: ['src/test.ts'],
      checkTypes: ['injection'],
    });

    expect(result.dependencyVulnerabilities).toBeUndefined();
  });

  it('should add evidence refs for dependency scan', async () => {
    const mockAuditOutput = JSON.stringify({
      vulnerabilities: {
        lodash: { severity: 'high', via: [] },
      },
      metadata: { dependencies: { prod: 50 } },
    });

    vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

    const result = await helper.audit({
      files: [],
      checkTypes: [],
      workspace: '/test/workspace',
    });

    expect(result.evidenceRefs).toContain('dependency_scan:npm_audit:1_vulns');
    expect(result.evidenceRefs).toContain('packages_scanned:50');
  });

  it('should compute correct severity breakdown including dependencies', async () => {
    const mockAuditOutput = JSON.stringify({
      vulnerabilities: {
        pkg1: { severity: 'critical', via: [] },
        pkg2: { severity: 'high', via: [] },
        pkg3: { severity: 'moderate', via: [] },
      },
      metadata: { dependencies: {} },
    });

    vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

    const result = await helper.audit({
      files: [],
      checkTypes: [],
      workspace: '/test/workspace',
    });

    expect(result.severity.critical).toBe(1);
    expect(result.severity.high).toBe(1);
    expect(result.severity.medium).toBe(1); // 'moderate' maps to 'medium'
  });
});

describe('Version comparison', () => {
  // Testing the internal version comparison through the fallback mechanism

  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(child_process.execSync).mockImplementation(() => {
      throw new Error('npm audit failed');
    });
  });

  const testVersions = [
    { installed: '^4.17.19', below: '4.17.21', vulnerable: true },
    { installed: '~4.17.19', below: '4.17.21', vulnerable: true },
    { installed: '>=4.17.19', below: '4.17.21', vulnerable: true },
    { installed: '4.17.21', below: '4.17.21', vulnerable: false },
    { installed: '4.17.22', below: '4.17.21', vulnerable: false },
    { installed: '5.0.0', below: '4.17.21', vulnerable: false },
    { installed: '3.0.0', below: '4.17.21', vulnerable: true },
    { installed: '4.0.0', below: '4.17.21', vulnerable: true },
    { installed: '4.17.0', below: '4.17.21', vulnerable: true },
  ];

  testVersions.forEach(({ installed, below, vulnerable }) => {
    it(`should ${vulnerable ? '' : 'not '}detect ${installed} as vulnerable (below ${below})`, async () => {
      const mockPackageJson = JSON.stringify({
        dependencies: {
          lodash: installed,
        },
      });

      vi.mocked(fs.promises.readFile).mockResolvedValue(mockPackageJson);

      const result = await scanDependencyVulnerabilities('/test/workspace');

      const lodashVuln = result.vulnerabilities.find(v => v.package === 'lodash');
      if (vulnerable) {
        expect(lodashVuln).toBeDefined();
      } else {
        expect(lodashVuln).toBeUndefined();
      }
    });
  });
});

describe('Dependency vulnerability to finding conversion', () => {
  let helper: SecurityAuditHelper;
  let mockLibrarian: Librarian;

  beforeEach(() => {
    vi.clearAllMocks();
    mockLibrarian = createMockLibrarian();
    helper = new SecurityAuditHelper(mockLibrarian);
  });

  it('should convert dependency vulnerabilities to proper security findings', async () => {
    const mockAuditOutput = JSON.stringify({
      vulnerabilities: {
        testpkg: {
          name: 'testpkg',
          severity: 'high',
          url: 'https://example.com/vuln',
          fixAvailable: true,
          range: '<1.0.0',
          via: ['dep1', 'dep2'],
        },
      },
      metadata: { dependencies: {} },
    });

    vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

    const result = await helper.audit({
      files: [],
      checkTypes: [],
      workspace: '/test/workspace',
    });

    const finding = result.findings[0];
    expect(finding.type).toBe('components');
    expect(finding.severity).toBe('high');
    expect(finding.file).toBe('/test/workspace/package.json');
    expect(finding.title).toContain('testpkg');
    expect(finding.cweId).toBe('CWE-1395');
    expect(finding.remediation).toContain('npm audit fix');
    expect(finding.confidence).toBe(0.95);
    expect(finding.codeSnippet).toContain('dep1 -> dep2');
  });

  it('should handle vulnerabilities without fix available', async () => {
    const mockAuditOutput = JSON.stringify({
      vulnerabilities: {
        unfixable: {
          name: 'unfixable',
          severity: 'critical',
          fixAvailable: false,
          range: '*',
          via: [],
        },
      },
      metadata: { dependencies: {} },
    });

    vi.mocked(child_process.execSync).mockReturnValue(mockAuditOutput);

    const result = await helper.audit({
      files: [],
      checkTypes: [],
      workspace: '/test/workspace',
    });

    const finding = result.findings[0];
    expect(finding.remediation).toContain('Monitor for updates');
    expect(finding.remediation).toContain('alternative package');
  });
});
