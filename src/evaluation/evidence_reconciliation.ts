type MetricSummary = {
  mean: number;
  target: number;
  met: boolean;
};

export type EvidenceManifestSummary = {
  generatedAt: string;
  metrics: {
    retrievalRecallAt5: MetricSummary;
    contextPrecision: MetricSummary;
    hallucinationRate: MetricSummary;
    faithfulness: MetricSummary;
    answerRelevancy: MetricSummary;
  };
  ab: {
    lift: number;
    pValue: number;
    targetLift: number;
    significant: boolean;
  };
  performance: {
    p50LatencyMs: number;
    p99LatencyMs: number;
    memoryPerKLOC: number;
    targetMemoryPerKLOC: number;
  };
  scenarios: {
    total: number;
    passing: number;
    failing: number;
  };
};

export type EvidenceSummary = EvidenceManifestSummary & {
  derived: {
    memoryMet: boolean;
    liftMet: boolean;
    scenarioPassRate: number;
  };
};

function round(value: number, digits = 2): number {
  const factor = 10 ** digits;
  return Math.round(value * factor) / factor;
}

export function buildEvidenceSummary(manifest: EvidenceManifestSummary): EvidenceSummary {
  const memoryMet = manifest.performance.memoryPerKLOC <= manifest.performance.targetMemoryPerKLOC;
  const liftMet = manifest.ab.lift >= manifest.ab.targetLift;
  const scenarioPassRate = manifest.scenarios.total > 0
    ? manifest.scenarios.passing / manifest.scenarios.total
    : 0;
  return {
    ...manifest,
    derived: {
      memoryMet,
      liftMet,
      scenarioPassRate,
    },
  };
}

export function renderStatusBlock(summary: EvidenceSummary): string {
  const metrics = summary.metrics;
  const rows = [
    ['Retrieval Recall@5', metrics.retrievalRecallAt5.target, metrics.retrievalRecallAt5.mean, metrics.retrievalRecallAt5.met],
    ['Context Precision', metrics.contextPrecision.target, metrics.contextPrecision.mean, metrics.contextPrecision.met],
    ['Hallucination Rate', metrics.hallucinationRate.target, metrics.hallucinationRate.mean, metrics.hallucinationRate.met],
    ['Faithfulness', metrics.faithfulness.target, metrics.faithfulness.mean, metrics.faithfulness.met],
    ['Answer Relevancy', metrics.answerRelevancy.target, metrics.answerRelevancy.mean, metrics.answerRelevancy.met],
  ];

  const metricLines = rows
    .map(([name, target, measured, met]) => {
      const status = met ? 'MET' : 'NOT MET';
      return `| ${name} | ${target} | ${measured} | ${status} |`;
    })
    .join('\n');

  const memoryStatus = summary.derived.memoryMet ? 'MET' : 'NOT MET';
  const liftStatus = summary.derived.liftMet ? 'MET' : 'NOT MET';
  const scenarioRate = round(summary.derived.scenarioPassRate * 100, 1);

  return [
    '### Evidence-Backed Status (Autogenerated)',
    `Generated: ${summary.generatedAt}`,
    '',
    '| Metric | Target | Measured | Status |',
    '| --- | --- | --- | --- |',
    metricLines,
    '',
    `| A/B Lift | ${summary.ab.targetLift} | ${round(summary.ab.lift, 4)} (p-value ${round(summary.ab.pValue, 4)}) | ${liftStatus} |`,
    `| Memory per 1K LOC | ${summary.performance.targetMemoryPerKLOC} MB | ${round(summary.performance.memoryPerKLOC, 2)} MB | ${memoryStatus} |`,
    '',
    `Scenario Families: ${summary.scenarios.passing}/${summary.scenarios.total} (${scenarioRate}%)`,
  ].join('\n');
}

export function renderValidationBlock(summary: EvidenceSummary): string {
  const scenarioRate = round(summary.derived.scenarioPassRate * 100, 1);
  return [
    '### Validation Summary (Autogenerated)',
    `Generated: ${summary.generatedAt}`,
    '',
    `Scenario Families: ${summary.scenarios.passing}/${summary.scenarios.total} (${scenarioRate}%)`,
    `A/B Lift: ${round(summary.ab.lift, 4)} (p-value ${round(summary.ab.pValue, 4)})`,
    `Memory per 1K LOC: ${round(summary.performance.memoryPerKLOC, 2)} MB (target ${summary.performance.targetMemoryPerKLOC} MB)`,
  ].join('\n');
}

export function applyAutogenBlock(contents: string, markerName: string, newBlock: string): string {
  const start = `<!-- ${markerName}_START -->`;
  const end = `<!-- ${markerName}_END -->`;
  const startIdx = contents.indexOf(start);
  const endIdx = contents.indexOf(end);

  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    return `${contents}\n${start}\n${newBlock}\n${end}`;
  }

  const before = contents.slice(0, startIdx + start.length);
  const after = contents.slice(endIdx);
  return `${before}\n${newBlock}\n${after}`;
}

export function reconcileGates(
  gates: Record<string, any>,
  summary: EvidenceSummary,
): Record<string, any> {
  const next = { ...gates };
  next.lastUpdated = summary.generatedAt;
  const blockingMetrics: Record<string, { target: string; measured: string; status: string }> = {
    'Retrieval Recall@5': {
      target: `>=${summary.metrics.retrievalRecallAt5.target}`,
      measured: `${summary.metrics.retrievalRecallAt5.mean}`,
      status: summary.metrics.retrievalRecallAt5.met ? 'MET' : 'NOT MET',
    },
    'Context Precision': {
      target: `>=${summary.metrics.contextPrecision.target}`,
      measured: `${summary.metrics.contextPrecision.mean}`,
      status: summary.metrics.contextPrecision.met ? 'MET' : 'NOT MET',
    },
    'Hallucination Rate': {
      target: `<${summary.metrics.hallucinationRate.target}`,
      measured: `${summary.metrics.hallucinationRate.mean}`,
      status: summary.metrics.hallucinationRate.met ? 'MET' : 'NOT MET',
    },
    'Faithfulness': {
      target: `>=${summary.metrics.faithfulness.target}`,
      measured: `${summary.metrics.faithfulness.mean}`,
      status: summary.metrics.faithfulness.met ? 'MET' : 'NOT MET',
    },
    'Answer Relevancy': {
      target: `>=${summary.metrics.answerRelevancy.target}`,
      measured: `${summary.metrics.answerRelevancy.mean}`,
      status: summary.metrics.answerRelevancy.met ? 'MET' : 'NOT MET',
    },
    'A/B Lift': {
      target: `>=${summary.ab.targetLift}`,
      measured: `${summary.ab.lift} (p=${summary.ab.pValue})`,
      status: summary.derived.liftMet ? 'MET' : 'NOT MET',
    },
    'Memory per 1K LOC': {
      target: `<=${summary.performance.targetMemoryPerKLOC} MB`,
      measured: `${summary.performance.memoryPerKLOC} MB`,
      status: summary.derived.memoryMet ? 'MET' : 'NOT MET',
    },
  };

  if (!next.validationStatus) {
    next.validationStatus = {};
  }
  next.validationStatus.blockingMetrics = blockingMetrics;
  next.validationStatus.lastVerified = summary.generatedAt;
  return next;
}
