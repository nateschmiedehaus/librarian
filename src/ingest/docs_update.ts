/**
 * Automatic Docs Update - Updates repo agent docs with librarian usage info
 *
 * During bootstrap/indexing, this module:
 * 1. Detects AGENTS.md, CLAUDE.md, or similar files in the repo
 * 2. Generates a librarian usage section with current capabilities
 * 3. Inserts or updates the section (idempotent)
 *
 * Philosophy: Keep the team informed about librarian capabilities
 * without requiring manual documentation updates.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';
import type { BootstrapCapabilities, BootstrapReport } from '../types.js';

export interface DocsUpdateConfig {
  /** Workspace root directory */
  workspace: string;
  /** Bootstrap report with capabilities and stats */
  report: BootstrapReport;
  /** Capabilities determined during bootstrap */
  capabilities: BootstrapCapabilities;
  /** Dry run mode - don't actually write files */
  dryRun?: boolean;
  /** Skip if section already exists (default: false - update if stale) */
  skipIfExists?: boolean;
}

export interface DocsUpdateResult {
  /** Files that were updated */
  filesUpdated: string[];
  /** Files that were checked but not updated */
  filesSkipped: string[];
  /** Any errors encountered */
  errors: string[];
  /** Whether the update was successful */
  success: boolean;
}

const LIBRARIAN_SECTION_START = '<!-- LIBRARIAN_DOCS_START -->';
const LIBRARIAN_SECTION_END = '<!-- LIBRARIAN_DOCS_END -->';

const AGENT_DOC_PATTERNS = [
  'AGENTS.md',
  'docs/AGENTS.md',
  'CLAUDE.md',
  'docs/CLAUDE.md',
  'CODEX.md',
  'docs/CODEX.md',
  '.github/AGENTS.md',
];

/**
 * Update repo documentation with librarian usage information.
 * Called automatically after successful bootstrap.
 */
export async function updateRepoDocs(config: DocsUpdateConfig): Promise<DocsUpdateResult> {
  const result: DocsUpdateResult = {
    filesUpdated: [],
    filesSkipped: [],
    errors: [],
    success: true,
  };

  const { workspace, report, capabilities, dryRun, skipIfExists } = config;

  // Find agent documentation files
  const agentDocs = await findAgentDocs(workspace);

  if (agentDocs.length === 0) {
    result.filesSkipped.push('(no agent docs found)');
    return result;
  }

  // Generate the librarian section content
  const sectionContent = generateLibrarianSection(report, capabilities);

  for (const docPath of agentDocs) {
    try {
      const updated = await updateDocFile(docPath, sectionContent, { dryRun, skipIfExists });
      if (updated) {
        result.filesUpdated.push(path.relative(workspace, docPath));
      } else {
        result.filesSkipped.push(path.relative(workspace, docPath));
      }
    } catch (error) {
      result.errors.push(`${path.relative(workspace, docPath)}: ${error instanceof Error ? error.message : String(error)}`);
      result.success = false;
    }
  }

  return result;
}

/**
 * Find agent documentation files in the workspace.
 */
async function findAgentDocs(workspace: string): Promise<string[]> {
  const found: string[] = [];

  for (const pattern of AGENT_DOC_PATTERNS) {
    const fullPath = path.join(workspace, pattern);
    try {
      await fs.access(fullPath);
      found.push(fullPath);
    } catch {
      // File doesn't exist, skip
    }
  }

  return found;
}

/**
 * Generate the librarian documentation section content.
 */
function generateLibrarianSection(report: BootstrapReport, capabilities: BootstrapCapabilities): string {
  const stats = report.phases.reduce((acc, phase) => {
    acc[phase.phase.name] = phase.itemsProcessed;
    return acc;
  }, {} as Record<string, number>);

  const availableCapabilities = Object.entries(capabilities)
    .filter(([, enabled]) => enabled)
    .map(([name]) => formatCapabilityName(name));

  const limitedCapabilities = Object.entries(capabilities)
    .filter(([, enabled]) => !enabled)
    .map(([name]) => formatCapabilityName(name));

  const lastIndexed = report.completedAt?.toISOString() ?? new Date().toISOString();

  const lines: string[] = [
    LIBRARIAN_SECTION_START,
    '',
    '## Librarian: Codebase Knowledge System',
    '',
    '> Auto-generated by librarian bootstrap. Do not edit manually.',
    '',
    '### What is Librarian?',
    '',
    'Librarian is the **codebase knowledge backbone** for Wave0. It provides:',
    '- **Semantic search**: Find code by meaning, not just keywords',
    '- **Context packs**: Pre-computed context for common tasks',
    '- **Function knowledge**: Purpose, signatures, and relationships',
    '- **Graph analysis**: Call graphs, import graphs, and metrics',
    '',
    '### How to Use Librarian',
    '',
    '```typescript',
    '// 1. Get the librarian instance',
    "import { getLibrarian } from '@wave0/librarian';",
    'const librarian = await getLibrarian(workspaceRoot);',
    '',
    '// 2. Query for context',
    "const context = await librarian.query('How does authentication work?');",
    '',
    '// 3. Use in prompts',
    'const prompt = `Given this context:\\n${context}\\nImplement...`;',
    '```',
    '',
    '### Current Capabilities',
    '',
    availableCapabilities.length > 0
      ? `**Available**: ${availableCapabilities.join(', ')}`
      : '*No capabilities currently available*',
    '',
    limitedCapabilities.length > 0
      ? `**Limited/Unavailable**: ${limitedCapabilities.join(', ')}`
      : '',
    '',
    '### Index Statistics',
    '',
    `- **Last indexed**: ${lastIndexed}`,
    `- **Files processed**: ${report.totalFilesProcessed}`,
    `- **Functions indexed**: ${report.totalFunctionsIndexed}`,
    `- **Context packs**: ${report.totalContextPacksCreated}`,
    '',
    '### Key Documentation',
    '',
    '- **Entry point**: `docs/librarian/README.md`',
    '- **API reference**: `src/librarian/api/README.md`',
    '- **Query guide**: `docs/librarian/query-guide.md`',
    '',
    '### When to Re-index',
    '',
    'Librarian auto-watches for changes. Manual reindex needed when:',
    '- Major refactoring (>50 files changed)',
    '- After git operations that bypass file watchers',
    '- When embeddings seem stale',
    '',
    '```bash',
    '# Trigger manual reindex',
    'npx librarian reindex --force',
    '```',
    '',
    LIBRARIAN_SECTION_END,
  ].filter(line => line !== ''); // Remove empty lines between filtered capability lines

  return lines.join('\n');
}

/**
 * Format a capability name for display.
 */
function formatCapabilityName(name: string): string {
  return name
    .replace(/([A-Z])/g, ' $1')
    .toLowerCase()
    .trim()
    .replace(/^has /, '');
}

/**
 * Update a documentation file with the librarian section.
 */
async function updateDocFile(
  filePath: string,
  sectionContent: string,
  options: { dryRun?: boolean; skipIfExists?: boolean }
): Promise<boolean> {
  const content = await fs.readFile(filePath, 'utf-8');

  const hasSection = content.includes(LIBRARIAN_SECTION_START);

  if (hasSection && options.skipIfExists) {
    return false;
  }

  let newContent: string;

  if (hasSection) {
    // Replace existing section
    const startIdx = content.indexOf(LIBRARIAN_SECTION_START);
    const endIdx = content.indexOf(LIBRARIAN_SECTION_END);

    if (endIdx === -1) {
      // Malformed - append end marker
      newContent = content.replace(
        LIBRARIAN_SECTION_START,
        sectionContent
      );
    } else {
      const before = content.substring(0, startIdx);
      const after = content.substring(endIdx + LIBRARIAN_SECTION_END.length);
      newContent = before + sectionContent + after;
    }
  } else {
    // Append new section
    newContent = content.trimEnd() + '\n\n---\n\n' + sectionContent + '\n';
  }

  // Check if content actually changed
  if (newContent === content) {
    return false;
  }

  if (!options.dryRun) {
    await fs.writeFile(filePath, newContent, 'utf-8');
  }

  return true;
}

/**
 * Check if librarian docs update is needed.
 */
export async function isDocsUpdateNeeded(workspace: string): Promise<boolean> {
  const agentDocs = await findAgentDocs(workspace);

  for (const docPath of agentDocs) {
    try {
      const content = await fs.readFile(docPath, 'utf-8');
      if (!content.includes(LIBRARIAN_SECTION_START)) {
        return true;
      }
    } catch {
      // File doesn't exist or can't be read
    }
  }

  return false;
}
