import * as fs from 'fs/promises'; import * as path from 'path';
export type EscapeHatchReason = 'trivial_file' | 'unindexed' | 'explicit_override' | 'config_file';
export interface EscapeHatchRequest { filePath: string; reason?: string; content?: string; indexed?: boolean; }
export interface EscapeHatchOptions { maxLines?: number; maxComplexity?: number; maxConfigBytes?: number; readFile?: (path: string) => Promise<string | Buffer>; }
const CONFIG_EXT = new Set(['.json', '.yaml', '.yml']); const DEFAULT_MAX_LINES = 50; const DEFAULT_MAX_COMPLEXITY = 5; const DEFAULT_MAX_CONFIG_BYTES = 1024; const estimateComplexity = (content: string): number => (content.match(/\b(if|for|while|case|catch|switch)\b|&&|\|\||\?/g) ?? []).length;
export async function evaluateEscapeHatch(req: EscapeHatchRequest, options: EscapeHatchOptions = {}): Promise<{ allowed: boolean; reason?: EscapeHatchReason }> { if (req.indexed === false) return { allowed: true, reason: 'unindexed' }; if (typeof req.reason === 'string' && req.reason.trim().length > 10) return { allowed: true, reason: 'explicit_override' }; const readFile = options.readFile ?? (async (filePath: string) => fs.readFile(filePath, 'utf8')); const content = typeof req.content === 'string' ? req.content : await readFile(req.filePath); const text = typeof content === 'string' ? content : content.toString('utf8'); const maxConfigBytes = options.maxConfigBytes ?? DEFAULT_MAX_CONFIG_BYTES; const ext = path.extname(req.filePath).toLowerCase(); if (CONFIG_EXT.has(ext) && Buffer.byteLength(text, 'utf8') <= maxConfigBytes) return { allowed: true, reason: 'config_file' }; const maxLines = options.maxLines ?? DEFAULT_MAX_LINES; const maxComplexity = options.maxComplexity ?? DEFAULT_MAX_COMPLEXITY; const lines = text.split(/\r?\n/).length; const complexity = estimateComplexity(text); if (lines <= maxLines && complexity <= maxComplexity) return { allowed: true, reason: 'trivial_file' }; return { allowed: false }; }
