/**
 * @fileoverview Conceptual Verification Implementation
 *
 * Detects errors beyond code - logical, theoretical, design, and domain errors:
 * - Logical errors: Contradictions, incomplete case handling
 * - Theoretical errors: Algorithm misuse, distributed system fallacies
 * - Design errors: Abstraction leaks, temporal coupling
 * - Domain errors: Business rule violations, language inconsistency
 * - Consistency errors: Doc/code drift, decision drift
 * - Security model errors: Trust boundary violations
 *
 * Design principles:
 * - Evidence-based detection with provenance
 * - Confidence-weighted findings
 * - Root cause analysis
 * - Actionable fix suggestions
 */

import { randomUUID } from 'crypto';
import type {
  ConceptualErrorCategory,
  ErrorSubcategory,
  ConceptualError,
  ErrorSeverity,
  ErrorLocation,
  ErrorScope,
  ConceptualEvidence,
  RootCauseAnalysis,
  ContributingFactor,
  Implication,
  SuggestedFix,
  FixStep,
  DetectionMethod,
  DetectionRule,
  DetectionPattern,
  ErrorStatus,
  VerificationContext,
  VerificationConfig,
  VerificationReport,
  VerificationSummary,
  CategoryBreakdown,
  VerificationTrends,
  VerificationRecommendation,
  ConceptualVerifier as IConceptualVerifier,
  ErrorExplanation,
  ERROR_SUBCATEGORIES,
  BUILT_IN_VERIFICATION_RULES,
} from './conceptual_verification.js';
import type { BoundedContext, ConfidenceAssessment } from './types.js';
import type { StrategicStorage, ConceptualErrorQueryOptions } from './storage.js';
import { createSystemProvenance, scoreToLevel } from './strategic_context.js';

// ============================================================================
// CONCEPTUAL VERIFIER IMPLEMENTATION
// ============================================================================

export interface ConceptualVerifierOptions {
  /** Custom verification rules */
  customRules?: DetectionRule[];
  /** Minimum confidence to report error */
  minConfidence?: number;
  /** Enable learning from resolved errors */
  enableLearning?: boolean;
  /** Custom detection patterns */
  customPatterns?: DetectionPattern[];
}

export interface VerificationInput {
  /** Code content to analyze */
  code?: {
    files: Array<{
      path: string;
      content: string;
      language: string;
    }>;
    functions?: Array<{
      name: string;
      file: string;
      startLine: number;
      endLine: number;
      signature?: string;
      body?: string;
    }>;
  };
  /** Documentation content */
  documentation?: {
    readme?: string;
    apiDocs?: string;
    comments?: Array<{
      file: string;
      line: number;
      content: string;
    }>;
  };
  /** Architecture information */
  architecture?: {
    decisions?: Array<{
      id: string;
      title: string;
      decision: string;
      rationale: string;
    }>;
    dependencies?: Array<{
      from: string;
      to: string;
      type: string;
    }>;
    modules?: Array<{
      name: string;
      files: string[];
      publicApi?: string[];
    }>;
  };
  /** Domain model */
  domain?: {
    terms?: Array<{
      term: string;
      definition: string;
    }>;
    rules?: Array<{
      name: string;
      description: string;
      constraints?: string[];
    }>;
    contexts?: BoundedContext[];
  };
}

/**
 * Conceptual Verifier
 *
 * Detects conceptual, logical, and theoretical errors
 * that go beyond traditional code analysis.
 */
export class ConceptualVerifier implements IConceptualVerifier {
  private readonly storage: StrategicStorage;
  private readonly rules: DetectionRule[];
  private readonly patterns: DetectionPattern[];
  private readonly minConfidence: number;
  private readonly enableLearning: boolean;

  constructor(
    storage: StrategicStorage,
    options: ConceptualVerifierOptions = {},
  ) {
    this.storage = storage;
    this.rules = [...BUILT_IN_VERIFICATION_RULES, ...(options.customRules ?? [])];
    this.patterns = options.customPatterns ?? [];
    this.minConfidence = options.minConfidence ?? 0.5;
    this.enableLearning = options.enableLearning ?? true;
  }

  // --------------------------------------------------------------------------
  // VERIFICATION
  // --------------------------------------------------------------------------

  /**
   * Run all verification checks
   */
  async verifyAll(input: VerificationInput): Promise<VerificationReport> {
    const startedAt = new Date().toISOString();
    const errors: ConceptualError[] = [];

    // Run logical verification
    const logical = await this.verifyLogical(input);
    errors.push(...logical);

    // Run theoretical verification
    const theoretical = await this.verifyTheoretical(input);
    errors.push(...theoretical);

    // Run design verification
    const design = await this.verifyDesign(input);
    errors.push(...design);

    // Run domain verification
    const domain = await this.verifyDomain(input);
    errors.push(...domain);

    // Run consistency verification
    const consistency = await this.verifyConsistency(input);
    errors.push(...consistency);

    // Run security model verification
    const security = await this.verifySecurityModel(input);
    errors.push(...security);

    // Filter by confidence
    const filteredErrors = errors.filter(
      (e) => e.confidence.score >= this.minConfidence,
    );

    // Save errors to storage
    for (const error of filteredErrors) {
      this.storage.saveConceptualError(error);
    }

    const completedAt = new Date().toISOString();

    // Build report
    return this.buildReport(filteredErrors, startedAt, completedAt);
  }

  /**
   * Verify logical consistency
   */
  async verifyLogical(input: VerificationInput): Promise<ConceptualError[]> {
    const errors: ConceptualError[] = [];

    // Check for contradictory conditions
    if (input.code?.functions) {
      for (const func of input.code.functions) {
        const contradictions = this.detectContradictions(func);
        errors.push(...contradictions);
      }
    }

    // Check for incomplete case handling
    if (input.code?.files) {
      for (const file of input.code.files) {
        const incomplete = this.detectIncompleteCases(file);
        errors.push(...incomplete);
      }
    }

    // Check for circular reasoning in documentation
    if (input.documentation) {
      const circular = this.detectCircularDefinitions(input.documentation);
      errors.push(...circular);
    }

    return errors;
  }

  /**
   * Verify theoretical soundness
   */
  async verifyTheoretical(input: VerificationInput): Promise<ConceptualError[]> {
    const errors: ConceptualError[] = [];

    // Check for distributed system fallacies
    if (input.code?.files) {
      const fallacies = this.detectDistributedFallacies(input.code.files);
      errors.push(...fallacies);
    }

    // Check for algorithm complexity issues
    if (input.code?.functions) {
      const complexity = this.detectComplexityIssues(input.code.functions);
      errors.push(...complexity);
    }

    // Check for concurrency issues
    if (input.code?.files) {
      const concurrency = this.detectConcurrencyIssues(input.code.files);
      errors.push(...concurrency);
    }

    return errors;
  }

  /**
   * Verify design quality
   */
  async verifyDesign(input: VerificationInput): Promise<ConceptualError[]> {
    const errors: ConceptualError[] = [];

    // Check for abstraction leaks
    if (input.architecture?.modules) {
      const leaks = this.detectAbstractionLeaks(input.architecture.modules);
      errors.push(...leaks);
    }

    // Check for temporal coupling
    if (input.code?.functions) {
      const coupling = this.detectTemporalCoupling(input.code.functions);
      errors.push(...coupling);
    }

    // Check for violation of design principles
    if (input.architecture?.dependencies) {
      const violations = this.detectDesignViolations(input.architecture);
      errors.push(...violations);
    }

    return errors;
  }

  /**
   * Verify domain model
   */
  async verifyDomain(input: VerificationInput): Promise<ConceptualError[]> {
    const errors: ConceptualError[] = [];

    // Check for undefined domain terms
    if (input.domain?.terms && input.code?.files) {
      const undefined_ = this.detectUndefinedTerms(input.domain.terms, input.code.files);
      errors.push(...undefined_);
    }

    // Check for business rule violations
    if (input.domain?.rules && input.code?.functions) {
      const violations = this.detectRuleViolations(input.domain.rules, input.code.functions);
      errors.push(...violations);
    }

    // Check for context boundary violations
    if (input.domain?.contexts) {
      const boundary = this.detectBoundaryViolations(input.domain.contexts);
      errors.push(...boundary);
    }

    return errors;
  }

  /**
   * Verify consistency between artifacts
   */
  async verifyConsistency(input: VerificationInput): Promise<ConceptualError[]> {
    const errors: ConceptualError[] = [];

    // Check doc/code drift
    if (input.documentation && input.code) {
      const drift = this.detectDocCodeDrift(input.documentation, input.code);
      errors.push(...drift);
    }

    // Check decision drift (ADR vs implementation)
    if (input.architecture?.decisions && input.code) {
      const decisionDrift = this.detectDecisionDrift(
        input.architecture.decisions,
        input.code,
      );
      errors.push(...decisionDrift);
    }

    return errors;
  }

  /**
   * Verify security model
   */
  async verifySecurityModel(input: VerificationInput): Promise<ConceptualError[]> {
    const errors: ConceptualError[] = [];

    // Check for trust boundary violations
    if (input.architecture?.dependencies) {
      const trust = this.detectTrustViolations(input.architecture.dependencies);
      errors.push(...trust);
    }

    // Check for privilege escalation paths
    if (input.code?.files) {
      const privilege = this.detectPrivilegeEscalation(input.code.files);
      errors.push(...privilege);
    }

    return errors;
  }

  // --------------------------------------------------------------------------
  // ERROR MANAGEMENT
  // --------------------------------------------------------------------------

  /**
   * Get error by ID
   */
  getError(id: string): ConceptualError | null {
    return this.storage.getConceptualError(id);
  }

  /**
   * Query errors
   */
  queryErrors(options?: ConceptualErrorQueryOptions): ConceptualError[] {
    return this.storage.queryConceptualErrors(options);
  }

  /**
   * Update error status
   */
  updateErrorStatus(
    id: string,
    newStatus: ErrorStatus['current'],
    options?: {
      reason?: string;
      assignedTo?: string;
      workItemId?: string;
    },
  ): ConceptualError | null {
    const error = this.getError(id);
    if (!error) return null;

    const now = new Date().toISOString();

    const statusChange = {
      from: error.status.current,
      to: newStatus,
      changedAt: now,
      reason: options?.reason,
    };

    const updates: Partial<ConceptualError> = {
      status: {
        current: newStatus,
        history: [...error.status.history, statusChange],
        assignedTo: options?.assignedTo ?? error.status.assignedTo,
        workItemId: options?.workItemId ?? error.status.workItemId,
      },
    };

    if (newStatus === 'resolved' || newStatus === 'false_positive') {
      updates.resolvedAt = now;
    }

    return this.storage.updateConceptualError(id, updates);
  }

  /**
   * Resolve error with evidence
   */
  resolveError(
    id: string,
    resolution: {
      type: 'fixed' | 'wont_fix' | 'false_positive';
      description: string;
      evidence?: {
        type: string;
        description: string;
        artifactPath?: string;
      };
    },
    resolvedBy?: string,
  ): ConceptualError | null {
    const status: ErrorStatus['current'] =
      resolution.type === 'false_positive' ? 'false_positive' :
      resolution.type === 'wont_fix' ? 'wont_fix' : 'resolved';

    const updated = this.updateErrorStatus(id, status, {
      reason: resolution.description,
    });

    if (updated && resolution.evidence) {
      // Add resolution evidence
      const newEvidence: ConceptualEvidence = {
        id: randomUUID(),
        type: 'resolution',
        description: resolution.evidence.description,
        source: resolution.evidence.artifactPath ?? 'manual',
        confidence: 0.9,
        collectedAt: new Date().toISOString(),
      };

      this.storage.updateConceptualError(id, {
        evidence: [...updated.evidence, newEvidence],
      });
    }

    // Learn from resolution if enabled
    if (this.enableLearning && updated) {
      this.learnFromResolution(updated, resolution);
    }

    return this.getError(id);
  }

  // --------------------------------------------------------------------------
  // EXPLANATION
  // --------------------------------------------------------------------------

  /**
   * Explain a conceptual error in detail
   */
  async explain(error: ConceptualError): Promise<ErrorExplanation> {
    // Get subcategory details
    const subcategoryInfo = ERROR_SUBCATEGORIES.find(
      (s) => s.category === error.category && s.subcategory === error.subcategory,
    );

    // Build detailed explanation
    const explanation: ErrorExplanation = {
      error,
      categoryDescription: this.getCategoryDescription(error.category),
      subcategoryDescription: subcategoryInfo?.description ?? '',
      whyItMatters: this.explainWhyItMatters(error),
      howToFix: this.explainHowToFix(error),
      examples: subcategoryInfo?.examples ?? [],
      relatedPatterns: this.findRelatedPatterns(error),
      learningResources: this.findLearningResources(error),
    };

    return explanation;
  }

  // --------------------------------------------------------------------------
  // DETECTION HELPERS
  // --------------------------------------------------------------------------

  private detectContradictions(
    func: { name: string; file: string; startLine: number; endLine: number; body?: string },
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    if (!func.body) return errors;

    // Detect patterns like "if (x && !x)" or contradictory conditions
    const contradictionPatterns = [
      /if\s*\(\s*(\w+)\s*&&\s*!\1\s*\)/g,
      /if\s*\(\s*!\s*(\w+)\s*&&\s*\1\s*\)/g,
      /(\w+)\s*===?\s*true\s*&&\s*\1\s*===?\s*false/g,
    ];

    for (const pattern of contradictionPatterns) {
      const matches = func.body.matchAll(pattern);
      for (const match of matches) {
        errors.push(this.createError({
          category: 'logical',
          subcategory: 'contradiction',
          title: `Contradictory condition in ${func.name}`,
          description: `Found contradictory condition: ${match[0]}`,
          severity: 'error',
          location: {
            type: 'function',
            path: func.file,
            startLine: func.startLine,
            endLine: func.endLine,
            functionName: func.name,
          },
          evidence: [{
            id: randomUUID(),
            type: 'code_pattern',
            description: `Matched pattern: ${match[0]}`,
            source: func.file,
            confidence: 0.9,
            collectedAt: new Date().toISOString(),
          }],
          confidence: 0.9,
        }));
      }
    }

    return errors;
  }

  private detectIncompleteCases(
    file: { path: string; content: string; language: string },
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    // Detect switch without default
    const switchPattern = /switch\s*\([^)]+\)\s*\{[^}]*\}/g;
    const matches = file.content.matchAll(switchPattern);

    for (const match of matches) {
      if (!match[0].includes('default:')) {
        const lineNumber = file.content.slice(0, match.index).split('\n').length;
        errors.push(this.createError({
          category: 'logical',
          subcategory: 'incomplete_cases',
          title: 'Switch statement without default case',
          description: 'Switch statement may not handle all possible values',
          severity: 'warning',
          location: {
            type: 'file',
            path: file.path,
            startLine: lineNumber,
          },
          evidence: [{
            id: randomUUID(),
            type: 'code_pattern',
            description: 'Switch without default',
            source: file.path,
            confidence: 0.8,
            collectedAt: new Date().toISOString(),
          }],
          confidence: 0.8,
        }));
      }
    }

    return errors;
  }

  private detectCircularDefinitions(
    documentation: { readme?: string; apiDocs?: string },
  ): ConceptualError[] {
    // Simplified - would need more sophisticated analysis
    return [];
  }

  private detectDistributedFallacies(
    files: Array<{ path: string; content: string; language: string }>,
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    for (const file of files) {
      // Detect assuming network is reliable
      const networkPatterns = [
        /await\s+fetch\([^)]+\)(?!\s*\.catch)/g,
        /await\s+axios\.[a-z]+\([^)]+\)(?!\s*\.catch)/g,
        /\.then\([^)]+\)(?!\s*\.catch)/g,
      ];

      for (const pattern of networkPatterns) {
        const matches = file.content.matchAll(pattern);
        for (const match of matches) {
          const lineNumber = file.content.slice(0, match.index).split('\n').length;
          errors.push(this.createError({
            category: 'theoretical',
            subcategory: 'distributed_fallacy',
            title: 'Network call without error handling',
            description: 'Assuming network is reliable violates distributed systems principles',
            severity: 'warning',
            location: {
              type: 'file',
              path: file.path,
              startLine: lineNumber,
            },
            evidence: [{
              id: randomUUID(),
              type: 'code_pattern',
              description: 'Network call without catch/error handling',
              source: file.path,
              confidence: 0.7,
              collectedAt: new Date().toISOString(),
            }],
            confidence: 0.7,
          }));
        }
      }

      // Detect assuming zero latency
      const latencyPatterns = [
        /setTimeout\(\s*[^,]+,\s*0\s*\)/g,
        /for\s*\([^)]*await[^)]*\)/g, // Sequential awaits in loop
      ];

      for (const pattern of latencyPatterns) {
        const matches = file.content.matchAll(pattern);
        for (const match of matches) {
          const lineNumber = file.content.slice(0, match.index).split('\n').length;
          errors.push(this.createError({
            category: 'theoretical',
            subcategory: 'distributed_fallacy',
            title: 'Potential latency assumption',
            description: 'Code may assume zero or instant latency',
            severity: 'info',
            location: {
              type: 'file',
              path: file.path,
              startLine: lineNumber,
            },
            evidence: [{
              id: randomUUID(),
              type: 'code_pattern',
              description: match[0],
              source: file.path,
              confidence: 0.5,
              collectedAt: new Date().toISOString(),
            }],
            confidence: 0.5,
          }));
        }
      }
    }

    return errors;
  }

  private detectComplexityIssues(
    functions: Array<{ name: string; file: string; startLine: number; endLine: number; body?: string }>,
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    for (const func of functions) {
      if (!func.body) continue;

      // Detect nested loops (O(n²) or worse)
      const nestedLoopPattern = /(?:for|while)\s*\([^)]*\)\s*\{[^}]*(?:for|while)\s*\([^)]*\)\s*\{/g;
      if (nestedLoopPattern.test(func.body)) {
        errors.push(this.createError({
          category: 'theoretical',
          subcategory: 'algorithm_misuse',
          title: `Nested loops in ${func.name}`,
          description: 'Nested loops may indicate O(n²) or worse complexity',
          severity: 'warning',
          location: {
            type: 'function',
            path: func.file,
            startLine: func.startLine,
            endLine: func.endLine,
            functionName: func.name,
          },
          evidence: [{
            id: randomUUID(),
            type: 'code_pattern',
            description: 'Nested loop structure detected',
            source: func.file,
            confidence: 0.7,
            collectedAt: new Date().toISOString(),
          }],
          confidence: 0.7,
        }));
      }

      // Detect recursive calls without base case check
      const funcNameEscaped = func.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const recursivePattern = new RegExp(`function\\s+${funcNameEscaped}|${funcNameEscaped}\\s*\\(`, 'g');
      const matches = [...func.body.matchAll(recursivePattern)];
      if (matches.length > 1 && !func.body.includes('return') ) {
        errors.push(this.createError({
          category: 'theoretical',
          subcategory: 'algorithm_misuse',
          title: `Potential infinite recursion in ${func.name}`,
          description: 'Recursive function may lack proper base case',
          severity: 'error',
          location: {
            type: 'function',
            path: func.file,
            startLine: func.startLine,
            endLine: func.endLine,
            functionName: func.name,
          },
          evidence: [{
            id: randomUUID(),
            type: 'code_pattern',
            description: 'Self-referential function without clear return',
            source: func.file,
            confidence: 0.6,
            collectedAt: new Date().toISOString(),
          }],
          confidence: 0.6,
        }));
      }
    }

    return errors;
  }

  private detectConcurrencyIssues(
    files: Array<{ path: string; content: string; language: string }>,
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    for (const file of files) {
      // Detect shared mutable state patterns
      const sharedStatePatterns = [
        /let\s+\w+\s*=.*;\s*(?:.*\n)*?.*async/g,
        /var\s+\w+\s*=.*;\s*(?:.*\n)*?.*Promise/g,
      ];

      // Detect race condition patterns
      const racePatterns = [
        /if\s*\([^)]*\)\s*\{[^}]*await[^}]*\}[^}]*else\s*\{[^}]*await/g,
      ];

      for (const pattern of racePatterns) {
        const matches = file.content.matchAll(pattern);
        for (const match of matches) {
          const lineNumber = file.content.slice(0, match.index).split('\n').length;
          errors.push(this.createError({
            category: 'theoretical',
            subcategory: 'concurrency_issue',
            title: 'Potential race condition',
            description: 'Conditional async operations may have race conditions',
            severity: 'warning',
            location: {
              type: 'file',
              path: file.path,
              startLine: lineNumber,
            },
            evidence: [{
              id: randomUUID(),
              type: 'code_pattern',
              description: 'Conditional async with shared state',
              source: file.path,
              confidence: 0.6,
              collectedAt: new Date().toISOString(),
            }],
            confidence: 0.6,
          }));
        }
      }
    }

    return errors;
  }

  private detectAbstractionLeaks(
    modules: Array<{ name: string; files: string[]; publicApi?: string[] }>,
  ): ConceptualError[] {
    // Would need actual file content analysis
    return [];
  }

  private detectTemporalCoupling(
    functions: Array<{ name: string; file: string; startLine: number; endLine: number; body?: string }>,
  ): ConceptualError[] {
    // Would need more sophisticated analysis
    return [];
  }

  private detectDesignViolations(
    architecture: { dependencies?: Array<{ from: string; to: string; type: string }> },
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    if (!architecture.dependencies) return errors;

    // Detect circular dependencies
    const graph = new Map<string, Set<string>>();
    for (const dep of architecture.dependencies) {
      if (!graph.has(dep.from)) graph.set(dep.from, new Set());
      graph.get(dep.from)!.add(dep.to);
    }

    const cycles = this.findCycles(graph);
    for (const cycle of cycles) {
      errors.push(this.createError({
        category: 'design',
        subcategory: 'circular_dependency',
        title: 'Circular dependency detected',
        description: `Circular dependency: ${cycle.join(' -> ')}`,
        severity: 'warning',
        location: {
          type: 'module',
          path: cycle[0],
        },
        evidence: [{
          id: randomUUID(),
          type: 'dependency_analysis',
          description: `Cycle: ${cycle.join(' -> ')}`,
          source: 'architecture',
          confidence: 0.95,
          collectedAt: new Date().toISOString(),
        }],
        confidence: 0.95,
      }));
    }

    return errors;
  }

  private findCycles(graph: Map<string, Set<string>>): string[][] {
    const cycles: string[][] = [];
    const visited = new Set<string>();
    const recStack = new Set<string>();
    const path: string[] = [];

    const dfs = (node: string): void => {
      visited.add(node);
      recStack.add(node);
      path.push(node);

      const neighbors = graph.get(node) ?? new Set();
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          dfs(neighbor);
        } else if (recStack.has(neighbor)) {
          const cycleStart = path.indexOf(neighbor);
          cycles.push([...path.slice(cycleStart), neighbor]);
        }
      }

      path.pop();
      recStack.delete(node);
    };

    for (const node of graph.keys()) {
      if (!visited.has(node)) {
        dfs(node);
      }
    }

    return cycles;
  }

  private detectUndefinedTerms(
    terms: Array<{ term: string; definition: string }>,
    files: Array<{ path: string; content: string; language: string }>,
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];
    const definedTerms = new Set(terms.map((t) => t.term.toLowerCase()));

    // Look for potential domain terms that aren't defined
    for (const file of files) {
      // Extract PascalCase and camelCase identifiers
      const identifiers = file.content.match(/\b[A-Z][a-z]+(?:[A-Z][a-z]+)+\b/g) ?? [];

      for (const identifier of identifiers) {
        const normalized = identifier.toLowerCase();
        const words = identifier.replace(/([A-Z])/g, ' $1').trim().toLowerCase().split(' ');

        // Check if any part seems like a domain term but isn't defined
        for (const word of words) {
          if (
            word.length > 4 &&
            !definedTerms.has(word) &&
            !this.isCommonProgrammingTerm(word)
          ) {
            // This is a heuristic - would need refinement
            // Only flag if term appears multiple times
            const count = (file.content.match(new RegExp(word, 'gi')) ?? []).length;
            if (count >= 3) {
              errors.push(this.createError({
                category: 'domain',
                subcategory: 'undefined_term',
                title: `Potentially undefined domain term: ${word}`,
                description: `Term "${word}" appears ${count} times but is not in the ubiquitous language`,
                severity: 'info',
                location: {
                  type: 'file',
                  path: file.path,
                },
                evidence: [{
                  id: randomUUID(),
                  type: 'term_analysis',
                  description: `Found ${count} occurrences`,
                  source: file.path,
                  confidence: 0.5,
                  collectedAt: new Date().toISOString(),
                }],
                confidence: 0.5,
              }));
            }
          }
        }
      }
    }

    return errors;
  }

  private isCommonProgrammingTerm(word: string): boolean {
    const common = new Set([
      'string', 'number', 'boolean', 'object', 'array', 'function',
      'async', 'await', 'promise', 'callback', 'handler', 'listener',
      'component', 'service', 'controller', 'model', 'view', 'router',
      'config', 'options', 'params', 'props', 'state', 'context',
      'error', 'result', 'response', 'request', 'data', 'item',
      'index', 'count', 'length', 'value', 'name', 'type',
    ]);
    return common.has(word.toLowerCase());
  }

  private detectRuleViolations(
    rules: Array<{ name: string; description: string; constraints?: string[] }>,
    functions: Array<{ name: string; file: string; startLine: number; endLine: number; body?: string }>,
  ): ConceptualError[] {
    // Would need domain-specific rule checking
    return [];
  }

  private detectBoundaryViolations(
    contexts: BoundedContext[],
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    for (const context of contexts) {
      // Check for overlapping paths between contexts
      for (const otherContext of contexts) {
        if (context.id === otherContext.id) continue;

        const overlap = context.boundaries.includedPaths.filter((p) =>
          otherContext.boundaries.includedPaths.some((op) =>
            p.startsWith(op) || op.startsWith(p),
          ),
        );

        if (overlap.length > 0) {
          errors.push(this.createError({
            category: 'domain',
            subcategory: 'boundary_violation',
            title: `Overlapping context boundaries`,
            description: `Contexts "${context.name}" and "${otherContext.name}" have overlapping paths`,
            severity: 'warning',
            location: {
              type: 'module',
              path: overlap[0],
            },
            evidence: [{
              id: randomUUID(),
              type: 'boundary_analysis',
              description: `Overlapping paths: ${overlap.join(', ')}`,
              source: 'context_boundaries',
              confidence: 0.9,
              collectedAt: new Date().toISOString(),
            }],
            confidence: 0.9,
          }));
        }
      }
    }

    return errors;
  }

  private detectDocCodeDrift(
    documentation: { readme?: string; apiDocs?: string; comments?: Array<{ file: string; line: number; content: string }> },
    code: { files: Array<{ path: string; content: string; language: string }> },
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    // Check for outdated function references in docs
    if (documentation.readme) {
      const codeReferences = documentation.readme.match(/`([a-zA-Z_][a-zA-Z0-9_]*)\(/g) ?? [];

      for (const ref of codeReferences) {
        const funcName = ref.slice(1, -1); // Remove backtick and paren
        const exists = code.files.some((f) =>
          f.content.includes(`function ${funcName}`) ||
          f.content.includes(`const ${funcName} =`) ||
          f.content.includes(`${funcName}:`),
        );

        if (!exists) {
          errors.push(this.createError({
            category: 'consistency',
            subcategory: 'doc_code_drift',
            title: `Documentation references non-existent function: ${funcName}`,
            description: `README references function "${funcName}" which may not exist`,
            severity: 'warning',
            location: {
              type: 'file',
              path: 'README.md',
            },
            evidence: [{
              id: randomUUID(),
              type: 'doc_analysis',
              description: `Reference: ${ref}`,
              source: 'README.md',
              confidence: 0.7,
              collectedAt: new Date().toISOString(),
            }],
            confidence: 0.7,
          }));
        }
      }
    }

    return errors;
  }

  private detectDecisionDrift(
    decisions: Array<{ id: string; title: string; decision: string; rationale: string }>,
    code: { files: Array<{ path: string; content: string; language: string }> },
  ): ConceptualError[] {
    // Would need semantic analysis of decisions vs implementation
    return [];
  }

  private detectTrustViolations(
    dependencies: Array<{ from: string; to: string; type: string }>,
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    // Detect potential trust boundary violations
    // (e.g., internal module directly accessing external API)
    for (const dep of dependencies) {
      if (dep.type === 'external' && !dep.from.includes('api') && !dep.from.includes('gateway')) {
        errors.push(this.createError({
          category: 'security_model',
          subcategory: 'trust_boundary_violation',
          title: 'Direct external access bypassing gateway',
          description: `"${dep.from}" directly accesses external resource "${dep.to}" without going through API gateway`,
          severity: 'warning',
          location: {
            type: 'module',
            path: dep.from,
          },
          evidence: [{
            id: randomUUID(),
            type: 'dependency_analysis',
            description: `Direct dependency: ${dep.from} -> ${dep.to}`,
            source: 'architecture',
            confidence: 0.7,
            collectedAt: new Date().toISOString(),
          }],
          confidence: 0.7,
        }));
      }
    }

    return errors;
  }

  private detectPrivilegeEscalation(
    files: Array<{ path: string; content: string; language: string }>,
  ): ConceptualError[] {
    const errors: ConceptualError[] = [];

    for (const file of files) {
      // Detect potential privilege escalation patterns
      const patterns = [
        /setuid|setgid|sudo|admin|root/gi,
        /process\.env\.(?:ADMIN|ROOT|SECRET)/g,
        /role\s*[=:]\s*['"]admin['"]/gi,
      ];

      for (const pattern of patterns) {
        const matches = file.content.matchAll(pattern);
        for (const match of matches) {
          const lineNumber = file.content.slice(0, match.index).split('\n').length;
          errors.push(this.createError({
            category: 'security_model',
            subcategory: 'privilege_escalation',
            title: 'Potential privilege escalation',
            description: `Found privilege-related pattern: ${match[0]}`,
            severity: 'warning',
            location: {
              type: 'file',
              path: file.path,
              startLine: lineNumber,
            },
            evidence: [{
              id: randomUUID(),
              type: 'code_pattern',
              description: `Pattern: ${match[0]}`,
              source: file.path,
              confidence: 0.6,
              collectedAt: new Date().toISOString(),
            }],
            confidence: 0.6,
          }));
        }
      }
    }

    return errors;
  }

  // --------------------------------------------------------------------------
  // REPORT BUILDING
  // --------------------------------------------------------------------------

  private buildReport(
    errors: ConceptualError[],
    startedAt: string,
    completedAt: string,
  ): VerificationReport {
    // Build summary
    const summary: VerificationSummary = {
      totalErrors: errors.length,
      byCategory: this.groupByCategory(errors),
      bySeverity: this.groupBySeverity(errors),
      criticalCount: errors.filter((e) => e.severity === 'critical').length,
      highCount: errors.filter((e) => e.severity === 'error').length,
      mediumCount: errors.filter((e) => e.severity === 'warning').length,
      lowCount: errors.filter((e) => e.severity === 'info').length,
    };

    // Calculate confidence
    const avgConfidence = errors.length > 0
      ? errors.reduce((sum, e) => sum + e.confidence.score, 0) / errors.length
      : 1;

    // Generate recommendations
    const recommendations = this.generateRecommendations(errors);

    return {
      id: randomUUID(),
      scope: 'full',
      startedAt,
      completedAt,
      summary,
      errors,
      recommendations,
      confidence: {
        score: avgConfidence,
        level: scoreToLevel(avgConfidence),
        factors: [],
        needsResearch: avgConfidence < 0.7,
      },
    };
  }

  private groupByCategory(errors: ConceptualError[]): Record<string, number> {
    const result: Record<string, number> = {};
    for (const error of errors) {
      result[error.category] = (result[error.category] ?? 0) + 1;
    }
    return result;
  }

  private groupBySeverity(errors: ConceptualError[]): Record<string, number> {
    const result: Record<string, number> = {};
    for (const error of errors) {
      result[error.severity] = (result[error.severity] ?? 0) + 1;
    }
    return result;
  }

  private generateRecommendations(errors: ConceptualError[]): VerificationRecommendation[] {
    const recommendations: VerificationRecommendation[] = [];

    // Group by category and identify patterns
    const byCategory = new Map<string, ConceptualError[]>();
    for (const error of errors) {
      if (!byCategory.has(error.category)) {
        byCategory.set(error.category, []);
      }
      byCategory.get(error.category)!.push(error);
    }

    // Generate category-specific recommendations
    for (const [category, categoryErrors] of byCategory) {
      if (categoryErrors.length >= 3) {
        recommendations.push({
          priority: 'high',
          category,
          description: `Multiple ${category} errors detected (${categoryErrors.length})`,
          actions: [
            `Review ${category} patterns across the codebase`,
            `Consider establishing guidelines for ${category} issues`,
          ],
          estimatedEffort: 'medium',
        });
      }
    }

    // Critical errors get immediate attention
    const critical = errors.filter((e) => e.severity === 'critical');
    if (critical.length > 0) {
      recommendations.unshift({
        priority: 'critical',
        category: 'all',
        description: `${critical.length} critical errors require immediate attention`,
        actions: critical.map((e) => `Fix: ${e.title}`),
        estimatedEffort: 'high',
      });
    }

    return recommendations;
  }

  // --------------------------------------------------------------------------
  // HELPER METHODS
  // --------------------------------------------------------------------------

  private createError(params: {
    category: ConceptualErrorCategory;
    subcategory: string;
    title: string;
    description: string;
    severity: ErrorSeverity;
    location: Partial<ErrorLocation>;
    evidence: ConceptualEvidence[];
    confidence: number;
  }): ConceptualError {
    const now = new Date().toISOString();

    return {
      id: randomUUID(),
      version: 1,
      category: params.category,
      subcategory: params.subcategory,
      title: params.title,
      description: params.description,
      severity: params.severity,
      location: {
        type: params.location.type ?? 'file',
        path: params.location.path ?? 'unknown',
        startLine: params.location.startLine,
        endLine: params.location.endLine,
        functionName: params.location.functionName,
        moduleName: params.location.moduleName,
        contextName: params.location.contextName,
      },
      scope: {
        affectedFiles: params.location.path ? [params.location.path] : [],
        affectedFunctions: params.location.functionName ? [params.location.functionName] : [],
        affectedModules: params.location.moduleName ? [params.location.moduleName] : [],
        affectedContexts: params.location.contextName ? [params.location.contextName] : [],
      },
      evidence: params.evidence,
      rootCause: undefined,
      implications: [],
      suggestedFixes: [],
      detectionMethod: {
        type: 'pattern_matching',
        ruleId: undefined,
        toolName: 'ConceptualVerifier',
        confidence: params.confidence,
      },
      relatedErrors: [],
      status: {
        current: 'open',
        history: [{
          from: undefined,
          to: 'open',
          changedAt: now,
        }],
      },
      confidence: {
        score: params.confidence,
        level: scoreToLevel(params.confidence),
        factors: [],
        needsResearch: params.confidence < 0.7,
      },
      provenance: createSystemProvenance('conceptual_verification'),
      detectedAt: now,
      createdAt: now,
      updatedAt: now,
    };
  }

  private getCategoryDescription(category: ConceptualErrorCategory): string {
    const descriptions: Record<ConceptualErrorCategory, string> = {
      logical: 'Errors in reasoning, contradictions, or incomplete logic',
      theoretical: 'Violations of computer science principles or algorithms',
      design: 'Architectural and design pattern issues',
      domain: 'Business logic and domain model problems',
      consistency: 'Mismatches between documentation, code, and decisions',
      security_model: 'Security architecture and trust boundary issues',
      performance_model: 'Performance assumptions and bottlenecks',
      data_model: 'Data structure and modeling problems',
      integration: 'Interface and integration issues',
      temporal: 'Time-related logic and sequencing problems',
    };
    return descriptions[category] ?? 'Unknown category';
  }

  private explainWhyItMatters(error: ConceptualError): string {
    const mattersMap: Record<ConceptualErrorCategory, string> = {
      logical: 'Logical errors can cause unpredictable behavior and are hard to debug',
      theoretical: 'Theoretical errors often manifest as performance issues or edge case failures at scale',
      design: 'Design issues accumulate technical debt and make the system harder to maintain',
      domain: 'Domain errors can cause incorrect business outcomes and compliance issues',
      consistency: 'Inconsistencies confuse developers and lead to maintenance errors',
      security_model: 'Security model errors can lead to vulnerabilities and data breaches',
      performance_model: 'Performance model errors cause scalability problems',
      data_model: 'Data model errors cause data corruption and loss',
      integration: 'Integration errors cause system failures at boundaries',
      temporal: 'Temporal errors cause race conditions and intermittent failures',
    };
    return mattersMap[error.category] ?? 'This error type can impact system quality';
  }

  private explainHowToFix(error: ConceptualError): string[] {
    const fixes: string[] = [];

    // Add suggested fixes from error
    for (const fix of error.suggestedFixes) {
      fixes.push(fix.description);
    }

    // Add generic guidance
    switch (error.category) {
      case 'logical':
        fixes.push('Review conditions for completeness');
        fixes.push('Add exhaustive case handling');
        break;
      case 'theoretical':
        fixes.push('Review algorithm complexity');
        fixes.push('Add proper error handling for distributed scenarios');
        break;
      case 'design':
        fixes.push('Refactor to reduce coupling');
        fixes.push('Apply appropriate design patterns');
        break;
      case 'domain':
        fixes.push('Consult domain experts');
        fixes.push('Update ubiquitous language');
        break;
      case 'consistency':
        fixes.push('Update documentation to match implementation');
        fixes.push('Review and update ADRs');
        break;
      case 'security_model':
        fixes.push('Implement proper trust boundaries');
        fixes.push('Add security review process');
        break;
    }

    return fixes;
  }

  private findRelatedPatterns(error: ConceptualError): string[] {
    const patterns: string[] = [];

    // Map categories to common patterns
    const patternMap: Record<string, string[]> = {
      logical: ['Guard Clause', 'Null Object', 'State Machine'],
      theoretical: ['Circuit Breaker', 'Retry with Backoff', 'Bulkhead'],
      design: ['Facade', 'Adapter', 'Dependency Injection'],
      domain: ['Aggregate', 'Value Object', 'Domain Event'],
      consistency: ['Documentation as Code', 'Living Documentation'],
      security_model: ['Zero Trust', 'Defense in Depth', 'Least Privilege'],
    };

    patterns.push(...(patternMap[error.category] ?? []));
    return patterns;
  }

  private findLearningResources(error: ConceptualError): string[] {
    const resources: string[] = [];

    // Map categories to learning resources
    const resourceMap: Record<string, string[]> = {
      logical: ['Clean Code by Robert Martin', 'Code Complete by Steve McConnell'],
      theoretical: ['Designing Data-Intensive Applications', 'Release It!'],
      design: ['Design Patterns (GoF)', 'Patterns of Enterprise Application Architecture'],
      domain: ['Domain-Driven Design by Eric Evans', 'Implementing DDD by Vaughn Vernon'],
      consistency: ['Docs as Code', 'Architecture Decision Records'],
      security_model: ['OWASP Guidelines', 'The Web Application Hacker\'s Handbook'],
    };

    resources.push(...(resourceMap[error.category] ?? []));
    return resources;
  }

  private learnFromResolution(
    error: ConceptualError,
    resolution: { type: string; description: string },
  ): void {
    // Store resolution patterns for future detection improvement
    // This would be expanded with actual ML/pattern learning
    console.log(`Learning from resolution of ${error.category}/${error.subcategory}: ${resolution.type}`);
  }
}
