/**
 * @fileoverview Prioritization Engine Implementation
 *
 * Provides intelligent, transparent work prioritization based on:
 * - Strategic alignment with project vision
 * - User impact assessment
 * - Risk reduction value
 * - Dependency unblock potential
 * - Effort/value ratio
 * - Time decay (urgency)
 * - Momentum (current focus)
 * - External pressure (deadlines, stakeholders)
 *
 * Design principles:
 * - Every priority decision is explainable
 * - Rules are configurable and composable
 * - Simulations allow "what-if" analysis
 * - Learning from outcomes improves future prioritization
 */

import { randomUUID } from 'crypto';
import type {
  PrioritizationConfig,
  PriorityWeights,
  PriorityThresholds,
  DecayConfig,
  PrioritizationRule,
  RuleCondition,
  RuleEffect,
  PriorityComputeContext,
  DependencyGraph,
  PriorityComputation,
  AppliedRule,
  PriorityAdjustment,
  PriorityExplanation,
  ExplainedFactor,
  PriorityComparison,
  PrioritySuggestion,
  RankedWork,
  RankOptions,
  FocusRecommendation,
  PrioritySimulation,
  PriorityChange,
  FactorCalculator,
  FactorResult,
  PrioritizationEngine as IPrioritizationEngine,
  DEFAULT_PRIORITIZATION_CONFIG,
  BUILT_IN_RULES,
  calculateStrategicAlignment,
  calculateUserImpact,
  calculateRiskReduction,
  calculateDependencyUnblock,
  calculateEffortValue,
  calculateTimeDecay,
  calculateMomentum,
  calculateExternalPressure,
} from './prioritization.js';
import type {
  WorkPrimitive,
  ComputedPriority,
  PriorityLevel,
  PriorityFactor,
} from './work_primitives.js';
import type { ProjectVision, BoundedContext, ConfidenceAssessment } from './types.js';
import type { StrategicStorage } from './storage.js';
import { scoreToLevel, createSystemProvenance } from './strategic_context.js';

// ============================================================================
// PRIORITY ENGINE IMPLEMENTATION
// ============================================================================

export interface PrioritizationEngineOptions {
  /** Custom configuration (overrides defaults) */
  config?: Partial<PrioritizationConfig>;
  /** Enable caching of computed priorities */
  enableCaching?: boolean;
  /** Cache TTL in milliseconds */
  cacheTTL?: number;
  /** Custom factor calculators */
  customCalculators?: Record<string, FactorCalculator>;
}

/**
 * Prioritization Engine
 *
 * Computes transparent, explainable priorities for work items
 * based on multiple weighted factors and configurable rules.
 */
export class PrioritizationEngine implements IPrioritizationEngine {
  private readonly storage: StrategicStorage;
  private readonly config: PrioritizationConfig;
  private readonly calculators: Map<string, FactorCalculator>;
  private readonly cache: Map<string, { priority: ComputedPriority; expiresAt: number }>;
  private readonly cacheTTL: number;

  constructor(
    storage: StrategicStorage,
    options: PrioritizationEngineOptions = {},
  ) {
    this.storage = storage;
    this.config = {
      ...DEFAULT_PRIORITIZATION_CONFIG,
      ...options.config,
    };
    this.cache = new Map();
    this.cacheTTL = options.cacheTTL ?? 5 * 60 * 1000; // 5 minutes default

    // Register factor calculators
    this.calculators = new Map();
    this.registerDefaultCalculators();
    if (options.customCalculators) {
      for (const [name, calc] of Object.entries(options.customCalculators)) {
        this.calculators.set(name, calc);
      }
    }
  }

  // --------------------------------------------------------------------------
  // PRIORITY COMPUTATION
  // --------------------------------------------------------------------------

  /**
   * Compute priority for a single work item
   */
  async computePriority(
    work: WorkPrimitive,
    context?: Partial<PriorityComputeContext>,
  ): Promise<PriorityComputation> {
    const now = new Date().toISOString();

    // Check cache
    const cached = this.cache.get(work.id);
    if (cached && cached.expiresAt > Date.now()) {
      return {
        workId: work.id,
        priority: cached.priority,
        factors: cached.priority.factors,
        appliedRules: [],
        adjustments: [],
        computedAt: cached.priority.computedAt,
        validUntil: new Date(cached.expiresAt).toISOString(),
        confidence: { score: 0.8, level: 'established', factors: [], needsResearch: false },
      };
    }

    // Build full context
    const fullContext = await this.buildContext(work, context);

    // Calculate each factor
    const factorResults: FactorResult[] = [];
    for (const [factorName, weight] of Object.entries(this.config.weights)) {
      const calculator = this.calculators.get(factorName);
      if (calculator) {
        const result = await calculator(fullContext);
        factorResults.push({
          ...result,
          factor: factorName,
          weight,
        });
      }
    }

    // Compute base score
    let score = 0;
    const factors: PriorityFactor[] = [];
    for (const result of factorResults) {
      const contribution = result.score * result.weight;
      score += contribution;
      factors.push({
        name: result.factor,
        weight: result.weight,
        score: result.score,
        contribution,
        description: result.explanation,
      });
    }

    // Apply rules
    const { appliedRules, adjustments, adjustedScore } = this.applyRules(work, score, fullContext);
    score = adjustedScore;

    // Apply manual override if present
    if (work.priority.override) {
      score = work.priority.override.score;
      adjustments.push({
        reason: `Manual override: ${work.priority.override.reason}`,
        delta: work.priority.override.score - adjustedScore,
        source: 'override',
        appliedAt: work.priority.override.overriddenAt,
      });
    }

    // Clamp to [0, 1]
    score = Math.max(0, Math.min(1, score));

    // Determine level
    const level = this.scoreToLevel(score);

    // Calculate confidence based on factor confidences
    const avgFactorConfidence = factorResults.length > 0
      ? factorResults.reduce((sum, f) => sum + f.confidence, 0) / factorResults.length
      : 0.5;

    const priority: ComputedPriority = {
      score,
      level,
      factors,
      override: work.priority.override,
      computedAt: now,
    };

    // Update cache
    this.cache.set(work.id, {
      priority,
      expiresAt: Date.now() + this.cacheTTL,
    });

    return {
      workId: work.id,
      priority,
      factors: factorResults,
      appliedRules,
      adjustments,
      computedAt: now,
      validUntil: new Date(Date.now() + this.cacheTTL).toISOString(),
      confidence: {
        score: avgFactorConfidence,
        level: scoreToLevel(avgFactorConfidence),
        factors: [],
        needsResearch: avgFactorConfidence < 0.5,
      },
    };
  }

  /**
   * Batch compute priorities for multiple work items
   */
  async computeBatch(
    items: WorkPrimitive[],
    context?: Partial<PriorityComputeContext>,
  ): Promise<PriorityComputation[]> {
    // Build shared context once
    const sharedContext = context ?? {};

    // Compute in parallel
    return Promise.all(
      items.map((item) => this.computePriority(item, sharedContext)),
    );
  }

  /**
   * Rank work items by priority
   */
  async rank(
    items: WorkPrimitive[],
    options: RankOptions = {},
  ): Promise<RankedWork[]> {
    // Compute priorities
    const computations = await this.computeBatch(items);

    // Build ranked list
    let ranked: RankedWork[] = computations.map((comp, index) => ({
      work: items[index],
      computation: comp,
      rank: 0, // Will be set after sorting
      comparedTo: [],
    }));

    // Filter by threshold
    if (options.minScore !== undefined) {
      ranked = ranked.filter((r) => r.computation.priority.score >= options.minScore!);
    }

    // Sort by score (descending)
    ranked.sort((a, b) => b.computation.priority.score - a.computation.priority.score);

    // Assign ranks
    ranked.forEach((item, index) => {
      item.rank = index + 1;
    });

    // Limit results
    if (options.limit !== undefined) {
      ranked = ranked.slice(0, options.limit);
    }

    return ranked;
  }

  // --------------------------------------------------------------------------
  // EXPLANATIONS
  // --------------------------------------------------------------------------

  /**
   * Explain priority computation for a work item
   */
  async explain(work: WorkPrimitive): Promise<PriorityExplanation> {
    const computation = await this.computePriority(work);

    // Build explained factors
    const factors: ExplainedFactor[] = computation.factors.map((f) => ({
      factor: f.factor,
      score: f.score,
      weight: f.weight,
      contribution: f.score * f.weight,
      explanation: f.explanation,
      improvementHints: this.getImprovementHints(f.factor, f.score),
    }));

    // Sort by contribution
    factors.sort((a, b) => b.contribution - a.contribution);

    // Generate narrative
    const narrative = this.generateNarrative(work, factors, computation);

    // Generate suggestions
    const suggestions = this.generateSuggestions(work, factors);

    return {
      workId: work.id,
      score: computation.priority.score,
      level: computation.priority.level,
      factors,
      appliedRules: computation.appliedRules,
      adjustments: computation.adjustments,
      narrative,
      suggestions,
      computedAt: computation.computedAt,
    };
  }

  /**
   * Compare priorities of two work items
   */
  async compare(
    workA: WorkPrimitive,
    workB: WorkPrimitive,
  ): Promise<PriorityComparison> {
    const [compA, compB] = await Promise.all([
      this.computePriority(workA),
      this.computePriority(workB),
    ]);

    const difference = compA.priority.score - compB.priority.score;

    // Identify key differences
    const factorDiffs: Array<{
      factor: string;
      scoreA: number;
      scoreB: number;
      diff: number;
      significantReason?: string;
    }> = [];

    for (const factorA of compA.factors) {
      const factorB = compB.factors.find((f) => f.factor === factorA.factor);
      if (factorB) {
        const diff = factorA.score - factorB.score;
        if (Math.abs(diff) > 0.1) {
          factorDiffs.push({
            factor: factorA.factor,
            scoreA: factorA.score,
            scoreB: factorB.score,
            diff,
            significantReason: Math.abs(diff) > 0.3
              ? `Significant difference in ${factorA.factor}`
              : undefined,
          });
        }
      }
    }

    // Sort by absolute difference
    factorDiffs.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff));

    // Generate recommendation
    const winner = difference > 0 ? workA : difference < 0 ? workB : null;
    const recommendation = winner
      ? `Prioritize "${winner.title}" due to higher ${factorDiffs[0]?.factor ?? 'overall score'}`
      : 'Both items have similar priority';

    return {
      itemA: {
        id: workA.id,
        title: workA.title,
        score: compA.priority.score,
        level: compA.priority.level,
      },
      itemB: {
        id: workB.id,
        title: workB.title,
        score: compB.priority.score,
        level: compB.priority.level,
      },
      difference,
      winner: winner ? winner.id : undefined,
      keyDifferences: factorDiffs,
      recommendation,
    };
  }

  // --------------------------------------------------------------------------
  // FOCUS RECOMMENDATIONS
  // --------------------------------------------------------------------------

  /**
   * Get focus recommendation for next work to tackle
   */
  async getFocusRecommendation(
    availableWork: WorkPrimitive[],
    options?: {
      maxRecommendations?: number;
      excludeBlocked?: boolean;
      preferredTypes?: string[];
    },
  ): Promise<FocusRecommendation> {
    // Filter available work
    let candidates = [...availableWork];
    if (options?.excludeBlocked !== false) {
      candidates = candidates.filter((w) => w.status !== 'blocked');
    }
    if (options?.preferredTypes?.length) {
      const preferred = candidates.filter((w) =>
        options.preferredTypes!.includes(w.type),
      );
      if (preferred.length > 0) {
        candidates = preferred;
      }
    }

    // Rank candidates
    const ranked = await this.rank(candidates, {
      limit: options?.maxRecommendations ?? 3,
    });

    if (ranked.length === 0) {
      return {
        recommendations: [],
        reasoning: 'No work items available',
        confidence: { score: 0, level: 'unknown', factors: [], needsResearch: true },
      };
    }

    // Build recommendations
    const recommendations = ranked.map((r, index) => {
      const explanation = this.computeRecommendationReason(r, index);
      return {
        work: r.work,
        rank: r.rank,
        score: r.computation.priority.score,
        reason: explanation,
        unblocks: this.findUnblocked(r.work, availableWork),
      };
    });

    // Overall reasoning
    const topItem = recommendations[0];
    const reasoning = this.buildFocusReasoning(topItem, recommendations);

    return {
      recommendations,
      reasoning,
      confidence: {
        score: topItem.score > 0.7 ? 0.8 : 0.6,
        level: topItem.score > 0.7 ? 'established' : 'probable',
        factors: [],
        needsResearch: false,
      },
    };
  }

  // --------------------------------------------------------------------------
  // SIMULATION
  // --------------------------------------------------------------------------

  /**
   * Simulate priority changes without persisting
   */
  async simulate(
    changes: Array<{
      workId: string;
      changes: Partial<WorkPrimitive>;
    }>,
  ): Promise<PrioritySimulation> {
    const results: PriorityChange[] = [];

    for (const change of changes) {
      const original = this.storage.getWorkPrimitive(change.workId);
      if (!original) continue;

      // Compute original priority
      const originalComp = await this.computePriority(original);

      // Apply simulated changes
      const modified: WorkPrimitive = { ...original, ...change.changes };

      // Clear cache to force recomputation
      this.cache.delete(change.workId);

      // Compute new priority
      const newComp = await this.computePriority(modified);

      const delta = newComp.priority.score - originalComp.priority.score;

      results.push({
        workId: change.workId,
        originalScore: originalComp.priority.score,
        newScore: newComp.priority.score,
        delta,
        levelChange:
          originalComp.priority.level !== newComp.priority.level
            ? {
                from: originalComp.priority.level,
                to: newComp.priority.level,
              }
            : undefined,
        significantFactors: this.identifySignificantChanges(
          originalComp.factors,
          newComp.factors,
        ),
      });

      // Restore cache with original
      this.cache.set(change.workId, {
        priority: originalComp.priority,
        expiresAt: Date.now() + this.cacheTTL,
      });
    }

    // Calculate impact summary
    const totalDelta = results.reduce((sum, r) => sum + r.delta, 0);
    const avgDelta = results.length > 0 ? totalDelta / results.length : 0;
    const maxIncrease = Math.max(...results.map((r) => r.delta));
    const maxDecrease = Math.min(...results.map((r) => r.delta));

    return {
      changes: results,
      summary: {
        itemsAffected: results.length,
        averageDelta: avgDelta,
        maxIncrease,
        maxDecrease,
        recommendations: this.generateSimulationRecommendations(results),
      },
      simulatedAt: new Date().toISOString(),
    };
  }

  // --------------------------------------------------------------------------
  // CONFIGURATION
  // --------------------------------------------------------------------------

  /**
   * Update prioritization configuration
   */
  updateConfig(updates: Partial<PrioritizationConfig>): void {
    Object.assign(this.config, updates);
    // Clear cache when config changes
    this.cache.clear();
    // Persist to storage
    this.storage.savePrioritizationConfig(this.config);
  }

  /**
   * Get current configuration
   */
  getConfig(): PrioritizationConfig {
    return { ...this.config };
  }

  /**
   * Add custom prioritization rule
   */
  addRule(rule: PrioritizationRule): void {
    this.config.rules.push(rule);
    this.cache.clear();
  }

  /**
   * Remove rule by ID
   */
  removeRule(ruleId: string): boolean {
    const index = this.config.rules.findIndex((r) => r.id === ruleId);
    if (index >= 0) {
      this.config.rules.splice(index, 1);
      this.cache.clear();
      return true;
    }
    return false;
  }

  /**
   * Register custom factor calculator
   */
  registerCalculator(name: string, calculator: FactorCalculator): void {
    this.calculators.set(name, calculator);
    this.cache.clear();
  }

  // --------------------------------------------------------------------------
  // PRIVATE HELPERS
  // --------------------------------------------------------------------------

  private registerDefaultCalculators(): void {
    this.calculators.set('strategicAlignment', calculateStrategicAlignment);
    this.calculators.set('userImpact', calculateUserImpact);
    this.calculators.set('riskReduction', calculateRiskReduction);
    this.calculators.set('dependencyUnblock', calculateDependencyUnblock);
    this.calculators.set('effortValue', calculateEffortValue);
    this.calculators.set('timeDecay', calculateTimeDecay);
    this.calculators.set('momentum', calculateMomentum);
    this.calculators.set('externalPressure', calculateExternalPressure);
  }

  private async buildContext(
    work: WorkPrimitive,
    partial?: Partial<PriorityComputeContext>,
  ): Promise<PriorityComputeContext> {
    const vision = this.storage.getVision();
    const contexts = this.storage.getAllBoundedContexts();

    // Build dependency graph
    const allWork = this.storage.queryWorkPrimitives({});
    const dependencyGraph = this.buildDependencyGraph(allWork);

    return {
      work,
      vision: partial?.vision ?? vision ?? undefined,
      boundedContexts: partial?.boundedContexts ?? contexts,
      dependencyGraph: partial?.dependencyGraph ?? dependencyGraph,
      currentTime: partial?.currentTime ?? new Date().toISOString(),
      activeWorkIds: partial?.activeWorkIds ?? allWork
        .filter((w) => w.status === 'in_progress')
        .map((w) => w.id),
      recentCompletions: partial?.recentCompletions ?? allWork
        .filter((w) => w.status === 'completed')
        .slice(0, 10)
        .map((w) => w.id),
      config: this.config,
    };
  }

  private buildDependencyGraph(items: WorkPrimitive[]): DependencyGraph {
    const nodes = new Map<string, { work: WorkPrimitive; inDegree: number; outDegree: number }>();
    const edges: Array<{ from: string; to: string; isBlocking: boolean }> = [];

    // Initialize nodes
    for (const item of items) {
      nodes.set(item.id, { work: item, inDegree: 0, outDegree: item.dependencies.length });
    }

    // Build edges and update in-degrees
    for (const item of items) {
      for (const dep of item.dependencies) {
        edges.push({
          from: item.id,
          to: dep.dependsOnId,
          isBlocking: dep.isBlocking,
        });
        const targetNode = nodes.get(dep.dependsOnId);
        if (targetNode) {
          targetNode.inDegree++;
        }
      }
    }

    return {
      nodes: Object.fromEntries(nodes),
      edges,
      topologicalOrder: this.topologicalSort(items),
    };
  }

  private topologicalSort(items: WorkPrimitive[]): string[] {
    const result: string[] = [];
    const visited = new Set<string>();
    const inProgress = new Set<string>();
    const itemMap = new Map(items.map((i) => [i.id, i]));

    const visit = (id: string): boolean => {
      if (inProgress.has(id)) return false; // Cycle detected
      if (visited.has(id)) return true;

      inProgress.add(id);
      const item = itemMap.get(id);
      if (item) {
        for (const dep of item.dependencies) {
          if (!visit(dep.dependsOnId)) return false;
        }
      }
      inProgress.delete(id);
      visited.add(id);
      result.push(id);
      return true;
    };

    for (const item of items) {
      visit(item.id);
    }

    return result.reverse();
  }

  private applyRules(
    work: WorkPrimitive,
    baseScore: number,
    context: PriorityComputeContext,
  ): {
    appliedRules: AppliedRule[];
    adjustments: PriorityAdjustment[];
    adjustedScore: number;
  } {
    const appliedRules: AppliedRule[] = [];
    const adjustments: PriorityAdjustment[] = [];
    let adjustedScore = baseScore;

    // Sort rules by priority
    const sortedRules = [...this.config.rules].sort(
      (a, b) => (b.priority ?? 0) - (a.priority ?? 0),
    );

    for (const rule of sortedRules) {
      if (!rule.enabled) continue;

      // Evaluate conditions
      const matches = this.evaluateConditions(rule.conditions, work, context);
      if (!matches) continue;

      // Apply effects
      for (const effect of rule.effects) {
        const adjustment = this.applyEffect(effect, adjustedScore);
        if (adjustment !== 0) {
          adjustedScore += adjustment;
          adjustments.push({
            reason: rule.description,
            delta: adjustment,
            source: `rule:${rule.id}`,
            appliedAt: new Date().toISOString(),
          });
        }
      }

      appliedRules.push({
        ruleId: rule.id,
        ruleName: rule.name,
        matchedConditions: rule.conditions.map((c) => c.field),
        effects: rule.effects,
      });
    }

    return { appliedRules, adjustments, adjustedScore };
  }

  private evaluateConditions(
    conditions: RuleCondition[],
    work: WorkPrimitive,
    context: PriorityComputeContext,
  ): boolean {
    for (const condition of conditions) {
      const value = this.getFieldValue(work, context, condition.field);
      const matches = this.evaluateCondition(value, condition.operator, condition.value);
      if (!matches) return false;
    }
    return true;
  }

  private getFieldValue(
    work: WorkPrimitive,
    context: PriorityComputeContext,
    field: string,
  ): unknown {
    // Handle nested fields
    const parts = field.split('.');
    let value: unknown = { work, context };

    for (const part of parts) {
      if (value && typeof value === 'object') {
        value = (value as Record<string, unknown>)[part];
      } else {
        return undefined;
      }
    }

    return value;
  }

  private evaluateCondition(
    value: unknown,
    operator: RuleCondition['operator'],
    target: unknown,
  ): boolean {
    switch (operator) {
      case 'equals':
        return value === target;
      case 'not_equals':
        return value !== target;
      case 'greater_than':
        return typeof value === 'number' && typeof target === 'number' && value > target;
      case 'less_than':
        return typeof value === 'number' && typeof target === 'number' && value < target;
      case 'contains':
        return typeof value === 'string' && typeof target === 'string' && value.includes(target);
      case 'in':
        return Array.isArray(target) && target.includes(value);
      case 'matches':
        return typeof value === 'string' && typeof target === 'string' && new RegExp(target).test(value);
      default:
        return false;
    }
  }

  private applyEffect(effect: RuleEffect, currentScore: number): number {
    switch (effect.type) {
      case 'add':
        return effect.value;
      case 'multiply':
        return currentScore * effect.value - currentScore;
      case 'set':
        return effect.value - currentScore;
      case 'cap':
        return currentScore > effect.value ? effect.value - currentScore : 0;
      case 'floor':
        return currentScore < effect.value ? effect.value - currentScore : 0;
      default:
        return 0;
    }
  }

  private scoreToLevel(score: number): PriorityLevel {
    const { critical, high, medium, low } = this.config.thresholds;
    if (score >= critical) return 'critical';
    if (score >= high) return 'high';
    if (score >= medium) return 'medium';
    if (score >= low) return 'low';
    return 'none';
  }

  private getImprovementHints(factor: string, score: number): string[] {
    const hints: string[] = [];

    if (score < 0.5) {
      switch (factor) {
        case 'strategicAlignment':
          hints.push('Link this work to strategic pillars');
          hints.push('Document how this supports the project mission');
          break;
        case 'userImpact':
          hints.push('Identify affected user segments');
          hints.push('Quantify the user benefit');
          break;
        case 'riskReduction':
          hints.push('Document risks this work addresses');
          hints.push('Link to known issues or vulnerabilities');
          break;
        case 'dependencyUnblock':
          hints.push('Identify work items blocked by this');
          hints.push('Consider if this enables other high-priority work');
          break;
        case 'effortValue':
          hints.push('Break down into smaller deliverables');
          hints.push('Identify quick wins within the scope');
          break;
      }
    }

    return hints;
  }

  private generateNarrative(
    work: WorkPrimitive,
    factors: ExplainedFactor[],
    computation: PriorityComputation,
  ): string {
    const topFactors = factors.slice(0, 3);
    const level = computation.priority.level;

    let narrative = `"${work.title}" has ${level} priority (score: ${(computation.priority.score * 100).toFixed(0)}%).`;

    if (topFactors.length > 0) {
      const topFactor = topFactors[0];
      narrative += ` The primary driver is ${topFactor.factor} (${(topFactor.score * 100).toFixed(0)}%).`;
    }

    if (computation.appliedRules.length > 0) {
      narrative += ` ${computation.appliedRules.length} rules were applied.`;
    }

    if (computation.adjustments.length > 0) {
      const totalAdjustment = computation.adjustments.reduce((sum, a) => sum + a.delta, 0);
      narrative += ` Adjustments: ${totalAdjustment > 0 ? '+' : ''}${(totalAdjustment * 100).toFixed(0)}%.`;
    }

    return narrative;
  }

  private generateSuggestions(
    work: WorkPrimitive,
    factors: ExplainedFactor[],
  ): PrioritySuggestion[] {
    const suggestions: PrioritySuggestion[] = [];

    // Low factors suggest improvements
    const lowFactors = factors.filter((f) => f.score < 0.3);
    for (const factor of lowFactors) {
      suggestions.push({
        type: 'improve_factor',
        description: `Improve ${factor.factor} to increase priority`,
        potentialImpact: factor.weight * (0.7 - factor.score),
        actions: factor.improvementHints,
      });
    }

    // High effort with moderate value
    const effortFactor = factors.find((f) => f.factor === 'effortValue');
    if (effortFactor && effortFactor.score < 0.4) {
      suggestions.push({
        type: 'decompose',
        description: 'Consider breaking into smaller items',
        potentialImpact: 0.15,
        actions: ['Identify minimum viable deliverable', 'Split by user stories'],
      });
    }

    // Missing dependencies
    if (work.dependencies.length === 0) {
      suggestions.push({
        type: 'add_dependencies',
        description: 'Adding dependencies may increase priority through unblock potential',
        potentialImpact: 0.1,
        actions: ['Identify blocked items', 'Document dependencies'],
      });
    }

    return suggestions;
  }

  private computeRecommendationReason(
    ranked: RankedWork,
    index: number,
  ): string {
    const topFactor = ranked.computation.factors
      .sort((a, b) => b.score * b.weight - a.score * a.weight)[0];

    if (index === 0) {
      return `Highest priority - ${topFactor?.factor} is the key driver`;
    }

    return `High ${topFactor?.factor ?? 'overall score'}`;
  }

  private findUnblocked(work: WorkPrimitive, allWork: WorkPrimitive[]): string[] {
    return allWork
      .filter((w) =>
        w.dependencies.some(
          (d) => d.dependsOnId === work.id && d.isBlocking,
        ),
      )
      .map((w) => w.id);
  }

  private buildFocusReasoning(
    top: { work: WorkPrimitive; score: number; reason: string },
    all: Array<{ work: WorkPrimitive; score: number }>,
  ): string {
    if (top.score > 0.8) {
      return `"${top.work.title}" is a clear priority with score ${(top.score * 100).toFixed(0)}%. ${top.reason}`;
    }

    if (all.length > 1 && Math.abs(all[0].score - all[1].score) < 0.05) {
      return `Multiple items have similar priority. "${top.work.title}" is slightly ahead.`;
    }

    return `"${top.work.title}" is recommended based on ${top.reason}`;
  }

  private identifySignificantChanges(
    original: FactorResult[],
    modified: FactorResult[],
  ): Array<{ factor: string; originalScore: number; newScore: number }> {
    const significant: Array<{ factor: string; originalScore: number; newScore: number }> = [];

    for (const orig of original) {
      const mod = modified.find((m) => m.factor === orig.factor);
      if (mod && Math.abs(mod.score - orig.score) > 0.1) {
        significant.push({
          factor: orig.factor,
          originalScore: orig.score,
          newScore: mod.score,
        });
      }
    }

    return significant;
  }

  private generateSimulationRecommendations(
    changes: PriorityChange[],
  ): string[] {
    const recommendations: string[] = [];

    const improvements = changes.filter((c) => c.delta > 0.1);
    if (improvements.length > 0) {
      recommendations.push(
        `${improvements.length} items would see significant priority increase`,
      );
    }

    const decreases = changes.filter((c) => c.delta < -0.1);
    if (decreases.length > 0) {
      recommendations.push(
        `${decreases.length} items would see priority decrease - review impact`,
      );
    }

    const levelChanges = changes.filter((c) => c.levelChange);
    if (levelChanges.length > 0) {
      recommendations.push(
        `${levelChanges.length} items would change priority level`,
      );
    }

    return recommendations;
  }

  /**
   * Clear priority cache
   */
  clearCache(): void {
    this.cache.clear();
  }
}
