/**
 * @fileoverview Strategic Knowledge Storage Layer
 *
 * Provides persistent storage for strategic knowledge architecture including:
 * - Project Vision and Strategic Context
 * - Bounded Contexts (DDD-style)
 * - Work Primitives (Epic/Story/Task hierarchy)
 * - Architecture Decision Records (ADRs)
 * - Research findings and external knowledge
 * - Conceptual verification results
 *
 * Design principles:
 * - All data includes provenance and confidence tracking
 * - Full audit trail for all changes
 * - Optimized for both transactional and analytical queries
 * - Supports temporal queries (point-in-time reconstruction)
 */

import Database from 'better-sqlite3';
import { randomUUID } from 'crypto';
import type {
  ProjectVision,
  BoundedContext,
  ArchitectureDecision,
  ExternalKnowledge,
  ResearchResult,
  ConfidenceLevel,
  Provenance,
  ValidationResult,
  ChangeRecord,
} from './types.js';
import type {
  WorkPrimitive,
  WorkStatus,
  WorkPrimitiveType,
  WorkQuery,
  WorkReport,
  WorkTemplate,
  ComputedPriority,
} from './work_primitives.js';
import type {
  ConceptualError,
  VerificationReport,
  ErrorStatus,
} from './conceptual_verification.js';
import type {
  PrioritizationConfig,
  PrioritizationRule,
  RankedWork,
} from './prioritization.js';

// ============================================================================
// SQL INJECTION PREVENTION
// ============================================================================

const ALLOWED_STRATEGIC_TABLES = new Set([
  'strategic_vision',
  'strategic_bounded_contexts',
  'strategic_context_relationships',
  'strategic_architecture_decisions',
  'strategic_external_knowledge',
  'strategic_research_results',
  'strategic_work_primitives',
  'strategic_work_dependencies',
  'strategic_work_evidence',
  'strategic_work_templates',
  'strategic_conceptual_errors',
  'strategic_verification_reports',
  'strategic_prioritization_config',
  'strategic_prioritization_rules',
  'strategic_change_history',
]);

const ALLOWED_STRATEGIC_COLUMNS = new Set([
  'id',
  'created_at',
  'updated_at',
  'version',
  'confidence',
  'confidence_level',
  'status',
  'type',
  'priority_score',
  'computed_at',
  'parent_id',
  'title',
  'name',
  'category',
  'severity',
  'resolved_at',
]);

function validateStrategicTable(table: string): string {
  if (!ALLOWED_STRATEGIC_TABLES.has(table)) {
    throw new Error(`Invalid strategic table: ${table.slice(0, 50)}`);
  }
  return table;
}

function validateStrategicColumn(column: string): string {
  if (!ALLOWED_STRATEGIC_COLUMNS.has(column)) {
    throw new Error(`Invalid strategic column: ${column.slice(0, 50)}`);
  }
  return column;
}

// ============================================================================
// STRATEGIC STORAGE INTERFACE
// ============================================================================

export interface StrategicStorageOptions {
  /** Enable write-ahead logging for better concurrency */
  enableWAL?: boolean;
  /** Enable foreign key constraints */
  enableForeignKeys?: boolean;
  /** Busy timeout in milliseconds */
  busyTimeout?: number;
}

export interface StrategicQueryOptions {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderDirection?: 'asc' | 'desc';
}

export interface WorkQueryOptions extends StrategicQueryOptions {
  types?: WorkPrimitiveType[];
  statuses?: WorkStatus[];
  parentId?: string | null;
  hasParent?: boolean;
  minPriority?: number;
  maxPriority?: number;
  labels?: string[];
  contextId?: string;
  includeChildren?: boolean;
  includeEvidence?: boolean;
}

export interface ConceptualErrorQueryOptions extends StrategicQueryOptions {
  categories?: string[];
  severities?: string[];
  statuses?: ErrorStatus[];
  contextId?: string;
  minConfidence?: number;
  resolved?: boolean;
}

// ============================================================================
// STRATEGIC STORAGE IMPLEMENTATION
// ============================================================================

export class StrategicStorage {
  private db: Database.Database;
  private initialized = false;

  constructor(
    private readonly dbPath: string,
    private readonly options: StrategicStorageOptions = {},
  ) {
    this.db = new Database(dbPath);
  }

  // --------------------------------------------------------------------------
  // INITIALIZATION
  // --------------------------------------------------------------------------

  async initialize(): Promise<void> {
    if (this.initialized) return;

    // Configure database
    if (this.options.enableWAL !== false) {
      this.db.pragma('journal_mode = WAL');
    }
    this.db.pragma('synchronous = NORMAL');
    if (this.options.enableForeignKeys !== false) {
      this.db.pragma('foreign_keys = ON');
    }
    this.db.pragma(`busy_timeout = ${this.options.busyTimeout ?? 5000}`);

    // Create tables
    this.createStrategicTables();
    this.createWorkTables();
    this.createVerificationTables();
    this.createPrioritizationTables();
    this.createAuditTables();

    this.initialized = true;
  }

  private createStrategicTables(): void {
    // Project Vision - singleton per project
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_vision (
        id TEXT PRIMARY KEY,
        version INTEGER NOT NULL DEFAULT 1,
        mission TEXT NOT NULL,
        problem_statement TEXT NOT NULL,
        value_proposition TEXT NOT NULL,
        target_users TEXT NOT NULL,
        pillars TEXT NOT NULL,
        constraints TEXT NOT NULL,
        anti_patterns TEXT NOT NULL,
        success_criteria TEXT NOT NULL,
        quality_weights TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        confidence_level TEXT NOT NULL,
        confidence_factors TEXT NOT NULL,
        provenance TEXT NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        valid_from TEXT NOT NULL,
        valid_until TEXT
      );
      CREATE INDEX IF NOT EXISTS idx_vision_valid ON strategic_vision(valid_from, valid_until);
    `);

    // Bounded Contexts (DDD)
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_bounded_contexts (
        id TEXT PRIMARY KEY,
        version INTEGER NOT NULL DEFAULT 1,
        name TEXT NOT NULL,
        description TEXT NOT NULL,
        boundaries TEXT NOT NULL,
        ubiquitous_language TEXT NOT NULL,
        ownership TEXT NOT NULL,
        implementation TEXT NOT NULL,
        external_dependencies TEXT NOT NULL,
        health TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        confidence_level TEXT NOT NULL,
        provenance TEXT NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        valid_from TEXT NOT NULL,
        valid_until TEXT
      );
      CREATE INDEX IF NOT EXISTS idx_context_name ON strategic_bounded_contexts(name);
      CREATE INDEX IF NOT EXISTS idx_context_valid ON strategic_bounded_contexts(valid_from, valid_until);
    `);

    // Context Relationships
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_context_relationships (
        id TEXT PRIMARY KEY,
        source_context_id TEXT NOT NULL,
        target_context_id TEXT NOT NULL,
        relationship_type TEXT NOT NULL,
        integration_mechanism TEXT NOT NULL,
        data_flows TEXT NOT NULL,
        contracts TEXT NOT NULL,
        health TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        FOREIGN KEY (source_context_id) REFERENCES strategic_bounded_contexts(id),
        FOREIGN KEY (target_context_id) REFERENCES strategic_bounded_contexts(id)
      );
      CREATE INDEX IF NOT EXISTS idx_rel_source ON strategic_context_relationships(source_context_id);
      CREATE INDEX IF NOT EXISTS idx_rel_target ON strategic_context_relationships(target_context_id);
    `);

    // Architecture Decision Records
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_architecture_decisions (
        id TEXT PRIMARY KEY,
        version INTEGER NOT NULL DEFAULT 1,
        title TEXT NOT NULL,
        status TEXT NOT NULL,
        context TEXT NOT NULL,
        decision TEXT NOT NULL,
        rationale TEXT NOT NULL,
        alternatives TEXT NOT NULL,
        consequences TEXT NOT NULL,
        risks TEXT NOT NULL,
        affected_contexts TEXT NOT NULL,
        supersedes TEXT,
        superseded_by TEXT,
        confidence_score REAL NOT NULL,
        confidence_level TEXT NOT NULL,
        provenance TEXT NOT NULL,
        decided_by TEXT NOT NULL,
        decided_at TEXT NOT NULL,
        review_date TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_adr_status ON strategic_architecture_decisions(status);
      CREATE INDEX IF NOT EXISTS idx_adr_decided ON strategic_architecture_decisions(decided_at);
    `);

    // External Knowledge Cache
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_external_knowledge (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL,
        source TEXT NOT NULL,
        url TEXT,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        summary TEXT NOT NULL,
        key_points TEXT NOT NULL,
        applicability TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        authority TEXT NOT NULL,
        fetched_at TEXT NOT NULL,
        valid_until TEXT,
        related_contexts TEXT NOT NULL,
        related_decisions TEXT NOT NULL,
        tags TEXT NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_ext_type ON strategic_external_knowledge(type);
      CREATE INDEX IF NOT EXISTS idx_ext_source ON strategic_external_knowledge(source);
      CREATE INDEX IF NOT EXISTS idx_ext_valid ON strategic_external_knowledge(valid_until);
    `);

    // Research Results
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_research_results (
        id TEXT PRIMARY KEY,
        query_id TEXT NOT NULL,
        query_text TEXT NOT NULL,
        depth TEXT NOT NULL,
        findings TEXT NOT NULL,
        synthesis TEXT NOT NULL,
        quality_assessment TEXT NOT NULL,
        knowledge_gaps TEXT NOT NULL,
        recommendations TEXT NOT NULL,
        sources_used TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        confidence_level TEXT NOT NULL,
        provenance TEXT NOT NULL,
        started_at TEXT NOT NULL,
        completed_at TEXT NOT NULL,
        created_at TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_research_query ON strategic_research_results(query_id);
      CREATE INDEX IF NOT EXISTS idx_research_depth ON strategic_research_results(depth);
    `);
  }

  private createWorkTables(): void {
    // Work Primitives (Epic/Story/Task/Step hierarchy)
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_work_primitives (
        id TEXT PRIMARY KEY,
        version INTEGER NOT NULL DEFAULT 1,
        type TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        rationale TEXT,
        acceptance_criteria TEXT NOT NULL,
        notes TEXT NOT NULL,
        parent_id TEXT,
        child_ids TEXT NOT NULL,
        context_id TEXT,
        traceability TEXT NOT NULL,
        priority_score REAL NOT NULL,
        priority_level TEXT NOT NULL,
        priority_factors TEXT NOT NULL,
        priority_override TEXT,
        priority_computed_at TEXT NOT NULL,
        impact TEXT NOT NULL,
        effort TEXT NOT NULL,
        status TEXT NOT NULL,
        status_history TEXT NOT NULL,
        timing TEXT NOT NULL,
        labels TEXT NOT NULL,
        change_history TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        confidence_level TEXT NOT NULL,
        provenance TEXT NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        FOREIGN KEY (parent_id) REFERENCES strategic_work_primitives(id),
        FOREIGN KEY (context_id) REFERENCES strategic_bounded_contexts(id)
      );
      CREATE INDEX IF NOT EXISTS idx_work_type ON strategic_work_primitives(type);
      CREATE INDEX IF NOT EXISTS idx_work_status ON strategic_work_primitives(status);
      CREATE INDEX IF NOT EXISTS idx_work_parent ON strategic_work_primitives(parent_id);
      CREATE INDEX IF NOT EXISTS idx_work_context ON strategic_work_primitives(context_id);
      CREATE INDEX IF NOT EXISTS idx_work_priority ON strategic_work_primitives(priority_score DESC);
    `);

    // Work Dependencies
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_work_dependencies (
        id TEXT PRIMARY KEY,
        work_id TEXT NOT NULL,
        depends_on_id TEXT NOT NULL,
        dependency_type TEXT NOT NULL,
        description TEXT,
        is_blocking INTEGER NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL,
        FOREIGN KEY (work_id) REFERENCES strategic_work_primitives(id),
        FOREIGN KEY (depends_on_id) REFERENCES strategic_work_primitives(id)
      );
      CREATE INDEX IF NOT EXISTS idx_dep_work ON strategic_work_dependencies(work_id);
      CREATE INDEX IF NOT EXISTS idx_dep_depends ON strategic_work_dependencies(depends_on_id);
      CREATE INDEX IF NOT EXISTS idx_dep_blocking ON strategic_work_dependencies(is_blocking);
    `);

    // Work Evidence
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_work_evidence (
        id TEXT PRIMARY KEY,
        work_id TEXT NOT NULL,
        evidence_type TEXT NOT NULL,
        description TEXT NOT NULL,
        artifact_path TEXT,
        artifact_url TEXT,
        verification_method TEXT NOT NULL,
        verified_at TEXT,
        verified_by TEXT,
        confidence_score REAL NOT NULL,
        created_at TEXT NOT NULL,
        FOREIGN KEY (work_id) REFERENCES strategic_work_primitives(id)
      );
      CREATE INDEX IF NOT EXISTS idx_evidence_work ON strategic_work_evidence(work_id);
      CREATE INDEX IF NOT EXISTS idx_evidence_type ON strategic_work_evidence(evidence_type);
    `);

    // Work Templates
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_work_templates (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        description TEXT NOT NULL,
        work_type TEXT NOT NULL,
        default_title_pattern TEXT NOT NULL,
        default_description_pattern TEXT NOT NULL,
        suggested_steps TEXT NOT NULL,
        default_labels TEXT NOT NULL,
        default_effort TEXT NOT NULL,
        auto_triggers TEXT NOT NULL,
        usage_count INTEGER NOT NULL DEFAULT 0,
        success_rate REAL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_template_type ON strategic_work_templates(work_type);
      CREATE INDEX IF NOT EXISTS idx_template_usage ON strategic_work_templates(usage_count DESC);
    `);
  }

  private createVerificationTables(): void {
    // Conceptual Errors
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_conceptual_errors (
        id TEXT PRIMARY KEY,
        version INTEGER NOT NULL DEFAULT 1,
        category TEXT NOT NULL,
        subcategory TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        severity TEXT NOT NULL,
        location TEXT NOT NULL,
        scope TEXT NOT NULL,
        evidence TEXT NOT NULL,
        root_cause TEXT,
        implications TEXT NOT NULL,
        suggested_fixes TEXT NOT NULL,
        detection_method TEXT NOT NULL,
        related_errors TEXT NOT NULL,
        status TEXT NOT NULL,
        status_history TEXT NOT NULL,
        assigned_to TEXT,
        work_item_id TEXT,
        confidence_score REAL NOT NULL,
        confidence_level TEXT NOT NULL,
        provenance TEXT NOT NULL,
        detected_at TEXT NOT NULL,
        resolved_at TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        FOREIGN KEY (work_item_id) REFERENCES strategic_work_primitives(id)
      );
      CREATE INDEX IF NOT EXISTS idx_error_category ON strategic_conceptual_errors(category);
      CREATE INDEX IF NOT EXISTS idx_error_severity ON strategic_conceptual_errors(severity);
      CREATE INDEX IF NOT EXISTS idx_error_status ON strategic_conceptual_errors(status);
      CREATE INDEX IF NOT EXISTS idx_error_detected ON strategic_conceptual_errors(detected_at);
    `);

    // Verification Reports
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_verification_reports (
        id TEXT PRIMARY KEY,
        context_id TEXT,
        scope TEXT NOT NULL,
        errors_found INTEGER NOT NULL,
        errors_by_category TEXT NOT NULL,
        errors_by_severity TEXT NOT NULL,
        summary TEXT NOT NULL,
        trends TEXT,
        recommendations TEXT NOT NULL,
        confidence_score REAL NOT NULL,
        started_at TEXT NOT NULL,
        completed_at TEXT NOT NULL,
        created_at TEXT NOT NULL,
        FOREIGN KEY (context_id) REFERENCES strategic_bounded_contexts(id)
      );
      CREATE INDEX IF NOT EXISTS idx_report_context ON strategic_verification_reports(context_id);
      CREATE INDEX IF NOT EXISTS idx_report_completed ON strategic_verification_reports(completed_at);
    `);
  }

  private createPrioritizationTables(): void {
    // Prioritization Configuration
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_prioritization_config (
        id TEXT PRIMARY KEY,
        version INTEGER NOT NULL DEFAULT 1,
        weights TEXT NOT NULL,
        thresholds TEXT NOT NULL,
        decay_config TEXT NOT NULL,
        rules TEXT NOT NULL,
        effective_from TEXT NOT NULL,
        effective_until TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_prio_effective ON strategic_prioritization_config(effective_from, effective_until);
    `);

    // Prioritization Rules (separate for easier management)
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_prioritization_rules (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT NOT NULL,
        conditions TEXT NOT NULL,
        effects TEXT NOT NULL,
        priority INTEGER NOT NULL DEFAULT 0,
        enabled INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_rule_priority ON strategic_prioritization_rules(priority DESC);
      CREATE INDEX IF NOT EXISTS idx_rule_enabled ON strategic_prioritization_rules(enabled);
    `);

    // Priority Computation Cache
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_priority_cache (
        work_id TEXT PRIMARY KEY,
        priority_score REAL NOT NULL,
        priority_level TEXT NOT NULL,
        factors TEXT NOT NULL,
        applied_rules TEXT NOT NULL,
        computed_at TEXT NOT NULL,
        valid_until TEXT NOT NULL,
        FOREIGN KEY (work_id) REFERENCES strategic_work_primitives(id)
      );
      CREATE INDEX IF NOT EXISTS idx_cache_valid ON strategic_priority_cache(valid_until);
    `);
  }

  private createAuditTables(): void {
    // Change History (audit trail)
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategic_change_history (
        id TEXT PRIMARY KEY,
        entity_type TEXT NOT NULL,
        entity_id TEXT NOT NULL,
        change_type TEXT NOT NULL,
        field_name TEXT,
        old_value TEXT,
        new_value TEXT,
        reason TEXT,
        changed_by TEXT NOT NULL,
        changed_at TEXT NOT NULL,
        session_id TEXT,
        provenance TEXT
      );
      CREATE INDEX IF NOT EXISTS idx_history_entity ON strategic_change_history(entity_type, entity_id);
      CREATE INDEX IF NOT EXISTS idx_history_changed ON strategic_change_history(changed_at);
      CREATE INDEX IF NOT EXISTS idx_history_session ON strategic_change_history(session_id);
    `);
  }

  // --------------------------------------------------------------------------
  // PROJECT VISION OPERATIONS
  // --------------------------------------------------------------------------

  getVision(): ProjectVision | null {
    const row = this.db
      .prepare(
        `SELECT * FROM strategic_vision
         WHERE valid_until IS NULL
         ORDER BY version DESC
         LIMIT 1`,
      )
      .get() as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToVision(row);
  }

  getVisionHistory(): ProjectVision[] {
    const rows = this.db
      .prepare(
        `SELECT * FROM strategic_vision
         ORDER BY version DESC`,
      )
      .all() as Record<string, unknown>[];

    return rows.map((row) => this.rowToVision(row));
  }

  saveVision(vision: Omit<ProjectVision, 'id' | 'version'>): ProjectVision {
    const now = new Date().toISOString();
    const id = randomUUID();

    // Invalidate current version
    this.db
      .prepare(
        `UPDATE strategic_vision
         SET valid_until = ?
         WHERE valid_until IS NULL`,
      )
      .run(now);

    // Get next version number
    const maxVersion = (
      this.db
        .prepare('SELECT MAX(version) as max FROM strategic_vision')
        .get() as { max: number | null }
    ).max;
    const version = (maxVersion ?? 0) + 1;

    // Insert new version
    this.db
      .prepare(
        `INSERT INTO strategic_vision (
          id, version, mission, problem_statement, value_proposition,
          target_users, pillars, constraints, anti_patterns, success_criteria,
          quality_weights, confidence_score, confidence_level, confidence_factors,
          provenance, created_at, updated_at, valid_from, valid_until
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NULL)`,
      )
      .run(
        id,
        version,
        vision.mission,
        vision.problemStatement,
        vision.valueProposition,
        JSON.stringify(vision.targetUsers),
        JSON.stringify(vision.pillars),
        JSON.stringify(vision.constraints),
        JSON.stringify(vision.antiPatterns),
        JSON.stringify(vision.successCriteria),
        JSON.stringify(vision.qualityWeights),
        vision.confidence.score,
        vision.confidence.level,
        JSON.stringify(vision.confidence.factors),
        JSON.stringify(vision.provenance),
        now,
        now,
        now,
      );

    this.recordChange('vision', id, 'create', null, null, JSON.stringify(vision), 'Initial creation');

    return { ...vision, id, version } as ProjectVision;
  }

  private rowToVision(row: Record<string, unknown>): ProjectVision {
    return {
      id: row.id as string,
      version: row.version as number,
      mission: row.mission as string,
      problemStatement: row.problem_statement as string,
      valueProposition: row.value_proposition as string,
      targetUsers: JSON.parse(row.target_users as string),
      pillars: JSON.parse(row.pillars as string),
      constraints: JSON.parse(row.constraints as string),
      antiPatterns: JSON.parse(row.anti_patterns as string),
      successCriteria: JSON.parse(row.success_criteria as string),
      qualityWeights: JSON.parse(row.quality_weights as string),
      confidence: {
        score: row.confidence_score as number,
        level: row.confidence_level as ConfidenceLevel,
        factors: JSON.parse(row.confidence_factors as string),
      },
      provenance: JSON.parse(row.provenance as string),
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    };
  }

  // --------------------------------------------------------------------------
  // BOUNDED CONTEXT OPERATIONS
  // --------------------------------------------------------------------------

  getBoundedContext(id: string): BoundedContext | null {
    const row = this.db
      .prepare(
        `SELECT * FROM strategic_bounded_contexts
         WHERE id = ? AND valid_until IS NULL`,
      )
      .get(id) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToBoundedContext(row);
  }

  getAllBoundedContexts(options?: StrategicQueryOptions): BoundedContext[] {
    let sql = `SELECT * FROM strategic_bounded_contexts WHERE valid_until IS NULL`;

    if (options?.orderBy) {
      const col = validateStrategicColumn(options.orderBy);
      const dir = options.orderDirection === 'desc' ? 'DESC' : 'ASC';
      sql += ` ORDER BY ${col} ${dir}`;
    } else {
      sql += ' ORDER BY name ASC';
    }

    if (options?.limit) {
      sql += ` LIMIT ${Number(options.limit)}`;
    }
    if (options?.offset) {
      sql += ` OFFSET ${Number(options.offset)}`;
    }

    const rows = this.db.prepare(sql).all() as Record<string, unknown>[];
    return rows.map((row) => this.rowToBoundedContext(row));
  }

  saveBoundedContext(
    context: Omit<BoundedContext, 'id' | 'version'>,
  ): BoundedContext {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_bounded_contexts (
          id, version, name, description, boundaries, ubiquitous_language,
          ownership, implementation, external_dependencies, health,
          confidence_score, confidence_level, provenance,
          created_at, updated_at, valid_from, valid_until
        ) VALUES (?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NULL)`,
      )
      .run(
        id,
        context.name,
        context.description,
        JSON.stringify(context.boundaries),
        JSON.stringify(context.ubiquitousLanguage),
        JSON.stringify(context.ownership),
        JSON.stringify(context.implementation),
        JSON.stringify(context.externalDependencies),
        JSON.stringify(context.health),
        context.confidence.score,
        context.confidence.level,
        JSON.stringify(context.provenance),
        now,
        now,
        now,
      );

    this.recordChange(
      'bounded_context',
      id,
      'create',
      null,
      null,
      context.name,
      'Created bounded context',
    );

    return { ...context, id, version: 1 } as BoundedContext;
  }

  updateBoundedContext(
    id: string,
    updates: Partial<BoundedContext>,
  ): BoundedContext | null {
    const existing = this.getBoundedContext(id);
    if (!existing) return null;

    const now = new Date().toISOString();

    // Invalidate current version
    this.db
      .prepare(
        `UPDATE strategic_bounded_contexts
         SET valid_until = ?
         WHERE id = ? AND valid_until IS NULL`,
      )
      .run(now, id);

    // Create new version
    const newVersion = existing.version + 1;
    const merged = { ...existing, ...updates, version: newVersion };

    this.db
      .prepare(
        `INSERT INTO strategic_bounded_contexts (
          id, version, name, description, boundaries, ubiquitous_language,
          ownership, implementation, external_dependencies, health,
          confidence_score, confidence_level, provenance,
          created_at, updated_at, valid_from, valid_until
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NULL)`,
      )
      .run(
        id,
        newVersion,
        merged.name,
        merged.description,
        JSON.stringify(merged.boundaries),
        JSON.stringify(merged.ubiquitousLanguage),
        JSON.stringify(merged.ownership),
        JSON.stringify(merged.implementation),
        JSON.stringify(merged.externalDependencies),
        JSON.stringify(merged.health),
        merged.confidence.score,
        merged.confidence.level,
        JSON.stringify(merged.provenance),
        existing.createdAt,
        now,
        now,
      );

    this.recordChange(
      'bounded_context',
      id,
      'update',
      null,
      JSON.stringify(existing),
      JSON.stringify(merged),
      'Updated bounded context',
    );

    return merged;
  }

  private rowToBoundedContext(row: Record<string, unknown>): BoundedContext {
    return {
      id: row.id as string,
      version: row.version as number,
      name: row.name as string,
      description: row.description as string,
      boundaries: JSON.parse(row.boundaries as string),
      ubiquitousLanguage: JSON.parse(row.ubiquitous_language as string),
      ownership: JSON.parse(row.ownership as string),
      implementation: JSON.parse(row.implementation as string),
      externalDependencies: JSON.parse(row.external_dependencies as string),
      health: JSON.parse(row.health as string),
      relationships: [], // Loaded separately
      confidence: {
        score: row.confidence_score as number,
        level: row.confidence_level as ConfidenceLevel,
        factors: [],
      },
      provenance: JSON.parse(row.provenance as string),
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    };
  }

  // --------------------------------------------------------------------------
  // WORK PRIMITIVE OPERATIONS
  // --------------------------------------------------------------------------

  getWorkPrimitive(id: string): WorkPrimitive | null {
    const row = this.db
      .prepare('SELECT * FROM strategic_work_primitives WHERE id = ?')
      .get(id) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToWorkPrimitive(row);
  }

  queryWorkPrimitives(options: WorkQueryOptions = {}): WorkPrimitive[] {
    const conditions: string[] = [];
    const params: unknown[] = [];

    if (options.types?.length) {
      conditions.push(`type IN (${options.types.map(() => '?').join(', ')})`);
      params.push(...options.types);
    }

    if (options.statuses?.length) {
      conditions.push(`status IN (${options.statuses.map(() => '?').join(', ')})`);
      params.push(...options.statuses);
    }

    if (options.parentId !== undefined) {
      if (options.parentId === null) {
        conditions.push('parent_id IS NULL');
      } else {
        conditions.push('parent_id = ?');
        params.push(options.parentId);
      }
    }

    if (options.hasParent !== undefined) {
      conditions.push(options.hasParent ? 'parent_id IS NOT NULL' : 'parent_id IS NULL');
    }

    if (options.minPriority !== undefined) {
      conditions.push('priority_score >= ?');
      params.push(options.minPriority);
    }

    if (options.maxPriority !== undefined) {
      conditions.push('priority_score <= ?');
      params.push(options.maxPriority);
    }

    if (options.contextId) {
      conditions.push('context_id = ?');
      params.push(options.contextId);
    }

    let sql = 'SELECT * FROM strategic_work_primitives';
    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ');
    }

    // Order by priority by default
    if (options.orderBy) {
      const col = validateStrategicColumn(options.orderBy);
      const dir = options.orderDirection === 'desc' ? 'DESC' : 'ASC';
      sql += ` ORDER BY ${col} ${dir}`;
    } else {
      sql += ' ORDER BY priority_score DESC';
    }

    if (options.limit) {
      sql += ` LIMIT ${Number(options.limit)}`;
    }
    if (options.offset) {
      sql += ` OFFSET ${Number(options.offset)}`;
    }

    const rows = this.db.prepare(sql).all(...params) as Record<string, unknown>[];
    return rows.map((row) => this.rowToWorkPrimitive(row));
  }

  saveWorkPrimitive(
    work: Omit<WorkPrimitive, 'id' | 'version'>,
  ): WorkPrimitive {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_work_primitives (
          id, version, type, title, description, rationale, acceptance_criteria,
          notes, parent_id, child_ids, context_id, traceability,
          priority_score, priority_level, priority_factors, priority_override, priority_computed_at,
          impact, effort, status, status_history, timing, labels,
          change_history, confidence_score, confidence_level, provenance,
          created_at, updated_at
        ) VALUES (?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      )
      .run(
        id,
        work.type,
        work.title,
        work.description,
        work.rationale ?? null,
        JSON.stringify(work.acceptanceCriteria),
        JSON.stringify(work.notes),
        work.parentId ?? null,
        JSON.stringify(work.childIds),
        work.contextId ?? null,
        JSON.stringify(work.traceability),
        work.priority.score,
        work.priority.level,
        JSON.stringify(work.priority.factors),
        work.priority.override ? JSON.stringify(work.priority.override) : null,
        work.priority.computedAt,
        JSON.stringify(work.impact),
        JSON.stringify(work.effort),
        work.status,
        JSON.stringify(work.statusHistory),
        JSON.stringify(work.timing),
        JSON.stringify(work.labels),
        JSON.stringify(work.changeHistory),
        work.confidence.score,
        work.confidence.level,
        JSON.stringify(work.provenance),
        now,
        now,
      );

    // Update parent's childIds if needed
    if (work.parentId) {
      const parent = this.getWorkPrimitive(work.parentId);
      if (parent && !parent.childIds.includes(id)) {
        this.updateWorkPrimitive(work.parentId, {
          childIds: [...parent.childIds, id],
        });
      }
    }

    this.recordChange('work_primitive', id, 'create', null, null, work.title, 'Created work item');

    return { ...work, id, version: 1 } as WorkPrimitive;
  }

  updateWorkPrimitive(
    id: string,
    updates: Partial<WorkPrimitive>,
  ): WorkPrimitive | null {
    const existing = this.getWorkPrimitive(id);
    if (!existing) return null;

    const now = new Date().toISOString();
    const merged = { ...existing, ...updates, version: existing.version + 1 };

    this.db
      .prepare(
        `UPDATE strategic_work_primitives SET
          version = ?,
          type = ?,
          title = ?,
          description = ?,
          rationale = ?,
          acceptance_criteria = ?,
          notes = ?,
          parent_id = ?,
          child_ids = ?,
          context_id = ?,
          traceability = ?,
          priority_score = ?,
          priority_level = ?,
          priority_factors = ?,
          priority_override = ?,
          priority_computed_at = ?,
          impact = ?,
          effort = ?,
          status = ?,
          status_history = ?,
          timing = ?,
          labels = ?,
          change_history = ?,
          confidence_score = ?,
          confidence_level = ?,
          provenance = ?,
          updated_at = ?
        WHERE id = ?`,
      )
      .run(
        merged.version,
        merged.type,
        merged.title,
        merged.description,
        merged.rationale ?? null,
        JSON.stringify(merged.acceptanceCriteria),
        JSON.stringify(merged.notes),
        merged.parentId ?? null,
        JSON.stringify(merged.childIds),
        merged.contextId ?? null,
        JSON.stringify(merged.traceability),
        merged.priority.score,
        merged.priority.level,
        JSON.stringify(merged.priority.factors),
        merged.priority.override ? JSON.stringify(merged.priority.override) : null,
        merged.priority.computedAt,
        JSON.stringify(merged.impact),
        JSON.stringify(merged.effort),
        merged.status,
        JSON.stringify(merged.statusHistory),
        JSON.stringify(merged.timing),
        JSON.stringify(merged.labels),
        JSON.stringify(merged.changeHistory),
        merged.confidence.score,
        merged.confidence.level,
        JSON.stringify(merged.provenance),
        now,
        id,
      );

    this.recordChange(
      'work_primitive',
      id,
      'update',
      null,
      JSON.stringify(existing),
      JSON.stringify(merged),
      'Updated work item',
    );

    return merged;
  }

  deleteWorkPrimitive(id: string): boolean {
    const existing = this.getWorkPrimitive(id);
    if (!existing) return false;

    // Remove from parent's childIds
    if (existing.parentId) {
      const parent = this.getWorkPrimitive(existing.parentId);
      if (parent) {
        this.updateWorkPrimitive(existing.parentId, {
          childIds: parent.childIds.filter((childId) => childId !== id),
        });
      }
    }

    // Delete dependencies
    this.db
      .prepare('DELETE FROM strategic_work_dependencies WHERE work_id = ? OR depends_on_id = ?')
      .run(id, id);

    // Delete evidence
    this.db.prepare('DELETE FROM strategic_work_evidence WHERE work_id = ?').run(id);

    // Delete work item
    this.db.prepare('DELETE FROM strategic_work_primitives WHERE id = ?').run(id);

    this.recordChange(
      'work_primitive',
      id,
      'delete',
      null,
      JSON.stringify(existing),
      null,
      'Deleted work item',
    );

    return true;
  }

  getWorkHierarchy(rootId?: string): WorkPrimitive[] {
    if (rootId) {
      // Get specific subtree
      const root = this.getWorkPrimitive(rootId);
      if (!root) return [];

      const result: WorkPrimitive[] = [root];
      const queue = [...root.childIds];

      while (queue.length > 0) {
        const childId = queue.shift()!;
        const child = this.getWorkPrimitive(childId);
        if (child) {
          result.push(child);
          queue.push(...child.childIds);
        }
      }

      return result;
    }

    // Get all root items and their trees
    const roots = this.queryWorkPrimitives({ parentId: null });
    const result: WorkPrimitive[] = [];

    for (const root of roots) {
      result.push(...this.getWorkHierarchy(root.id));
    }

    return result;
  }

  private rowToWorkPrimitive(row: Record<string, unknown>): WorkPrimitive {
    return {
      id: row.id as string,
      version: row.version as number,
      type: row.type as WorkPrimitiveType,
      title: row.title as string,
      description: row.description as string,
      rationale: row.rationale as string | undefined,
      acceptanceCriteria: JSON.parse(row.acceptance_criteria as string),
      notes: JSON.parse(row.notes as string),
      parentId: row.parent_id as string | null,
      childIds: JSON.parse(row.child_ids as string),
      contextId: row.context_id as string | undefined,
      dependencies: [], // Loaded separately
      traceability: JSON.parse(row.traceability as string),
      priority: {
        score: row.priority_score as number,
        level: row.priority_level as string,
        factors: JSON.parse(row.priority_factors as string),
        override: row.priority_override
          ? JSON.parse(row.priority_override as string)
          : undefined,
        computedAt: row.priority_computed_at as string,
      } as ComputedPriority,
      impact: JSON.parse(row.impact as string),
      effort: JSON.parse(row.effort as string),
      status: row.status as WorkStatus,
      statusHistory: JSON.parse(row.status_history as string),
      timing: JSON.parse(row.timing as string),
      evidence: [], // Loaded separately
      labels: JSON.parse(row.labels as string),
      changeHistory: JSON.parse(row.change_history as string),
      confidence: {
        score: row.confidence_score as number,
        level: row.confidence_level as ConfidenceLevel,
        factors: [],
      },
      provenance: JSON.parse(row.provenance as string),
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    };
  }

  // --------------------------------------------------------------------------
  // CONCEPTUAL ERROR OPERATIONS
  // --------------------------------------------------------------------------

  getConceptualError(id: string): ConceptualError | null {
    const row = this.db
      .prepare('SELECT * FROM strategic_conceptual_errors WHERE id = ?')
      .get(id) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToConceptualError(row);
  }

  queryConceptualErrors(options: ConceptualErrorQueryOptions = {}): ConceptualError[] {
    const conditions: string[] = [];
    const params: unknown[] = [];

    if (options.categories?.length) {
      conditions.push(`category IN (${options.categories.map(() => '?').join(', ')})`);
      params.push(...options.categories);
    }

    if (options.severities?.length) {
      conditions.push(`severity IN (${options.severities.map(() => '?').join(', ')})`);
      params.push(...options.severities);
    }

    if (options.statuses?.length) {
      conditions.push(`status IN (${options.statuses.map(() => '?').join(', ')})`);
      params.push(...options.statuses);
    }

    if (options.minConfidence !== undefined) {
      conditions.push('confidence_score >= ?');
      params.push(options.minConfidence);
    }

    if (options.resolved !== undefined) {
      conditions.push(options.resolved ? 'resolved_at IS NOT NULL' : 'resolved_at IS NULL');
    }

    let sql = 'SELECT * FROM strategic_conceptual_errors';
    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ');
    }

    if (options.orderBy) {
      const col = validateStrategicColumn(options.orderBy);
      const dir = options.orderDirection === 'desc' ? 'DESC' : 'ASC';
      sql += ` ORDER BY ${col} ${dir}`;
    } else {
      sql += ' ORDER BY detected_at DESC';
    }

    if (options.limit) {
      sql += ` LIMIT ${Number(options.limit)}`;
    }
    if (options.offset) {
      sql += ` OFFSET ${Number(options.offset)}`;
    }

    const rows = this.db.prepare(sql).all(...params) as Record<string, unknown>[];
    return rows.map((row) => this.rowToConceptualError(row));
  }

  saveConceptualError(
    error: Omit<ConceptualError, 'id' | 'version'>,
  ): ConceptualError {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_conceptual_errors (
          id, version, category, subcategory, title, description, severity,
          location, scope, evidence, root_cause, implications, suggested_fixes,
          detection_method, related_errors, status, status_history,
          assigned_to, work_item_id, confidence_score, confidence_level,
          provenance, detected_at, resolved_at, created_at, updated_at
        ) VALUES (?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      )
      .run(
        id,
        error.category,
        error.subcategory,
        error.title,
        error.description,
        error.severity,
        JSON.stringify(error.location),
        JSON.stringify(error.scope),
        JSON.stringify(error.evidence),
        error.rootCause ? JSON.stringify(error.rootCause) : null,
        JSON.stringify(error.implications),
        JSON.stringify(error.suggestedFixes),
        JSON.stringify(error.detectionMethod),
        JSON.stringify(error.relatedErrors),
        error.status.current,
        JSON.stringify(error.status.history),
        error.status.assignedTo ?? null,
        error.status.workItemId ?? null,
        error.confidence.score,
        error.confidence.level,
        JSON.stringify(error.provenance),
        error.detectedAt,
        error.resolvedAt ?? null,
        now,
        now,
      );

    this.recordChange(
      'conceptual_error',
      id,
      'create',
      null,
      null,
      error.title,
      'Detected conceptual error',
    );

    return { ...error, id, version: 1 } as ConceptualError;
  }

  updateConceptualError(
    id: string,
    updates: Partial<ConceptualError>,
  ): ConceptualError | null {
    const existing = this.getConceptualError(id);
    if (!existing) return null;

    const now = new Date().toISOString();
    const merged = { ...existing, ...updates, version: existing.version + 1 };

    this.db
      .prepare(
        `UPDATE strategic_conceptual_errors SET
          version = ?,
          category = ?,
          subcategory = ?,
          title = ?,
          description = ?,
          severity = ?,
          location = ?,
          scope = ?,
          evidence = ?,
          root_cause = ?,
          implications = ?,
          suggested_fixes = ?,
          detection_method = ?,
          related_errors = ?,
          status = ?,
          status_history = ?,
          assigned_to = ?,
          work_item_id = ?,
          confidence_score = ?,
          confidence_level = ?,
          provenance = ?,
          resolved_at = ?,
          updated_at = ?
        WHERE id = ?`,
      )
      .run(
        merged.version,
        merged.category,
        merged.subcategory,
        merged.title,
        merged.description,
        merged.severity,
        JSON.stringify(merged.location),
        JSON.stringify(merged.scope),
        JSON.stringify(merged.evidence),
        merged.rootCause ? JSON.stringify(merged.rootCause) : null,
        JSON.stringify(merged.implications),
        JSON.stringify(merged.suggestedFixes),
        JSON.stringify(merged.detectionMethod),
        JSON.stringify(merged.relatedErrors),
        merged.status.current,
        JSON.stringify(merged.status.history),
        merged.status.assignedTo ?? null,
        merged.status.workItemId ?? null,
        merged.confidence.score,
        merged.confidence.level,
        JSON.stringify(merged.provenance),
        merged.resolvedAt ?? null,
        now,
        id,
      );

    this.recordChange(
      'conceptual_error',
      id,
      'update',
      null,
      JSON.stringify(existing),
      JSON.stringify(merged),
      'Updated conceptual error',
    );

    return merged;
  }

  private rowToConceptualError(row: Record<string, unknown>): ConceptualError {
    return {
      id: row.id as string,
      version: row.version as number,
      category: row.category as string,
      subcategory: row.subcategory as string,
      title: row.title as string,
      description: row.description as string,
      severity: row.severity as string,
      location: JSON.parse(row.location as string),
      scope: JSON.parse(row.scope as string),
      evidence: JSON.parse(row.evidence as string),
      rootCause: row.root_cause ? JSON.parse(row.root_cause as string) : undefined,
      implications: JSON.parse(row.implications as string),
      suggestedFixes: JSON.parse(row.suggested_fixes as string),
      detectionMethod: JSON.parse(row.detection_method as string),
      relatedErrors: JSON.parse(row.related_errors as string),
      status: {
        current: row.status as string,
        history: JSON.parse(row.status_history as string),
        assignedTo: row.assigned_to as string | undefined,
        workItemId: row.work_item_id as string | undefined,
      },
      confidence: {
        score: row.confidence_score as number,
        level: row.confidence_level as ConfidenceLevel,
        factors: [],
      },
      provenance: JSON.parse(row.provenance as string),
      detectedAt: row.detected_at as string,
      resolvedAt: row.resolved_at as string | undefined,
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    } as ConceptualError;
  }

  // --------------------------------------------------------------------------
  // ARCHITECTURE DECISION RECORDS
  // --------------------------------------------------------------------------

  getArchitectureDecision(id: string): ArchitectureDecision | null {
    const row = this.db
      .prepare('SELECT * FROM strategic_architecture_decisions WHERE id = ?')
      .get(id) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToADR(row);
  }

  queryArchitectureDecisions(options?: StrategicQueryOptions): ArchitectureDecision[] {
    let sql = 'SELECT * FROM strategic_architecture_decisions';

    if (options?.orderBy) {
      const col = validateStrategicColumn(options.orderBy);
      const dir = options.orderDirection === 'desc' ? 'DESC' : 'ASC';
      sql += ` ORDER BY ${col} ${dir}`;
    } else {
      sql += ' ORDER BY decided_at DESC';
    }

    if (options?.limit) {
      sql += ` LIMIT ${Number(options.limit)}`;
    }
    if (options?.offset) {
      sql += ` OFFSET ${Number(options.offset)}`;
    }

    const rows = this.db.prepare(sql).all() as Record<string, unknown>[];
    return rows.map((row) => this.rowToADR(row));
  }

  saveArchitectureDecision(
    adr: Omit<ArchitectureDecision, 'id' | 'version'>,
  ): ArchitectureDecision {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_architecture_decisions (
          id, version, title, status, context, decision, rationale,
          alternatives, consequences, risks, affected_contexts,
          supersedes, superseded_by, confidence_score, confidence_level,
          provenance, decided_by, decided_at, review_date,
          created_at, updated_at
        ) VALUES (?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      )
      .run(
        id,
        adr.title,
        adr.status,
        adr.context,
        adr.decision,
        adr.rationale,
        JSON.stringify(adr.alternatives),
        JSON.stringify(adr.consequences),
        JSON.stringify(adr.risks),
        JSON.stringify(adr.affectedContexts),
        adr.supersedes ?? null,
        adr.supersededBy ?? null,
        adr.confidence.score,
        adr.confidence.level,
        JSON.stringify(adr.provenance),
        adr.decidedBy,
        adr.decidedAt,
        adr.reviewDate ?? null,
        now,
        now,
      );

    this.recordChange('adr', id, 'create', null, null, adr.title, 'Created ADR');

    return { ...adr, id, version: 1 } as ArchitectureDecision;
  }

  private rowToADR(row: Record<string, unknown>): ArchitectureDecision {
    return {
      id: row.id as string,
      version: row.version as number,
      title: row.title as string,
      status: row.status as string,
      context: row.context as string,
      decision: row.decision as string,
      rationale: row.rationale as string,
      alternatives: JSON.parse(row.alternatives as string),
      consequences: JSON.parse(row.consequences as string),
      risks: JSON.parse(row.risks as string),
      affectedContexts: JSON.parse(row.affected_contexts as string),
      supersedes: row.supersedes as string | undefined,
      supersededBy: row.superseded_by as string | undefined,
      confidence: {
        score: row.confidence_score as number,
        level: row.confidence_level as ConfidenceLevel,
        factors: [],
      },
      provenance: JSON.parse(row.provenance as string),
      decidedBy: row.decided_by as string,
      decidedAt: row.decided_at as string,
      reviewDate: row.review_date as string | undefined,
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    } as ArchitectureDecision;
  }

  // --------------------------------------------------------------------------
  // RESEARCH & EXTERNAL KNOWLEDGE
  // --------------------------------------------------------------------------

  saveResearchResult(result: Omit<ResearchResult, 'id'>): ResearchResult {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_research_results (
          id, query_id, query_text, depth, findings, synthesis,
          quality_assessment, knowledge_gaps, recommendations, sources_used,
          confidence_score, confidence_level, provenance,
          started_at, completed_at, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      )
      .run(
        id,
        result.queryId,
        result.queryText,
        result.depth,
        JSON.stringify(result.findings),
        JSON.stringify(result.synthesis),
        JSON.stringify(result.qualityAssessment),
        JSON.stringify(result.knowledgeGaps),
        JSON.stringify(result.recommendations),
        JSON.stringify(result.sourcesUsed),
        result.confidence.score,
        result.confidence.level,
        JSON.stringify(result.provenance),
        result.startedAt,
        result.completedAt,
        now,
      );

    this.recordChange(
      'research_result',
      id,
      'create',
      null,
      null,
      result.queryText,
      'Completed research',
    );

    return { ...result, id } as ResearchResult;
  }

  getResearchResults(queryId: string): ResearchResult[] {
    const rows = this.db
      .prepare(
        `SELECT * FROM strategic_research_results
         WHERE query_id = ?
         ORDER BY completed_at DESC`,
      )
      .all(queryId) as Record<string, unknown>[];

    return rows.map((row) => ({
      id: row.id as string,
      queryId: row.query_id as string,
      queryText: row.query_text as string,
      depth: row.depth as string,
      findings: JSON.parse(row.findings as string),
      synthesis: JSON.parse(row.synthesis as string),
      qualityAssessment: JSON.parse(row.quality_assessment as string),
      knowledgeGaps: JSON.parse(row.knowledge_gaps as string),
      recommendations: JSON.parse(row.recommendations as string),
      sourcesUsed: JSON.parse(row.sources_used as string),
      confidence: {
        score: row.confidence_score as number,
        level: row.confidence_level as ConfidenceLevel,
        factors: [],
      },
      provenance: JSON.parse(row.provenance as string),
      startedAt: row.started_at as string,
      completedAt: row.completed_at as string,
    })) as ResearchResult[];
  }

  saveExternalKnowledge(
    knowledge: Omit<ExternalKnowledge, 'id'>,
  ): ExternalKnowledge {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_external_knowledge (
          id, type, source, url, title, content, summary, key_points,
          applicability, confidence_score, authority, fetched_at, valid_until,
          related_contexts, related_decisions, tags, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      )
      .run(
        id,
        knowledge.type,
        knowledge.source,
        knowledge.url ?? null,
        knowledge.title,
        knowledge.content,
        knowledge.summary,
        JSON.stringify(knowledge.keyPoints),
        JSON.stringify(knowledge.applicability),
        knowledge.confidence.score,
        knowledge.authority,
        knowledge.fetchedAt,
        knowledge.validUntil ?? null,
        JSON.stringify(knowledge.relatedContexts),
        JSON.stringify(knowledge.relatedDecisions),
        JSON.stringify(knowledge.tags),
        now,
        now,
      );

    return { ...knowledge, id } as ExternalKnowledge;
  }

  // --------------------------------------------------------------------------
  // PRIORITIZATION CONFIG
  // --------------------------------------------------------------------------

  getPrioritizationConfig(): PrioritizationConfig | null {
    const row = this.db
      .prepare(
        `SELECT * FROM strategic_prioritization_config
         WHERE effective_until IS NULL
         ORDER BY version DESC
         LIMIT 1`,
      )
      .get() as Record<string, unknown> | undefined;

    if (!row) return null;

    return {
      weights: JSON.parse(row.weights as string),
      thresholds: JSON.parse(row.thresholds as string),
      decayConfig: JSON.parse(row.decay_config as string),
      rules: JSON.parse(row.rules as string),
    } as PrioritizationConfig;
  }

  savePrioritizationConfig(config: PrioritizationConfig): void {
    const now = new Date().toISOString();
    const id = randomUUID();

    // Invalidate current config
    this.db
      .prepare(
        `UPDATE strategic_prioritization_config
         SET effective_until = ?
         WHERE effective_until IS NULL`,
      )
      .run(now);

    // Get next version
    const maxVersion = (
      this.db
        .prepare('SELECT MAX(version) as max FROM strategic_prioritization_config')
        .get() as { max: number | null }
    ).max;
    const version = (maxVersion ?? 0) + 1;

    this.db
      .prepare(
        `INSERT INTO strategic_prioritization_config (
          id, version, weights, thresholds, decay_config, rules,
          effective_from, effective_until, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, NULL, ?, ?)`,
      )
      .run(
        id,
        version,
        JSON.stringify(config.weights),
        JSON.stringify(config.thresholds),
        JSON.stringify(config.decayConfig),
        JSON.stringify(config.rules),
        now,
        now,
        now,
      );

    this.recordChange(
      'prioritization_config',
      id,
      'create',
      null,
      null,
      `Version ${version}`,
      'Updated prioritization config',
    );
  }

  // --------------------------------------------------------------------------
  // WORK TEMPLATES
  // --------------------------------------------------------------------------

  getWorkTemplate(id: string): WorkTemplate | null {
    const row = this.db
      .prepare('SELECT * FROM strategic_work_templates WHERE id = ?')
      .get(id) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToWorkTemplate(row);
  }

  getWorkTemplateByName(name: string): WorkTemplate | null {
    const row = this.db
      .prepare('SELECT * FROM strategic_work_templates WHERE name = ?')
      .get(name) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToWorkTemplate(row);
  }

  getAllWorkTemplates(): WorkTemplate[] {
    const rows = this.db
      .prepare('SELECT * FROM strategic_work_templates ORDER BY usage_count DESC')
      .all() as Record<string, unknown>[];

    return rows.map((row) => this.rowToWorkTemplate(row));
  }

  saveWorkTemplate(
    template: Omit<WorkTemplate, 'id' | 'usageCount' | 'successRate'>,
  ): WorkTemplate {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_work_templates (
          id, name, description, work_type, default_title_pattern,
          default_description_pattern, suggested_steps, default_labels,
          default_effort, auto_triggers, usage_count, success_rate,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, NULL, ?, ?)`,
      )
      .run(
        id,
        template.name,
        template.description,
        template.workType,
        template.defaultTitlePattern,
        template.defaultDescriptionPattern,
        JSON.stringify(template.suggestedSteps),
        JSON.stringify(template.defaultLabels),
        JSON.stringify(template.defaultEffort),
        JSON.stringify(template.autoTriggers),
        now,
        now,
      );

    return { ...template, id, usageCount: 0, successRate: undefined } as WorkTemplate;
  }

  incrementTemplateUsage(id: string, success: boolean): void {
    const template = this.getWorkTemplate(id);
    if (!template) return;

    const newUsage = template.usageCount + 1;
    const currentSuccesses = template.successRate
      ? Math.round(template.successRate * template.usageCount)
      : 0;
    const newSuccessRate = (currentSuccesses + (success ? 1 : 0)) / newUsage;

    this.db
      .prepare(
        `UPDATE strategic_work_templates
         SET usage_count = ?, success_rate = ?, updated_at = ?
         WHERE id = ?`,
      )
      .run(newUsage, newSuccessRate, new Date().toISOString(), id);
  }

  private rowToWorkTemplate(row: Record<string, unknown>): WorkTemplate {
    return {
      id: row.id as string,
      name: row.name as string,
      description: row.description as string,
      workType: row.work_type as WorkPrimitiveType,
      defaultTitlePattern: row.default_title_pattern as string,
      defaultDescriptionPattern: row.default_description_pattern as string,
      suggestedSteps: JSON.parse(row.suggested_steps as string),
      defaultLabels: JSON.parse(row.default_labels as string),
      defaultEffort: JSON.parse(row.default_effort as string),
      autoTriggers: JSON.parse(row.auto_triggers as string),
      usageCount: row.usage_count as number,
      successRate: row.success_rate as number | undefined,
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    } as WorkTemplate;
  }

  // --------------------------------------------------------------------------
  // AUDIT TRAIL
  // --------------------------------------------------------------------------

  private recordChange(
    entityType: string,
    entityId: string,
    changeType: string,
    fieldName: string | null,
    oldValue: string | null,
    newValue: string | null,
    reason: string,
  ): void {
    const now = new Date().toISOString();
    const id = randomUUID();

    this.db
      .prepare(
        `INSERT INTO strategic_change_history (
          id, entity_type, entity_id, change_type, field_name,
          old_value, new_value, reason, changed_by, changed_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      )
      .run(
        id,
        entityType,
        entityId,
        changeType,
        fieldName,
        oldValue,
        newValue,
        reason,
        'system', // TODO: Track actual user/agent
        now,
      );
  }

  getChangeHistory(
    entityType: string,
    entityId: string,
    limit = 100,
  ): ChangeRecord[] {
    const rows = this.db
      .prepare(
        `SELECT * FROM strategic_change_history
         WHERE entity_type = ? AND entity_id = ?
         ORDER BY changed_at DESC
         LIMIT ?`,
      )
      .all(entityType, entityId, limit) as Record<string, unknown>[];

    return rows.map((row) => ({
      id: row.id as string,
      entityType: row.entity_type as string,
      entityId: row.entity_id as string,
      changeType: row.change_type as string,
      fieldName: row.field_name as string | undefined,
      oldValue: row.old_value as string | undefined,
      newValue: row.new_value as string | undefined,
      reason: row.reason as string,
      changedBy: row.changed_by as string,
      changedAt: row.changed_at as string,
    }));
  }

  // --------------------------------------------------------------------------
  // STATISTICS
  // --------------------------------------------------------------------------

  getStatistics(): {
    visionVersion: number;
    boundedContexts: number;
    workItems: { total: number; byStatus: Record<string, number>; byType: Record<string, number> };
    conceptualErrors: { total: number; unresolved: number; bySeverity: Record<string, number> };
    adrs: number;
    researchResults: number;
    externalKnowledge: number;
  } {
    const visionRow = this.db
      .prepare('SELECT MAX(version) as max FROM strategic_vision')
      .get() as { max: number | null };

    const contextCount = (
      this.db
        .prepare(
          'SELECT COUNT(*) as count FROM strategic_bounded_contexts WHERE valid_until IS NULL',
        )
        .get() as { count: number }
    ).count;

    const workTotal = (
      this.db
        .prepare('SELECT COUNT(*) as count FROM strategic_work_primitives')
        .get() as { count: number }
    ).count;

    const workByStatus = this.db
      .prepare(
        'SELECT status, COUNT(*) as count FROM strategic_work_primitives GROUP BY status',
      )
      .all() as { status: string; count: number }[];

    const workByType = this.db
      .prepare(
        'SELECT type, COUNT(*) as count FROM strategic_work_primitives GROUP BY type',
      )
      .all() as { type: string; count: number }[];

    const errorTotal = (
      this.db
        .prepare('SELECT COUNT(*) as count FROM strategic_conceptual_errors')
        .get() as { count: number }
    ).count;

    const errorUnresolved = (
      this.db
        .prepare(
          'SELECT COUNT(*) as count FROM strategic_conceptual_errors WHERE resolved_at IS NULL',
        )
        .get() as { count: number }
    ).count;

    const errorBySeverity = this.db
      .prepare(
        'SELECT severity, COUNT(*) as count FROM strategic_conceptual_errors GROUP BY severity',
      )
      .all() as { severity: string; count: number }[];

    const adrCount = (
      this.db
        .prepare('SELECT COUNT(*) as count FROM strategic_architecture_decisions')
        .get() as { count: number }
    ).count;

    const researchCount = (
      this.db
        .prepare('SELECT COUNT(*) as count FROM strategic_research_results')
        .get() as { count: number }
    ).count;

    const externalCount = (
      this.db
        .prepare('SELECT COUNT(*) as count FROM strategic_external_knowledge')
        .get() as { count: number }
    ).count;

    return {
      visionVersion: visionRow.max ?? 0,
      boundedContexts: contextCount,
      workItems: {
        total: workTotal,
        byStatus: Object.fromEntries(workByStatus.map((r) => [r.status, r.count])),
        byType: Object.fromEntries(workByType.map((r) => [r.type, r.count])),
      },
      conceptualErrors: {
        total: errorTotal,
        unresolved: errorUnresolved,
        bySeverity: Object.fromEntries(errorBySeverity.map((r) => [r.severity, r.count])),
      },
      adrs: adrCount,
      researchResults: researchCount,
      externalKnowledge: externalCount,
    };
  }

  // --------------------------------------------------------------------------
  // CLEANUP
  // --------------------------------------------------------------------------

  async close(): Promise<void> {
    this.db.close();
    this.initialized = false;
  }

  async vacuum(): Promise<void> {
    this.db.exec('VACUUM');
  }
}
