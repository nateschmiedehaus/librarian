/**
 * @fileoverview Strategic Context Manager
 *
 * High-level API for managing strategic knowledge including:
 * - Project Vision extraction and maintenance
 * - Bounded Context discovery and mapping
 * - Architecture Decision Records
 * - Cross-context consistency validation
 *
 * Follows research-first philosophy with confidence tracking.
 */

import { randomUUID } from 'crypto';
import type {
  ProjectVision,
  BoundedContext,
  ArchitectureDecision,
  ConfidenceLevel,
  ConfidenceAssessment,
  Provenance,
  QualityWeights,
  StrategicPillar,
  Constraint,
  TargetUser,
  SuccessCriterion,
  AntiPattern,
  Term,
  ContextRelationship,
  ContextHealth,
  ValidationResult,
  ValidationError,
  ValidationWarning,
  DEFAULT_QUALITY_WEIGHTS,
} from './types.js';
import type { StrategicStorage } from './storage.js';

// ============================================================================
// CONFIDENCE UTILITIES
// ============================================================================

/**
 * Compute confidence level from numeric score
 */
export function scoreToLevel(score: number): ConfidenceLevel {
  if (score >= 0.9) return 'verified';
  if (score >= 0.7) return 'established';
  if (score >= 0.5) return 'probable';
  if (score >= 0.3) return 'speculative';
  return 'unknown';
}

/**
 * Determine if research is recommended based on confidence
 */
export function shouldResearch(confidence: ConfidenceAssessment): {
  recommended: boolean;
  required: boolean;
  reason?: string;
} {
  if (confidence.level === 'unknown') {
    return { recommended: true, required: true, reason: 'No information available' };
  }
  if (confidence.level === 'speculative') {
    return { recommended: true, required: true, reason: 'LLM inference only, no authoritative source' };
  }
  if (confidence.level === 'probable') {
    return { recommended: true, required: false, reason: 'Single indirect source, verification advised' };
  }
  return { recommended: false, required: false };
}

/**
 * Create provenance record for system-generated content
 */
export function createSystemProvenance(method: string, sources: string[] = []): Provenance {
  return {
    source: 'system',
    method,
    timestamp: new Date().toISOString(),
    sources,
    verification: {
      verified: false,
    },
  };
}

/**
 * Create provenance record for user-provided content
 */
export function createUserProvenance(userId: string, sessionId?: string): Provenance {
  return {
    source: 'user',
    method: 'direct_input',
    timestamp: new Date().toISOString(),
    sources: [],
    verification: {
      verified: true,
      verifiedBy: userId,
      verifiedAt: new Date().toISOString(),
    },
    userId,
    sessionId,
  };
}

/**
 * Create provenance for research-derived content
 */
export function createResearchProvenance(
  researchId: string,
  sources: string[],
  confidenceScore: number,
): Provenance {
  return {
    source: 'research',
    method: 'external_research',
    timestamp: new Date().toISOString(),
    sources,
    verification: {
      verified: confidenceScore >= 0.7,
      verificationMethod: 'cross_reference',
    },
    researchId,
  };
}

// ============================================================================
// STRATEGIC CONTEXT MANAGER
// ============================================================================

export interface StrategicContextManagerOptions {
  /** Enable automatic validation on save */
  autoValidate?: boolean;
  /** Enable automatic research triggers */
  autoResearch?: boolean;
  /** Default confidence for new items */
  defaultConfidence?: number;
}

export interface VisionExtractionInput {
  /** Raw documentation content */
  documentation?: string;
  /** README content */
  readme?: string;
  /** Package.json or similar manifest */
  manifest?: Record<string, unknown>;
  /** Existing code patterns observed */
  codePatterns?: string[];
  /** User-provided mission statement */
  mission?: string;
  /** User-provided problem statement */
  problemStatement?: string;
}

export interface ContextDiscoveryInput {
  /** File paths and their purposes */
  filePaths: { path: string; purpose?: string }[];
  /** Import/export relationships */
  dependencies: { from: string; to: string; type: string }[];
  /** Identified modules */
  modules?: { name: string; files: string[]; description?: string }[];
}

export interface VisionValidationResult extends ValidationResult {
  suggestions?: {
    missingPillars?: string[];
    unclearConstraints?: string[];
    ambiguousUsers?: string[];
  };
}

/**
 * Strategic Context Manager
 *
 * Provides high-level operations for managing strategic knowledge
 * with built-in confidence tracking and research triggers.
 */
export class StrategicContextManager {
  private readonly storage: StrategicStorage;
  private readonly options: Required<StrategicContextManagerOptions>;

  constructor(
    storage: StrategicStorage,
    options: StrategicContextManagerOptions = {},
  ) {
    this.storage = storage;
    this.options = {
      autoValidate: options.autoValidate ?? true,
      autoResearch: options.autoResearch ?? false,
      defaultConfidence: options.defaultConfidence ?? 0.5,
    };
  }

  // --------------------------------------------------------------------------
  // PROJECT VISION
  // --------------------------------------------------------------------------

  /**
   * Get current project vision
   */
  getVision(): ProjectVision | null {
    return this.storage.getVision();
  }

  /**
   * Get vision history for temporal analysis
   */
  getVisionHistory(): ProjectVision[] {
    return this.storage.getVisionHistory();
  }

  /**
   * Extract and save project vision from various sources
   *
   * Uses confidence-weighted merging when multiple sources available.
   * Lower confidence sources are marked for research.
   */
  async extractVision(input: VisionExtractionInput): Promise<{
    vision: ProjectVision;
    confidence: ConfidenceAssessment;
    researchRecommendations: string[];
  }> {
    const researchRecommendations: string[] = [];
    const factors: { factor: string; score: number; weight: number }[] = [];

    // Extract mission
    let mission = input.mission ?? '';
    let missionConfidence = 0.3;
    if (input.mission) {
      missionConfidence = 0.9; // User-provided is high confidence
      factors.push({ factor: 'user_provided_mission', score: 0.9, weight: 0.3 });
    } else if (input.readme) {
      mission = this.extractMissionFromReadme(input.readme);
      missionConfidence = mission ? 0.6 : 0.2;
      factors.push({ factor: 'readme_extraction', score: missionConfidence, weight: 0.3 });
      if (missionConfidence < 0.5) {
        researchRecommendations.push('Clarify project mission statement');
      }
    } else {
      researchRecommendations.push('No mission statement found - research or user input required');
    }

    // Extract problem statement
    let problemStatement = input.problemStatement ?? '';
    let problemConfidence = 0.3;
    if (input.problemStatement) {
      problemConfidence = 0.9;
      factors.push({ factor: 'user_provided_problem', score: 0.9, weight: 0.2 });
    } else if (input.readme) {
      problemStatement = this.extractProblemFromReadme(input.readme);
      problemConfidence = problemStatement ? 0.5 : 0.2;
      factors.push({ factor: 'readme_problem_extraction', score: problemConfidence, weight: 0.2 });
    }

    // Extract target users
    const targetUsers: TargetUser[] = [];
    if (input.readme) {
      const users = this.extractUsersFromReadme(input.readme);
      targetUsers.push(...users);
    }
    if (targetUsers.length === 0) {
      researchRecommendations.push('Identify and document target users');
    }

    // Extract pillars and constraints
    const pillars = this.inferPillars(input);
    const constraints = this.inferConstraints(input);

    // Calculate overall confidence
    const overallScore = this.calculateWeightedConfidence(factors);
    const confidenceLevel = scoreToLevel(overallScore);

    const confidence: ConfidenceAssessment = {
      score: overallScore,
      level: confidenceLevel,
      factors,
      needsResearch: overallScore < 0.7,
      researchPriority: overallScore < 0.5 ? 'high' : overallScore < 0.7 ? 'medium' : 'low',
    };

    // Create vision object
    const vision = this.storage.saveVision({
      mission,
      problemStatement,
      valueProposition: this.inferValueProposition(mission, problemStatement),
      targetUsers,
      pillars,
      constraints,
      antiPatterns: [],
      successCriteria: [],
      qualityWeights: DEFAULT_QUALITY_WEIGHTS,
      confidence,
      provenance: createSystemProvenance('vision_extraction', [
        input.readme ? 'readme' : null,
        input.manifest ? 'manifest' : null,
        input.documentation ? 'documentation' : null,
      ].filter(Boolean) as string[]),
    });

    return { vision, confidence, researchRecommendations };
  }

  /**
   * Update vision with user-provided information
   *
   * User input has high confidence and can override extracted values.
   */
  updateVisionFromUser(
    updates: Partial<{
      mission: string;
      problemStatement: string;
      valueProposition: string;
      targetUsers: TargetUser[];
      pillars: StrategicPillar[];
      constraints: Constraint[];
      antiPatterns: AntiPattern[];
      successCriteria: SuccessCriterion[];
      qualityWeights: QualityWeights;
    }>,
    userId: string,
    sessionId?: string,
  ): ProjectVision {
    const current = this.getVision();
    if (!current) {
      throw new Error('No vision exists. Use extractVision first.');
    }

    // User updates get high confidence
    const newConfidence: ConfidenceAssessment = {
      score: 0.9,
      level: 'verified',
      factors: [
        { factor: 'user_verification', score: 0.9, weight: 1.0 },
        ...current.confidence.factors,
      ],
      needsResearch: false,
    };

    return this.storage.saveVision({
      ...current,
      ...updates,
      confidence: newConfidence,
      provenance: createUserProvenance(userId, sessionId),
    });
  }

  /**
   * Validate vision completeness and consistency
   */
  validateVision(vision?: ProjectVision): VisionValidationResult {
    const v = vision ?? this.getVision();
    if (!v) {
      return {
        valid: false,
        errors: [{ code: 'NO_VISION', message: 'No project vision defined' }],
        warnings: [],
      };
    }

    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    const suggestions: VisionValidationResult['suggestions'] = {};

    // Required fields
    if (!v.mission || v.mission.length < 10) {
      errors.push({ code: 'MISSING_MISSION', message: 'Mission statement is required and must be meaningful' });
    }

    if (!v.problemStatement || v.problemStatement.length < 20) {
      warnings.push({ code: 'WEAK_PROBLEM', message: 'Problem statement should clearly describe the problem being solved' });
    }

    // Target users
    if (v.targetUsers.length === 0) {
      errors.push({ code: 'NO_USERS', message: 'At least one target user must be defined' });
      suggestions.ambiguousUsers = ['developers', 'end-users', 'administrators'];
    }

    // Pillars
    if (v.pillars.length === 0) {
      warnings.push({ code: 'NO_PILLARS', message: 'Strategic pillars help guide decision-making' });
      suggestions.missingPillars = ['reliability', 'performance', 'maintainability', 'security'];
    }

    // Constraints
    const hasConstraints = v.constraints.length > 0;
    if (!hasConstraints) {
      warnings.push({ code: 'NO_CONSTRAINTS', message: 'Constraints help prevent scope creep and guide architecture' });
    }

    // Quality weights
    const totalWeight = Object.values(v.qualityWeights).reduce((a, b) => a + b, 0);
    if (Math.abs(totalWeight - 1.0) > 0.01) {
      warnings.push({ code: 'WEIGHTS_UNBALANCED', message: `Quality weights should sum to 1.0 (currently ${totalWeight.toFixed(2)})` });
    }

    // Confidence check
    if (v.confidence.score < 0.5) {
      warnings.push({
        code: 'LOW_CONFIDENCE',
        message: `Vision confidence is ${v.confidence.level}. Research recommended.`,
        suggestion: 'Verify vision elements through documentation review or stakeholder input',
      });
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      suggestions,
    };
  }

  // --------------------------------------------------------------------------
  // BOUNDED CONTEXTS
  // --------------------------------------------------------------------------

  /**
   * Get all bounded contexts
   */
  getBoundedContexts(): BoundedContext[] {
    return this.storage.getAllBoundedContexts();
  }

  /**
   * Get a specific bounded context
   */
  getBoundedContext(id: string): BoundedContext | null {
    return this.storage.getBoundedContext(id);
  }

  /**
   * Discover bounded contexts from codebase structure
   *
   * Uses file organization, import patterns, and naming conventions
   * to identify potential domain boundaries.
   */
  async discoverBoundedContexts(input: ContextDiscoveryInput): Promise<{
    contexts: BoundedContext[];
    confidence: ConfidenceAssessment;
    suggestions: string[];
  }> {
    const contexts: BoundedContext[] = [];
    const suggestions: string[] = [];

    // Group files by top-level directory
    const directoryClusters = this.clusterByDirectory(input.filePaths);

    // Analyze each cluster for context potential
    for (const [directory, files] of Object.entries(directoryClusters)) {
      // Skip common non-domain directories
      if (this.isInfrastructureDirectory(directory)) {
        continue;
      }

      // Extract potential terms from file names
      const terms = this.extractTermsFromFiles(files);

      // Calculate context confidence based on cohesion
      const cohesion = this.calculateCohesion(files, input.dependencies);
      const confidence: ConfidenceAssessment = {
        score: cohesion,
        level: scoreToLevel(cohesion),
        factors: [
          { factor: 'file_cohesion', score: cohesion, weight: 0.4 },
          { factor: 'naming_consistency', score: terms.length > 0 ? 0.6 : 0.3, weight: 0.3 },
          { factor: 'dependency_isolation', score: this.calculateIsolation(directory, input.dependencies), weight: 0.3 },
        ],
        needsResearch: cohesion < 0.7,
      };

      const context = this.storage.saveBoundedContext({
        name: this.directoryToContextName(directory),
        description: `Bounded context inferred from ${directory}`,
        boundaries: {
          includedPaths: files.map((f) => f.path),
          excludedPaths: [],
          boundaryRules: [],
        },
        ubiquitousLanguage: terms,
        relationships: [],
        ownership: {
          team: 'unknown',
          maintainers: [],
          decisionMakers: [],
        },
        implementation: {
          primaryLanguage: this.inferLanguage(files),
          frameworks: [],
          patterns: [],
          entryPoints: this.findEntryPoints(files),
        },
        externalDependencies: [],
        health: {
          overall: 'unknown',
          issues: [],
          lastAssessed: new Date().toISOString(),
        },
        confidence,
        provenance: createSystemProvenance('context_discovery', [directory]),
      });

      contexts.push(context);

      if (cohesion < 0.5) {
        suggestions.push(`Context "${context.name}" has low cohesion - consider splitting or verifying boundaries`);
      }
    }

    // Calculate overall discovery confidence
    const avgConfidence = contexts.length > 0
      ? contexts.reduce((sum, c) => sum + c.confidence.score, 0) / contexts.length
      : 0;

    return {
      contexts,
      confidence: {
        score: avgConfidence,
        level: scoreToLevel(avgConfidence),
        factors: [{ factor: 'discovery_average', score: avgConfidence, weight: 1.0 }],
        needsResearch: avgConfidence < 0.7,
      },
      suggestions,
    };
  }

  /**
   * Create a bounded context with user-provided information
   */
  createBoundedContext(
    input: {
      name: string;
      description: string;
      includedPaths: string[];
      excludedPaths?: string[];
      terms?: Array<{ term: string; definition: string }>;
      team?: string;
      maintainers?: string[];
    },
    userId: string,
  ): BoundedContext {
    const terms: Term[] = (input.terms ?? []).map((t) => ({
      term: t.term,
      definition: t.definition,
      examples: [],
      relatedTerms: [],
      confidence: { score: 0.9, level: 'verified', factors: [], needsResearch: false },
    }));

    return this.storage.saveBoundedContext({
      name: input.name,
      description: input.description,
      boundaries: {
        includedPaths: input.includedPaths,
        excludedPaths: input.excludedPaths ?? [],
        boundaryRules: [],
      },
      ubiquitousLanguage: terms,
      relationships: [],
      ownership: {
        team: input.team ?? 'unknown',
        maintainers: input.maintainers ?? [],
        decisionMakers: [],
      },
      implementation: {
        primaryLanguage: 'unknown',
        frameworks: [],
        patterns: [],
        entryPoints: [],
      },
      externalDependencies: [],
      health: {
        overall: 'unknown',
        issues: [],
        lastAssessed: new Date().toISOString(),
      },
      confidence: {
        score: 0.9,
        level: 'verified',
        factors: [{ factor: 'user_defined', score: 0.9, weight: 1.0 }],
        needsResearch: false,
      },
      provenance: createUserProvenance(userId),
    });
  }

  /**
   * Update bounded context
   */
  updateBoundedContext(
    id: string,
    updates: Partial<BoundedContext>,
  ): BoundedContext | null {
    return this.storage.updateBoundedContext(id, updates);
  }

  /**
   * Add relationship between contexts
   */
  addContextRelationship(
    sourceId: string,
    targetId: string,
    relationship: Omit<ContextRelationship, 'targetContextId'>,
  ): BoundedContext | null {
    const source = this.getBoundedContext(sourceId);
    const target = this.getBoundedContext(targetId);

    if (!source || !target) {
      return null;
    }

    const newRelationship: ContextRelationship = {
      ...relationship,
      targetContextId: targetId,
    };

    return this.updateBoundedContext(sourceId, {
      relationships: [...source.relationships, newRelationship],
    });
  }

  /**
   * Validate bounded context health
   */
  validateContext(context: BoundedContext): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];

    // Check boundaries
    if (context.boundaries.includedPaths.length === 0) {
      errors.push({ code: 'NO_PATHS', message: 'Context must include at least one path' });
    }

    // Check ubiquitous language
    if (context.ubiquitousLanguage.length === 0) {
      warnings.push({ code: 'NO_TERMS', message: 'Define domain terms for clearer communication' });
    }

    // Check ownership
    if (context.ownership.team === 'unknown') {
      warnings.push({ code: 'NO_OWNER', message: 'Assign team ownership for accountability' });
    }

    // Check confidence
    if (context.confidence.score < 0.5) {
      warnings.push({
        code: 'LOW_CONFIDENCE',
        message: `Context confidence is ${context.confidence.level}`,
        suggestion: 'Review and verify context boundaries',
      });
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  // --------------------------------------------------------------------------
  // ARCHITECTURE DECISION RECORDS
  // --------------------------------------------------------------------------

  /**
   * Get all ADRs
   */
  getArchitectureDecisions(): ArchitectureDecision[] {
    return this.storage.queryArchitectureDecisions();
  }

  /**
   * Get a specific ADR
   */
  getArchitectureDecision(id: string): ArchitectureDecision | null {
    return this.storage.getArchitectureDecision(id);
  }

  /**
   * Create a new ADR
   */
  createArchitectureDecision(
    input: {
      title: string;
      context: string;
      decision: string;
      rationale: string;
      alternatives?: Array<{
        title: string;
        description: string;
        prosAndCons: { pros: string[]; cons: string[] };
        rejectionReason?: string;
      }>;
      consequences?: Array<{
        description: string;
        type: 'positive' | 'negative' | 'neutral';
        mitigations?: string[];
      }>;
      affectedContextIds?: string[];
    },
    decidedBy: string,
  ): ArchitectureDecision {
    return this.storage.saveArchitectureDecision({
      title: input.title,
      status: 'proposed',
      context: input.context,
      decision: input.decision,
      rationale: input.rationale,
      alternatives: input.alternatives ?? [],
      consequences: input.consequences ?? [],
      risks: [],
      affectedContexts: input.affectedContextIds ?? [],
      confidence: {
        score: 0.7,
        level: 'established',
        factors: [{ factor: 'documented_decision', score: 0.7, weight: 1.0 }],
        needsResearch: false,
      },
      provenance: createUserProvenance(decidedBy),
      decidedBy,
      decidedAt: new Date().toISOString(),
    });
  }

  /**
   * Accept/approve an ADR
   */
  acceptDecision(id: string, approvedBy: string): ArchitectureDecision | null {
    const adr = this.getArchitectureDecision(id);
    if (!adr) return null;

    // Update to accepted status with higher confidence
    const updated = {
      ...adr,
      status: 'accepted' as const,
      confidence: {
        ...adr.confidence,
        score: 0.9,
        level: 'verified' as ConfidenceLevel,
        factors: [
          ...adr.confidence.factors,
          { factor: 'explicitly_accepted', score: 0.9, weight: 0.5 },
        ],
      },
      provenance: {
        ...adr.provenance,
        verification: {
          verified: true,
          verifiedBy: approvedBy,
          verifiedAt: new Date().toISOString(),
        },
      },
    };

    return this.storage.saveArchitectureDecision(updated);
  }

  /**
   * Supersede an ADR with a new one
   */
  supersedeDecision(
    oldId: string,
    newDecision: Parameters<typeof this.createArchitectureDecision>[0],
    decidedBy: string,
  ): { superseded: ArchitectureDecision; new: ArchitectureDecision } | null {
    const old = this.getArchitectureDecision(oldId);
    if (!old) return null;

    // Create new decision
    const newAdr = this.createArchitectureDecision(newDecision, decidedBy);

    // Update old decision
    const superseded = this.storage.saveArchitectureDecision({
      ...old,
      status: 'superseded',
      supersededBy: newAdr.id,
    });

    // Update new decision to reference old
    const updated = this.storage.saveArchitectureDecision({
      ...newAdr,
      supersedes: oldId,
    });

    return { superseded, new: updated };
  }

  // --------------------------------------------------------------------------
  // CROSS-CUTTING CONCERNS
  // --------------------------------------------------------------------------

  /**
   * Check consistency between vision and contexts
   */
  validateAlignment(): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];

    const vision = this.getVision();
    const contexts = this.getBoundedContexts();

    if (!vision) {
      errors.push({ code: 'NO_VISION', message: 'Cannot validate alignment without project vision' });
      return { valid: false, errors, warnings };
    }

    // Check that all strategic pillars have supporting contexts
    for (const pillar of vision.pillars) {
      const supportingContexts = contexts.filter((c) =>
        c.description.toLowerCase().includes(pillar.name.toLowerCase()) ||
        c.name.toLowerCase().includes(pillar.name.toLowerCase()),
      );

      if (supportingContexts.length === 0) {
        warnings.push({
          code: 'ORPHAN_PILLAR',
          message: `Strategic pillar "${pillar.name}" has no clearly supporting bounded context`,
          suggestion: 'Consider creating a context or documenting how existing contexts support this pillar',
        });
      }
    }

    // Check for orphan contexts (not supporting any pillar)
    for (const context of contexts) {
      const supportsPillar = vision.pillars.some(
        (p) =>
          context.description.toLowerCase().includes(p.name.toLowerCase()) ||
          context.name.toLowerCase().includes(p.name.toLowerCase()),
      );

      if (!supportsPillar && context.confidence.score >= 0.5) {
        warnings.push({
          code: 'ORPHAN_CONTEXT',
          message: `Context "${context.name}" doesn't clearly support any strategic pillar`,
          suggestion: 'Document how this context contributes to the project mission',
        });
      }
    }

    // Check context relationships for consistency
    for (const context of contexts) {
      for (const rel of context.relationships) {
        const target = contexts.find((c) => c.id === rel.targetContextId);
        if (!target) {
          errors.push({
            code: 'BROKEN_RELATIONSHIP',
            message: `Context "${context.name}" references non-existent context`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Get research recommendations based on current knowledge gaps
   */
  getResearchRecommendations(): Array<{
    area: string;
    priority: 'high' | 'medium' | 'low';
    reason: string;
    suggestedQueries: string[];
  }> {
    const recommendations: Array<{
      area: string;
      priority: 'high' | 'medium' | 'low';
      reason: string;
      suggestedQueries: string[];
    }> = [];

    // Check vision confidence
    const vision = this.getVision();
    if (vision) {
      const research = shouldResearch(vision.confidence);
      if (research.recommended) {
        recommendations.push({
          area: 'Project Vision',
          priority: research.required ? 'high' : 'medium',
          reason: research.reason ?? 'Low confidence in vision understanding',
          suggestedQueries: [
            `What is the primary purpose of ${vision.mission}`,
            `Who are the target users for projects solving "${vision.problemStatement}"`,
            `Best practices for ${vision.pillars.map((p) => p.name).join(', ')}`,
          ],
        });
      }
    } else {
      recommendations.push({
        area: 'Project Vision',
        priority: 'high',
        reason: 'No project vision defined',
        suggestedQueries: ['Project documentation', 'README analysis', 'Stakeholder interviews'],
      });
    }

    // Check context confidence
    const contexts = this.getBoundedContexts();
    for (const context of contexts) {
      const research = shouldResearch(context.confidence);
      if (research.recommended) {
        recommendations.push({
          area: `Bounded Context: ${context.name}`,
          priority: research.required ? 'high' : 'medium',
          reason: research.reason ?? 'Low confidence in context boundaries',
          suggestedQueries: [
            `Domain-driven design patterns for ${context.name}`,
            `Best practices for ${context.implementation.primaryLanguage} ${context.name} architecture`,
          ],
        });
      }

      // Check for undefined terms
      if (context.ubiquitousLanguage.length === 0) {
        recommendations.push({
          area: `Domain Terms: ${context.name}`,
          priority: 'medium',
          reason: 'No ubiquitous language defined',
          suggestedQueries: [
            `Domain terminology for ${context.name}`,
            `${context.name} glossary`,
          ],
        });
      }
    }

    // Sort by priority
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);

    return recommendations;
  }

  // --------------------------------------------------------------------------
  // PRIVATE HELPERS
  // --------------------------------------------------------------------------

  private extractMissionFromReadme(readme: string): string {
    // Look for common patterns
    const patterns = [
      /^#\s+.*\n\n([^#\n]+)/m, // First paragraph after title
      /## (?:About|Overview|Introduction)\n+([^#]+)/im,
      /(?:^|\n)>([^<\n]+)/m, // Blockquote
    ];

    for (const pattern of patterns) {
      const match = readme.match(pattern);
      if (match?.[1]) {
        const text = match[1].trim();
        if (text.length > 20 && text.length < 500) {
          return text;
        }
      }
    }

    return '';
  }

  private extractProblemFromReadme(readme: string): string {
    const patterns = [
      /## (?:Problem|Why|Motivation)\n+([^#]+)/im,
      /(?:solves?|addresses?|tackles?)\s+(?:the\s+)?(?:problem\s+of\s+)?([^.!?]+[.!?])/i,
    ];

    for (const pattern of patterns) {
      const match = readme.match(pattern);
      if (match?.[1]) {
        return match[1].trim();
      }
    }

    return '';
  }

  private extractUsersFromReadme(readme: string): TargetUser[] {
    const users: TargetUser[] = [];
    const patterns = [
      /(?:for|designed for|built for|helps?)\s+([a-z\s]+(?:developers?|engineers?|teams?|users?))/gi,
    ];

    for (const pattern of patterns) {
      const matches = readme.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) {
          users.push({
            id: randomUUID(),
            name: match[1].trim(),
            description: '',
            needs: [],
            painPoints: [],
            confidence: { score: 0.5, level: 'probable', factors: [], needsResearch: true },
          });
        }
      }
    }

    return users;
  }

  private inferPillars(input: VisionExtractionInput): StrategicPillar[] {
    const pillars: StrategicPillar[] = [];
    const text = [input.readme, input.documentation].filter(Boolean).join(' ').toLowerCase();

    const pillarKeywords: Record<string, string[]> = {
      reliability: ['reliable', 'robust', 'stable', 'fault-tolerant', 'resilient'],
      performance: ['fast', 'performant', 'efficient', 'optimized', 'scalable'],
      security: ['secure', 'safe', 'protected', 'encrypted', 'authenticated'],
      maintainability: ['maintainable', 'clean', 'modular', 'testable', 'documented'],
      usability: ['easy', 'intuitive', 'user-friendly', 'simple', 'accessible'],
    };

    for (const [pillar, keywords] of Object.entries(pillarKeywords)) {
      const matches = keywords.filter((k) => text.includes(k));
      if (matches.length > 0) {
        pillars.push({
          id: randomUUID(),
          name: pillar,
          description: `Emphasis on ${pillar} based on documentation`,
          rationale: `Keywords found: ${matches.join(', ')}`,
          metrics: [],
          confidence: {
            score: Math.min(0.3 + matches.length * 0.1, 0.7),
            level: matches.length > 2 ? 'probable' : 'speculative',
            factors: [{ factor: 'keyword_matching', score: matches.length * 0.15, weight: 1.0 }],
            needsResearch: true,
          },
        });
      }
    }

    return pillars;
  }

  private inferConstraints(input: VisionExtractionInput): Constraint[] {
    const constraints: Constraint[] = [];

    // Check manifest for constraints
    if (input.manifest) {
      const engines = (input.manifest as { engines?: Record<string, string> }).engines;
      if (engines) {
        for (const [engine, version] of Object.entries(engines)) {
          constraints.push({
            id: randomUUID(),
            name: `${engine} version`,
            description: `Requires ${engine} ${version}`,
            type: 'technical',
            rationale: 'Defined in package manifest',
            impact: 'Limits runtime environment compatibility',
            exceptions: [],
            confidence: {
              score: 0.95,
              level: 'verified',
              factors: [{ factor: 'manifest_defined', score: 0.95, weight: 1.0 }],
              needsResearch: false,
            },
          });
        }
      }
    }

    return constraints;
  }

  private inferValueProposition(mission: string, problem: string): string {
    if (mission && problem) {
      return `${mission} by addressing ${problem}`;
    }
    return mission || problem || 'Value proposition not yet defined';
  }

  private calculateWeightedConfidence(
    factors: Array<{ factor: string; score: number; weight: number }>,
  ): number {
    if (factors.length === 0) return 0.3;

    const totalWeight = factors.reduce((sum, f) => sum + f.weight, 0);
    const weightedSum = factors.reduce((sum, f) => sum + f.score * f.weight, 0);

    return totalWeight > 0 ? weightedSum / totalWeight : 0.3;
  }

  private clusterByDirectory(
    files: Array<{ path: string; purpose?: string }>,
  ): Record<string, Array<{ path: string; purpose?: string }>> {
    const clusters: Record<string, Array<{ path: string; purpose?: string }>> = {};

    for (const file of files) {
      const parts = file.path.split('/');
      const topDir = parts.length > 1 ? parts[0] : '.';

      if (!clusters[topDir]) {
        clusters[topDir] = [];
      }
      clusters[topDir].push(file);
    }

    return clusters;
  }

  private isInfrastructureDirectory(directory: string): boolean {
    const infraDirs = [
      'node_modules',
      '.git',
      'dist',
      'build',
      'coverage',
      '__pycache__',
      '.venv',
      'vendor',
      'target',
    ];
    return infraDirs.includes(directory.toLowerCase());
  }

  private extractTermsFromFiles(files: Array<{ path: string; purpose?: string }>): Term[] {
    const terms: Term[] = [];
    const wordCounts: Record<string, number> = {};

    for (const file of files) {
      // Extract words from path
      const pathWords = file.path
        .replace(/[^a-zA-Z]/g, ' ')
        .split(/\s+/)
        .filter((w) => w.length > 2);

      for (const word of pathWords) {
        const lower = word.toLowerCase();
        wordCounts[lower] = (wordCounts[lower] ?? 0) + 1;
      }
    }

    // Terms that appear in multiple files
    for (const [word, count] of Object.entries(wordCounts)) {
      if (count >= 2 && word.length > 3) {
        terms.push({
          term: word,
          definition: `Common term appearing in ${count} files`,
          examples: [],
          relatedTerms: [],
          confidence: {
            score: Math.min(0.3 + count * 0.05, 0.6),
            level: 'speculative',
            factors: [{ factor: 'frequency', score: count * 0.1, weight: 1.0 }],
            needsResearch: true,
          },
        });
      }
    }

    return terms.slice(0, 20); // Limit to top 20
  }

  private calculateCohesion(
    files: Array<{ path: string; purpose?: string }>,
    dependencies: Array<{ from: string; to: string; type: string }>,
  ): number {
    if (files.length <= 1) return 1.0;

    const filePaths = new Set(files.map((f) => f.path));

    // Count internal vs external dependencies
    let internal = 0;
    let external = 0;

    for (const dep of dependencies) {
      const fromIn = filePaths.has(dep.from);
      const toIn = filePaths.has(dep.to);

      if (fromIn && toIn) {
        internal++;
      } else if (fromIn || toIn) {
        external++;
      }
    }

    const total = internal + external;
    if (total === 0) return 0.5; // No dependency info

    return internal / total;
  }

  private calculateIsolation(
    directory: string,
    dependencies: Array<{ from: string; to: string; type: string }>,
  ): number {
    let crossingIn = 0;
    let crossingOut = 0;

    for (const dep of dependencies) {
      const fromInDir = dep.from.startsWith(directory);
      const toInDir = dep.to.startsWith(directory);

      if (fromInDir && !toInDir) crossingOut++;
      if (!fromInDir && toInDir) crossingIn++;
    }

    const total = crossingIn + crossingOut;
    if (total === 0) return 0.8; // No crossing = good isolation

    // Lower score for more crossings
    return Math.max(0.2, 1 - total * 0.05);
  }

  private directoryToContextName(directory: string): string {
    return directory
      .replace(/[_-]/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .split(' ')
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
      .join(' ');
  }

  private inferLanguage(files: Array<{ path: string; purpose?: string }>): string {
    const extensions: Record<string, number> = {};

    for (const file of files) {
      const ext = file.path.split('.').pop()?.toLowerCase() ?? '';
      extensions[ext] = (extensions[ext] ?? 0) + 1;
    }

    const languageMap: Record<string, string> = {
      ts: 'TypeScript',
      tsx: 'TypeScript',
      js: 'JavaScript',
      jsx: 'JavaScript',
      py: 'Python',
      rb: 'Ruby',
      go: 'Go',
      rs: 'Rust',
      java: 'Java',
      kt: 'Kotlin',
      cs: 'C#',
      cpp: 'C++',
      c: 'C',
    };

    let maxCount = 0;
    let primaryExt = '';
    for (const [ext, count] of Object.entries(extensions)) {
      if (count > maxCount && languageMap[ext]) {
        maxCount = count;
        primaryExt = ext;
      }
    }

    return languageMap[primaryExt] ?? 'unknown';
  }

  private findEntryPoints(files: Array<{ path: string; purpose?: string }>): string[] {
    const entryPatterns = [
      /index\.[jt]sx?$/,
      /main\.[jt]sx?$/,
      /app\.[jt]sx?$/,
      /__init__\.py$/,
      /mod\.rs$/,
    ];

    return files
      .filter((f) => entryPatterns.some((p) => p.test(f.path)))
      .map((f) => f.path);
  }
}
