/**
 * @fileoverview Work Primitives Manager
 *
 * High-level API for managing composable work items including:
 * - Epic/Story/Task/Step hierarchy creation and management
 * - Template-based work item creation
 * - Dependency tracking and cycle detection
 * - Progress tracking with evidence
 * - Work decomposition and aggregation
 *
 * Design principles:
 * - Every work item has clear acceptance criteria
 * - Evidence-based completion verification
 * - Full traceability from requirements to implementation
 * - Intelligent decomposition suggestions
 */

import { randomUUID } from 'crypto';
import type {
  WorkPrimitive,
  WorkPrimitiveType,
  WorkStatus,
  AcceptanceCriterion,
  WorkDependency,
  WorkTraceability,
  ComputedPriority,
  ImpactAssessment,
  EffortEstimate,
  WorkEvidence,
  WorkLabel,
  WorkTemplate,
  WorkReport,
  WorkMetrics,
  StatusChange,
  WorkChange,
  Note,
  DecomposeOptions,
  TransitionOptions,
} from './work_primitives.js';
import type { ConfidenceAssessment } from './types.js';
import type { StrategicStorage, WorkQueryOptions } from './storage.js';
import { createSystemProvenance, createUserProvenance, scoreToLevel } from './strategic_context.js';

// ============================================================================
// WORK MANAGER TYPES
// ============================================================================

export interface WorkManagerOptions {
  /** Enable automatic parent status updates */
  autoUpdateParentStatus?: boolean;
  /** Enable dependency validation on status changes */
  validateDependencies?: boolean;
  /** Default effort for new items */
  defaultEffort?: Partial<EffortEstimate>;
}

export interface CreateWorkInput {
  type: WorkPrimitiveType;
  title: string;
  description: string;
  rationale?: string;
  acceptanceCriteria?: Array<{
    description: string;
    verificationMethod?: string;
  }>;
  parentId?: string;
  contextId?: string;
  labels?: string[];
  dependencies?: Array<{
    dependsOnId: string;
    type: 'blocks' | 'requires' | 'relates_to';
    isBlocking?: boolean;
  }>;
  effort?: Partial<EffortEstimate>;
  deadline?: string;
}

export interface DecomposeResult {
  parent: WorkPrimitive;
  children: WorkPrimitive[];
  suggestions: string[];
}

export interface WorkProgressSummary {
  totalItems: number;
  completed: number;
  inProgress: number;
  blocked: number;
  pending: number;
  completionRate: number;
  estimatedRemaining: {
    items: number;
    effort: EffortEstimate | null;
  };
}

// ============================================================================
// WORK MANAGER IMPLEMENTATION
// ============================================================================

/**
 * Work Primitives Manager
 *
 * Provides comprehensive work item management with:
 * - Hierarchical organization (Epic → Story → Task → Step)
 * - Template-based creation for consistency
 * - Intelligent decomposition suggestions
 * - Evidence-based progress tracking
 */
export class WorkManager {
  private readonly storage: StrategicStorage;
  private readonly options: Required<WorkManagerOptions>;

  constructor(
    storage: StrategicStorage,
    options: WorkManagerOptions = {},
  ) {
    this.storage = storage;
    this.options = {
      autoUpdateParentStatus: options.autoUpdateParentStatus ?? true,
      validateDependencies: options.validateDependencies ?? true,
      defaultEffort: options.defaultEffort ?? {
        complexity: 'medium',
        size: 'medium',
      },
    };
  }

  // --------------------------------------------------------------------------
  // WORK ITEM CRUD
  // --------------------------------------------------------------------------

  /**
   * Create a new work item
   */
  create(input: CreateWorkInput, createdBy?: string): WorkPrimitive {
    const now = new Date().toISOString();

    // Build acceptance criteria
    const acceptanceCriteria: AcceptanceCriterion[] = (input.acceptanceCriteria ?? []).map(
      (ac) => ({
        id: randomUUID(),
        description: ac.description,
        verificationMethod: ac.verificationMethod
          ? { type: ac.verificationMethod as 'manual' | 'automated' | 'review', details: '' }
          : { type: 'manual', details: '' },
        isMet: false,
        confidence: { score: 0.5, level: 'probable', factors: [], needsResearch: false },
      }),
    );

    // Build dependencies
    const dependencies: WorkDependency[] = (input.dependencies ?? []).map((dep) => ({
      dependsOnId: dep.dependsOnId,
      type: dep.type,
      description: '',
      isBlocking: dep.isBlocking ?? dep.type === 'blocks',
      status: 'pending',
      createdAt: now,
    }));

    // Build labels
    const labels: WorkLabel[] = (input.labels ?? []).map((label) => ({
      name: label,
      color: this.getLabelColor(label),
      description: '',
    }));

    // Default effort
    const effort: EffortEstimate = {
      complexity: input.effort?.complexity ?? this.options.defaultEffort.complexity ?? 'medium',
      size: input.effort?.size ?? this.options.defaultEffort.size ?? 'medium',
      confidence: { score: 0.5, level: 'probable', factors: [], needsResearch: false },
    };

    // Initial priority (will be recomputed by prioritization engine)
    const priority: ComputedPriority = {
      score: 0.5,
      level: 'medium',
      factors: [],
      computedAt: now,
    };

    // Initial impact assessment
    const impact: ImpactAssessment = {
      level: 'medium',
      affectedAreas: [],
      cascadeEffects: [],
      reversibility: 'easily_reversible',
      confidence: { score: 0.5, level: 'probable', factors: [], needsResearch: false },
    };

    // Initial traceability
    const traceability: WorkTraceability = {
      requirements: [],
      affectedFiles: [],
      externalRefs: [],
      tests: [],
    };

    // Status history
    const statusHistory: StatusChange[] = [
      {
        from: null,
        to: 'draft',
        changedAt: now,
        changedBy: createdBy ?? 'system',
        reason: 'Created',
      },
    ];

    // Timing
    const timing = {
      createdAt: now,
      deadline: input.deadline
        ? { date: input.deadline, type: 'soft' as const }
        : undefined,
    };

    const work = this.storage.saveWorkPrimitive({
      type: input.type,
      title: input.title,
      description: input.description,
      rationale: input.rationale,
      acceptanceCriteria,
      notes: [],
      parentId: input.parentId ?? null,
      childIds: [],
      contextId: input.contextId,
      dependencies,
      traceability,
      priority,
      impact,
      effort,
      status: 'draft',
      statusHistory,
      timing,
      evidence: [],
      labels,
      changeHistory: [],
      confidence: {
        score: 0.7,
        level: 'established',
        factors: [{ factor: 'user_created', score: 0.7, weight: 1.0 }],
        needsResearch: false,
      },
      provenance: createdBy ? createUserProvenance(createdBy) : createSystemProvenance('work_creation'),
    });

    return work;
  }

  /**
   * Get a work item by ID
   */
  get(id: string): WorkPrimitive | null {
    return this.storage.getWorkPrimitive(id);
  }

  /**
   * Query work items
   */
  query(options: WorkQueryOptions = {}): WorkPrimitive[] {
    return this.storage.queryWorkPrimitives(options);
  }

  /**
   * Update a work item
   */
  update(
    id: string,
    updates: Partial<Pick<
      WorkPrimitive,
      'title' | 'description' | 'rationale' | 'acceptanceCriteria' |
      'labels' | 'effort' | 'impact' | 'traceability'
    >>,
    updatedBy?: string,
  ): WorkPrimitive | null {
    const existing = this.get(id);
    if (!existing) return null;

    const now = new Date().toISOString();

    // Record changes
    const changes: WorkChange[] = [];
    for (const [field, newValue] of Object.entries(updates)) {
      const oldValue = existing[field as keyof WorkPrimitive];
      if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
        changes.push({
          field,
          oldValue: JSON.stringify(oldValue),
          newValue: JSON.stringify(newValue),
          changedAt: now,
          changedBy: updatedBy ?? 'system',
        });
      }
    }

    return this.storage.updateWorkPrimitive(id, {
      ...updates,
      changeHistory: [...existing.changeHistory, ...changes],
    });
  }

  /**
   * Delete a work item
   */
  delete(id: string): boolean {
    return this.storage.deleteWorkPrimitive(id);
  }

  // --------------------------------------------------------------------------
  // STATUS MANAGEMENT
  // --------------------------------------------------------------------------

  /**
   * Transition work item to a new status
   */
  transition(
    id: string,
    newStatus: WorkStatus,
    options: TransitionOptions = {},
  ): { success: boolean; work?: WorkPrimitive; errors?: string[] } {
    const work = this.get(id);
    if (!work) {
      return { success: false, errors: ['Work item not found'] };
    }

    // Validate transition
    const validation = this.validateTransition(work, newStatus);
    if (!validation.valid) {
      if (!options.force) {
        return { success: false, errors: validation.errors };
      }
    }

    // Check dependencies if transitioning to in_progress or completed
    if (
      this.options.validateDependencies &&
      (newStatus === 'in_progress' || newStatus === 'completed')
    ) {
      const blockingDeps = this.getBlockingDependencies(work);
      if (blockingDeps.length > 0 && !options.force) {
        return {
          success: false,
          errors: [
            `Blocked by ${blockingDeps.length} dependencies: ${blockingDeps.map((d) => d.dependsOnId).join(', ')}`,
          ],
        };
      }
    }

    const now = new Date().toISOString();

    // Update status
    const statusChange: StatusChange = {
      from: work.status,
      to: newStatus,
      changedAt: now,
      changedBy: options.changedBy ?? 'system',
      reason: options.reason,
    };

    const updated = this.storage.updateWorkPrimitive(id, {
      status: newStatus,
      statusHistory: [...work.statusHistory, statusChange],
    });

    if (!updated) {
      return { success: false, errors: ['Failed to update work item'] };
    }

    // Update parent status if needed
    if (this.options.autoUpdateParentStatus && work.parentId) {
      this.updateParentStatus(work.parentId);
    }

    // Update dependent items
    this.updateDependentStatuses(id, newStatus);

    return { success: true, work: updated };
  }

  /**
   * Mark work item as completed with evidence
   */
  complete(
    id: string,
    evidence: Array<{
      type: 'test_pass' | 'code_review' | 'manual_verification' | 'automated_check' | 'documentation';
      description: string;
      artifactPath?: string;
    }>,
    completedBy?: string,
  ): { success: boolean; work?: WorkPrimitive; errors?: string[] } {
    const work = this.get(id);
    if (!work) {
      return { success: false, errors: ['Work item not found'] };
    }

    // Check acceptance criteria
    const unmetCriteria = work.acceptanceCriteria.filter((ac) => !ac.isMet);
    if (unmetCriteria.length > 0) {
      return {
        success: false,
        errors: [
          `${unmetCriteria.length} acceptance criteria not met`,
          ...unmetCriteria.map((ac) => `- ${ac.description}`),
        ],
      };
    }

    const now = new Date().toISOString();

    // Add evidence
    const newEvidence: WorkEvidence[] = evidence.map((e) => ({
      id: randomUUID(),
      type: e.type,
      description: e.description,
      artifactPath: e.artifactPath,
      collectedAt: now,
      collectedBy: completedBy ?? 'system',
      confidence: { score: 0.9, level: 'verified', factors: [], needsResearch: false },
    }));

    // Update work item
    const updated = this.storage.updateWorkPrimitive(id, {
      evidence: [...work.evidence, ...newEvidence],
    });

    if (!updated) {
      return { success: false, errors: ['Failed to add evidence'] };
    }

    // Transition to completed
    return this.transition(id, 'completed', {
      changedBy: completedBy,
      reason: 'All acceptance criteria met with evidence',
    });
  }

  /**
   * Block a work item
   */
  block(id: string, reason: string, blockedBy?: string): WorkPrimitive | null {
    const work = this.get(id);
    if (!work) return null;

    const now = new Date().toISOString();

    // Add blocking note
    const note: Note = {
      id: randomUUID(),
      content: `BLOCKED: ${reason}`,
      author: blockedBy ?? 'system',
      createdAt: now,
      type: 'blocker',
    };

    this.storage.updateWorkPrimitive(id, {
      notes: [...work.notes, note],
    });

    const result = this.transition(id, 'blocked', {
      changedBy: blockedBy,
      reason,
    });

    return result.work ?? null;
  }

  // --------------------------------------------------------------------------
  // HIERARCHY MANAGEMENT
  // --------------------------------------------------------------------------

  /**
   * Get work hierarchy from a root item
   */
  getHierarchy(rootId?: string): WorkPrimitive[] {
    return this.storage.getWorkHierarchy(rootId);
  }

  /**
   * Get children of a work item
   */
  getChildren(parentId: string): WorkPrimitive[] {
    return this.query({ parentId });
  }

  /**
   * Get parent chain of a work item
   */
  getParentChain(id: string): WorkPrimitive[] {
    const chain: WorkPrimitive[] = [];
    let current = this.get(id);

    while (current?.parentId) {
      const parent = this.get(current.parentId);
      if (parent) {
        chain.push(parent);
        current = parent;
      } else {
        break;
      }
    }

    return chain;
  }

  /**
   * Move work item to a new parent
   */
  move(id: string, newParentId: string | null): WorkPrimitive | null {
    const work = this.get(id);
    if (!work) return null;

    // Validate new parent
    if (newParentId) {
      const newParent = this.get(newParentId);
      if (!newParent) return null;

      // Prevent circular hierarchy
      const parentChain = this.getParentChain(newParentId);
      if (parentChain.some((p) => p.id === id)) {
        throw new Error('Cannot create circular hierarchy');
      }
    }

    return this.storage.updateWorkPrimitive(id, { parentId: newParentId });
  }

  /**
   * Decompose a work item into smaller items
   */
  decompose(
    id: string,
    children: Array<Omit<CreateWorkInput, 'parentId'>>,
    options: DecomposeOptions = {},
  ): DecomposeResult {
    const parent = this.get(id);
    if (!parent) {
      throw new Error('Work item not found');
    }

    // Infer child type based on parent type
    const childType = this.inferChildType(parent.type);

    const createdChildren: WorkPrimitive[] = [];
    const suggestions: string[] = [];

    for (const child of children) {
      const created = this.create({
        ...child,
        type: child.type ?? childType,
        parentId: id,
        contextId: child.contextId ?? parent.contextId,
      });
      createdChildren.push(created);
    }

    // Add suggestions based on decomposition
    if (createdChildren.length === 1) {
      suggestions.push('Consider if single-child decomposition is necessary');
    }
    if (createdChildren.length > 10) {
      suggestions.push('Many children - consider grouping into intermediate items');
    }

    // Check for uneven effort distribution
    const efforts = createdChildren.map((c) => this.effortToNumber(c.effort));
    const avgEffort = efforts.reduce((a, b) => a + b, 0) / efforts.length;
    const maxEffort = Math.max(...efforts);
    if (maxEffort > avgEffort * 2) {
      suggestions.push('Effort distribution is uneven - consider further decomposing large items');
    }

    // Update parent status if needed
    if (parent.status === 'draft' && options.startProgress) {
      this.transition(id, 'planned');
    }

    return {
      parent: this.get(id)!, // Refresh
      children: createdChildren,
      suggestions,
    };
  }

  /**
   * Get decomposition suggestions for a work item
   */
  suggestDecomposition(id: string): {
    suggestedChildren: Array<Partial<CreateWorkInput>>;
    rationale: string[];
  } {
    const work = this.get(id);
    if (!work) {
      return { suggestedChildren: [], rationale: ['Work item not found'] };
    }

    const suggestedChildren: Array<Partial<CreateWorkInput>> = [];
    const rationale: string[] = [];

    // Based on acceptance criteria
    if (work.acceptanceCriteria.length > 3) {
      rationale.push('Many acceptance criteria suggest decomposition');
      for (const ac of work.acceptanceCriteria) {
        suggestedChildren.push({
          type: this.inferChildType(work.type),
          title: `Implement: ${ac.description.slice(0, 50)}`,
          description: `Address acceptance criterion: ${ac.description}`,
          acceptanceCriteria: [{ description: ac.description }],
        });
      }
    }

    // Based on effort
    if (work.effort.size === 'large' || work.effort.size === 'epic') {
      rationale.push('Large effort suggests breaking into smaller pieces');
    }

    // Based on complexity
    if (work.effort.complexity === 'complex' || work.effort.complexity === 'very_complex') {
      rationale.push('High complexity benefits from incremental approach');
    }

    return { suggestedChildren, rationale };
  }

  // --------------------------------------------------------------------------
  // DEPENDENCY MANAGEMENT
  // --------------------------------------------------------------------------

  /**
   * Add dependency between work items
   */
  addDependency(
    fromId: string,
    toId: string,
    type: 'blocks' | 'requires' | 'relates_to',
    isBlocking = type === 'blocks',
  ): WorkPrimitive | null {
    const from = this.get(fromId);
    const to = this.get(toId);
    if (!from || !to) return null;

    // Check for cycles
    if (this.wouldCreateCycle(fromId, toId)) {
      throw new Error('Adding this dependency would create a cycle');
    }

    const dependency: WorkDependency = {
      dependsOnId: toId,
      type,
      description: '',
      isBlocking,
      status: to.status === 'completed' ? 'satisfied' : 'pending',
      createdAt: new Date().toISOString(),
    };

    return this.storage.updateWorkPrimitive(fromId, {
      dependencies: [...from.dependencies, dependency],
    });
  }

  /**
   * Remove dependency
   */
  removeDependency(fromId: string, toId: string): WorkPrimitive | null {
    const from = this.get(fromId);
    if (!from) return null;

    return this.storage.updateWorkPrimitive(fromId, {
      dependencies: from.dependencies.filter((d) => d.dependsOnId !== toId),
    });
  }

  /**
   * Get items that depend on this item
   */
  getDependents(id: string): WorkPrimitive[] {
    const all = this.query({});
    return all.filter((w) => w.dependencies.some((d) => d.dependsOnId === id));
  }

  /**
   * Get blocking dependencies for an item
   */
  getBlockingDependencies(work: WorkPrimitive): WorkDependency[] {
    return work.dependencies.filter(
      (d) => d.isBlocking && d.status !== 'satisfied',
    );
  }

  // --------------------------------------------------------------------------
  // TEMPLATES
  // --------------------------------------------------------------------------

  /**
   * Create work item from template
   */
  createFromTemplate(
    templateId: string,
    overrides: Partial<CreateWorkInput> = {},
    createdBy?: string,
  ): WorkPrimitive | null {
    const template = this.storage.getWorkTemplate(templateId);
    if (!template) return null;

    // Apply template patterns
    const title = overrides.title ??
      template.defaultTitlePattern.replace(/\{[^}]+\}/g, '');
    const description = overrides.description ??
      template.defaultDescriptionPattern.replace(/\{[^}]+\}/g, '');

    const work = this.create(
      {
        type: template.workType,
        title,
        description,
        labels: [...template.defaultLabels.map((l) => l.name), ...(overrides.labels ?? [])],
        effort: { ...template.defaultEffort, ...overrides.effort },
        ...overrides,
      },
      createdBy,
    );

    // Create suggested steps as children
    if (template.suggestedSteps.length > 0) {
      for (const step of template.suggestedSteps) {
        this.create({
          type: 'step',
          title: step.title,
          description: step.description,
          parentId: work.id,
          acceptanceCriteria: step.acceptanceCriteria.map((d) => ({ description: d })),
        });
      }
    }

    // Track template usage
    this.storage.incrementTemplateUsage(templateId, true);

    return this.get(work.id);
  }

  /**
   * Get all available templates
   */
  getTemplates(): WorkTemplate[] {
    return this.storage.getAllWorkTemplates();
  }

  /**
   * Get template by name
   */
  getTemplateByName(name: string): WorkTemplate | null {
    return this.storage.getWorkTemplateByName(name);
  }

  /**
   * Save a new template
   */
  saveTemplate(
    template: Omit<WorkTemplate, 'id' | 'usageCount' | 'successRate' | 'createdAt' | 'updatedAt'>,
  ): WorkTemplate {
    return this.storage.saveWorkTemplate(template);
  }

  // --------------------------------------------------------------------------
  // PROGRESS & REPORTS
  // --------------------------------------------------------------------------

  /**
   * Get progress summary for a work item and its children
   */
  getProgress(id?: string): WorkProgressSummary {
    const items = id ? this.getHierarchy(id) : this.query({});

    const completed = items.filter((w) => w.status === 'completed').length;
    const inProgress = items.filter((w) => w.status === 'in_progress').length;
    const blocked = items.filter((w) => w.status === 'blocked').length;
    const pending = items.filter(
      (w) => ['draft', 'planned', 'ready'].includes(w.status),
    ).length;

    const totalEffort = items
      .filter((w) => w.status !== 'completed' && w.status !== 'cancelled')
      .reduce((sum, w) => sum + this.effortToNumber(w.effort), 0);

    return {
      totalItems: items.length,
      completed,
      inProgress,
      blocked,
      pending,
      completionRate: items.length > 0 ? completed / items.length : 0,
      estimatedRemaining: {
        items: pending + inProgress + blocked,
        effort: totalEffort > 0
          ? {
              complexity: 'medium',
              size: totalEffort > 20 ? 'epic' : totalEffort > 10 ? 'large' : 'medium',
              confidence: { score: 0.5, level: 'probable', factors: [], needsResearch: true },
            }
          : null,
      },
    };
  }

  /**
   * Generate work report
   */
  generateReport(options?: {
    rootId?: string;
    includeCompleted?: boolean;
    includeMetrics?: boolean;
  }): WorkReport {
    const items = options?.rootId
      ? this.getHierarchy(options.rootId)
      : this.query({});

    const filteredItems = options?.includeCompleted
      ? items
      : items.filter((w) => w.status !== 'completed' && w.status !== 'cancelled');

    // Group by status
    const byStatus: Record<string, WorkPrimitive[]> = {};
    for (const item of filteredItems) {
      if (!byStatus[item.status]) {
        byStatus[item.status] = [];
      }
      byStatus[item.status].push(item);
    }

    // Calculate metrics
    const metrics: WorkMetrics = {
      total: items.length,
      byStatus: Object.fromEntries(
        Object.entries(byStatus).map(([status, items]) => [status, items.length]),
      ),
      byType: this.groupByType(items),
      completionRate: this.getProgress(options?.rootId).completionRate,
      averageTimeInStatus: {}, // Would require more tracking
      blockedPercentage: byStatus['blocked']
        ? byStatus['blocked'].length / items.length
        : 0,
    };

    // Identify issues
    const issues: Array<{ type: string; description: string; itemId: string }> = [];

    // Long-running items
    const now = new Date();
    for (const item of byStatus['in_progress'] ?? []) {
      const startTime = item.statusHistory
        .filter((s) => s.to === 'in_progress')
        .pop()?.changedAt;
      if (startTime) {
        const days = (now.getTime() - new Date(startTime).getTime()) / (1000 * 60 * 60 * 24);
        if (days > 7) {
          issues.push({
            type: 'long_running',
            description: `In progress for ${Math.round(days)} days`,
            itemId: item.id,
          });
        }
      }
    }

    // Blocked items
    for (const item of byStatus['blocked'] ?? []) {
      issues.push({
        type: 'blocked',
        description: item.notes.find((n) => n.type === 'blocker')?.content ?? 'Blocked',
        itemId: item.id,
      });
    }

    return {
      generatedAt: new Date().toISOString(),
      scope: options?.rootId ?? 'all',
      summary: {
        total: items.length,
        completed: items.filter((w) => w.status === 'completed').length,
        inProgress: byStatus['in_progress']?.length ?? 0,
        blocked: byStatus['blocked']?.length ?? 0,
        pending: filteredItems.length - (byStatus['in_progress']?.length ?? 0) - (byStatus['blocked']?.length ?? 0),
      },
      metrics: options?.includeMetrics ? metrics : undefined,
      issues,
      recommendations: this.generateRecommendations(items, issues),
    };
  }

  // --------------------------------------------------------------------------
  // ACCEPTANCE CRITERIA
  // --------------------------------------------------------------------------

  /**
   * Mark acceptance criterion as met
   */
  markCriterionMet(
    workId: string,
    criterionId: string,
    evidence?: {
      type: 'test_pass' | 'code_review' | 'manual_verification';
      description: string;
    },
    verifiedBy?: string,
  ): WorkPrimitive | null {
    const work = this.get(workId);
    if (!work) return null;

    const now = new Date().toISOString();

    const updatedCriteria = work.acceptanceCriteria.map((ac) => {
      if (ac.id === criterionId) {
        return {
          ...ac,
          isMet: true,
          metAt: now,
          metBy: verifiedBy,
          evidence: evidence
            ? {
                type: evidence.type,
                description: evidence.description,
                collectedAt: now,
              }
            : undefined,
          confidence: { score: 0.9, level: 'verified' as const, factors: [], needsResearch: false },
        };
      }
      return ac;
    });

    return this.storage.updateWorkPrimitive(workId, {
      acceptanceCriteria: updatedCriteria,
    });
  }

  /**
   * Add acceptance criterion
   */
  addAcceptanceCriterion(
    workId: string,
    criterion: { description: string; verificationMethod?: string },
  ): WorkPrimitive | null {
    const work = this.get(workId);
    if (!work) return null;

    const newCriterion: AcceptanceCriterion = {
      id: randomUUID(),
      description: criterion.description,
      verificationMethod: criterion.verificationMethod
        ? { type: criterion.verificationMethod as 'manual' | 'automated' | 'review', details: '' }
        : { type: 'manual', details: '' },
      isMet: false,
      confidence: { score: 0.7, level: 'established', factors: [], needsResearch: false },
    };

    return this.storage.updateWorkPrimitive(workId, {
      acceptanceCriteria: [...work.acceptanceCriteria, newCriterion],
    });
  }

  // --------------------------------------------------------------------------
  // PRIVATE HELPERS
  // --------------------------------------------------------------------------

  private validateTransition(
    work: WorkPrimitive,
    newStatus: WorkStatus,
  ): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Define valid transitions
    const validTransitions: Record<WorkStatus, WorkStatus[]> = {
      draft: ['planned', 'cancelled'],
      planned: ['ready', 'blocked', 'cancelled'],
      ready: ['in_progress', 'blocked', 'cancelled'],
      in_progress: ['completed', 'blocked', 'on_hold', 'cancelled'],
      blocked: ['ready', 'in_progress', 'cancelled'],
      on_hold: ['ready', 'in_progress', 'cancelled'],
      completed: ['in_progress'], // Reopen
      cancelled: ['draft'], // Resurrect
    };

    const allowed = validTransitions[work.status];
    if (!allowed || !allowed.includes(newStatus)) {
      errors.push(`Cannot transition from ${work.status} to ${newStatus}`);
    }

    // Additional checks for completion
    if (newStatus === 'completed') {
      const unmetCriteria = work.acceptanceCriteria.filter((ac) => !ac.isMet);
      if (unmetCriteria.length > 0) {
        errors.push(`${unmetCriteria.length} acceptance criteria not met`);
      }
    }

    return { valid: errors.length === 0, errors };
  }

  private updateParentStatus(parentId: string): void {
    const parent = this.get(parentId);
    if (!parent) return;

    const children = this.getChildren(parentId);
    if (children.length === 0) return;

    // Determine parent status based on children
    const allCompleted = children.every((c) => c.status === 'completed');
    const anyBlocked = children.some((c) => c.status === 'blocked');
    const anyInProgress = children.some((c) => c.status === 'in_progress');

    let newStatus: WorkStatus | null = null;

    if (allCompleted) {
      newStatus = 'completed';
    } else if (anyBlocked && !anyInProgress) {
      newStatus = 'blocked';
    } else if (anyInProgress) {
      newStatus = 'in_progress';
    }

    if (newStatus && newStatus !== parent.status) {
      this.transition(parentId, newStatus, {
        reason: 'Auto-updated based on children status',
      });
    }
  }

  private updateDependentStatuses(completedId: string, newStatus: WorkStatus): void {
    if (newStatus !== 'completed') return;

    const dependents = this.getDependents(completedId);
    for (const dependent of dependents) {
      const updatedDeps = dependent.dependencies.map((d) => {
        if (d.dependsOnId === completedId) {
          return { ...d, status: 'satisfied' as const };
        }
        return d;
      });

      this.storage.updateWorkPrimitive(dependent.id, { dependencies: updatedDeps });
    }
  }

  private wouldCreateCycle(fromId: string, toId: string): boolean {
    // Check if toId depends (directly or transitively) on fromId
    const visited = new Set<string>();
    const queue = [toId];

    while (queue.length > 0) {
      const current = queue.shift()!;
      if (current === fromId) return true;
      if (visited.has(current)) continue;
      visited.add(current);

      const work = this.get(current);
      if (work) {
        queue.push(...work.dependencies.map((d) => d.dependsOnId));
      }
    }

    return false;
  }

  private inferChildType(parentType: WorkPrimitiveType): WorkPrimitiveType {
    const hierarchy: Record<WorkPrimitiveType, WorkPrimitiveType> = {
      epic: 'story',
      story: 'task',
      task: 'step',
      step: 'checkpoint',
      checkpoint: 'checkpoint',
      research: 'task',
      decision: 'task',
      spike: 'task',
      debt: 'task',
      incident: 'task',
      maintenance: 'task',
      experiment: 'task',
    };
    return hierarchy[parentType] ?? 'task';
  }

  private effortToNumber(effort: EffortEstimate): number {
    const sizeValues: Record<string, number> = {
      trivial: 1,
      small: 2,
      medium: 5,
      large: 13,
      epic: 34,
    };
    const complexityMultiplier: Record<string, number> = {
      trivial: 0.5,
      simple: 0.8,
      medium: 1,
      complex: 1.5,
      very_complex: 2,
    };

    const size = sizeValues[effort.size ?? 'medium'] ?? 5;
    const complexity = complexityMultiplier[effort.complexity ?? 'medium'] ?? 1;

    return size * complexity;
  }

  private getLabelColor(label: string): string {
    const colorMap: Record<string, string> = {
      bug: '#d73a4a',
      feature: '#0075ca',
      enhancement: '#a2eeef',
      documentation: '#0075ca',
      urgent: '#d73a4a',
      technical_debt: '#fbca04',
    };
    return colorMap[label.toLowerCase()] ?? '#ededed';
  }

  private groupByType(items: WorkPrimitive[]): Record<string, number> {
    const byType: Record<string, number> = {};
    for (const item of items) {
      byType[item.type] = (byType[item.type] ?? 0) + 1;
    }
    return byType;
  }

  private generateRecommendations(
    items: WorkPrimitive[],
    issues: Array<{ type: string; description: string; itemId: string }>,
  ): string[] {
    const recommendations: string[] = [];

    // High blocked percentage
    const blockedCount = issues.filter((i) => i.type === 'blocked').length;
    if (blockedCount > items.length * 0.2) {
      recommendations.push(
        'High percentage of blocked items - consider dedicating time to unblock or re-evaluate dependencies',
      );
    }

    // Long running items
    const longRunning = issues.filter((i) => i.type === 'long_running').length;
    if (longRunning > 0) {
      recommendations.push(
        `${longRunning} items have been in progress for over a week - consider breaking them down or removing blockers`,
      );
    }

    // Large items without children
    const largeWithoutChildren = items.filter(
      (w) =>
        (w.effort.size === 'large' || w.effort.size === 'epic') &&
        w.childIds.length === 0 &&
        w.status !== 'completed',
    );
    if (largeWithoutChildren.length > 0) {
      recommendations.push(
        `${largeWithoutChildren.length} large items could benefit from decomposition`,
      );
    }

    return recommendations;
  }
}
